{"version":"1.0","sequence":130,"releaseAt":772210800,"items":[{"location":"https:\/\/medium.com\/@simpleandkind788\/11-genius-ways-to-use-your-iphones-usb-c-port-beyond-just-charging-d850d132dccd","title":"11 Genius Ways to Use Your iPhone’s USB-C Port Beyond Just Charging | by Zeeshan Saghir ","keywords":["Hardware","영어"],"comments":"USB-C 포트 악세서리 많이 쓰시나요? 충전 뿐만 아니고 다양한 용도로 확장할 수 있으니까요 ","summary":""},{"location":"https:\/\/www.timc.dev\/posts\/the-cost-of-running-a-conference\/?","title":"25,000 running a successful conference | Tim Condon","keywords":["Culture","영어"],"comments":"영국에서도 개인이 주도한 스위프트 서버 사이드 컨퍼런스를 하고 25,000 파운드 (대략 한화로 4660만원) 손실을 냈다는 글입니다. 와 영국도 물가 장난아니네요 ","summary":"팀 콘돈은 성공적인 컨퍼런스를 운영하면서 영업 손실을 경험한 실화를 공유하며, 컨퍼런스 준비의 복잡함과 재정적 부담을 설명합니다. 그는 최근 서버사이드 스위프트(Swift) 컨퍼런스의 티켓 가격 인상에 대해 일부 의견을 받았고, 이는 예산을 제대로 세우지 못한 결과로 25,000파운드의 손실을 초래했습니다. 그는 iOS 커뮤니티가 돈을 벌기 위해 컨퍼런스를 개최하지 않는 특성을 갖고 있음을 강조하며, 이로 인해 저렴하고 훌륭한 컨퍼런스가 많다고 언급합니다.\n\n2024년 컨퍼런스의 비용 구조에는 장소 임대료, 케이터링, AV 팀 비용 등이 포함되며, 특히 케이터링은 가장 큰 지출 항목으로 약 30,000파운드가 소요됩니다. 다른 부대비용도 고려해야 하며, 런던에서 개최되는 만큼 경비가 비쌉니다. 최종 비용은 약 80,000파운드로, 이는 대규모 기술 대회와 비교하면 적은 비용이지만, 개인이 조직하는 것 치고는 상당한 액수입니다.\n\n콘퍼런스 참가를 통해 지역 사회를 지원하라고 독려하며, 참가 및 후원이 지역 커뮤니티에 큰 도움이 된다고 강조합니다. 끝으로 그는 컨퍼런스를 조직하는 보람을 이야기하며, 참석자들의 즐거움과 새로운 아이디어 공유가 가장 큰 성취라는 점을 언급합니다.\n\n**핵심 키워드**: 컨퍼런스, 비용, 지역 사회, 지원, 보람"},{"location":"https:\/\/www.natashatherobot.com\/p\/swift-prompt-engineering-apples-foundationmodels?","title":"A Swift Developer’s Guide to Prompt Engineering with Apple’s FoundationModels","keywords":["AI\/ML"],"comments":"애플 플랫폼에서도 파운데이션 모델이 나오면서 전용 프롬프트 엔지니어링 가이드 사례가 나오고 있네요. 스위프트 코드로 프롬프트 엔지니어링이 필요한 시기가 됐네요","summary":""},{"location":"https:\/\/levelup.gitconnected.com\/apples-liquid-glass-threatens-hybrid-apps-d4678576664f","title":"Apple’s Liquid Glass Threatens Hybrid Apps | by Attila Vágó ","keywords":["Culture"],"comments":"애플의 새로운 디자인 언어 \"리퀴드 글래스\" 때문에 단순 UI 변화가 아니라 운영체제와 연계된 규칙이 있어서 하이브리드 앱 생태계를 위협한다는 글입니다. 그런 부분도 있겠네요","summary":"애플이 발표한 '리퀴드 글라스(Liquid Glass)'는 하이브리드 앱 개발에 대한 큰 변화를 예고하고 있습니다. 리퀴드 글라스는 예전의 플랫 디자인과는 다른 새로운 UI 디자인 언어로, 이는 하이브리드 앱의 미래에 부정적인 영향을 미칠 가능성이 큽니다. 아이오닉(Ionic)이나 플러터(Flutter)와 같은 하이브리드 프레임워크가 이전에 성공할 수 있었던 주된 이유가 플랫 디자인에 있었음에도 불구하고, 애플의 새로운 디자인 언어는 이러한 개념을 무효화할 수 있습니다.\n\n리퀴드 글라스는 단순한 UI의 변화가 아니라, 애플 OS와 깊이 통합되어 있으며, 이를 사용해 하이브리드 앱을 개발하는 것이 점점 어려워질 것입니다. 여러 가지 구현 규칙이 있어 UI 요소 간의 계층 구조를 고려해야 하며, 이로 인해 기존의 하이브리드 개발 방식은 점점 더 비효율적이 될 것입니다. 특히, 리퀴드 글라스는 접근성과 시인성을 중시하는 규정이 많아 Ionic이나 Flutter 같은 웹 기반 프레임워크에서 구현하기 어렵습니다.\n\n결국, 애플의 리퀴드 글라스는 하이브리드 개발 시대의 종말을 선언하는 신호탄일지도 모릅니다. 이에 따라 많은 개발자들이 다시 네이티브 개발로 돌아갈 것으로 예상됩니다.\n\n**핵심 키워드**: 리퀴드 글라스, 하이브리드 앱, 플랫 디자인, UI 디자인, 네이티브 개발"},{"location":"https:\/\/chamodshehanka.medium.com\/apples-new-containerization-framework-a-deep-dive-into-macos-s-future-for-developers-cf102643394a","title":"Apple’s New Containerization Framework: A Deep Dive into macOS’s Future for Developers | by Chamod Shehanka Perera ","keywords":["Framework"],"comments":"6월에 소개한 컨테이너 프레임워크에 대한 설명과 맥 개발 환경의 변화를 예고합니다. 이제 빠르고 격리가 쉬워지기 때문에 맥에서 샌드박스처럼 나눠서 동작하도록 다양한 변화가 가능할 것 같습니다","summary":""},{"location":"https:\/\/medium.com\/macoclock\/apples-working-on-a-true-budget-macbook-cheaper-than-the-macbook-air-8d7a65f87a09","title":"Apple’s Working on a True Budget MacBook (Cheaper Than the MacBook Air)! | by Michael Swengel ","keywords":["Hardware","영어"],"comments":"M5 칩이 들어간 맥북 말고 아이폰 16의 A18 계열이 들어간 가성비 좋은 맥북이 나올 수 있다는 루머가 있네요","summary":""},{"location":"https:\/\/steipete.me\/posts\/2025\/automatic-observation-tracking-uikit-appkit","title":"Automatic Observation Tracking in UIKit and AppKit: The Feature Apple Forgot to Mention | Peter Steinberger","keywords":["UIKit"],"comments":"지난 호에서도 소개했던 것처럼 iOS 18이상 UIKit 과 macOS 15이상 AppKit 에서 상태 변화를 Observation Tracking 방식으로 감지해서 다시 그리는 처리가 도입됩니다. SwiftUI 와 비슷한 형태가 가능해집니다","summary":""},{"location":"https:\/\/medium.com\/@dorangao\/building-a-scrollable-masonry-view-of-cards-in-swiftui-with-scroll-to-top-160f12cd3e10","title":"Building a Scrollable Masonry View of Cards in SwiftUI (with Scroll-to-Top) | by Doran Gao ","keywords":["SwiftUI"],"comments":"타일 형태로 보이는 카드가 계속 스크롤되는 앱을 만드는 과정을 상세하게 설명합니다 ","summary":"이 글에서는 SwiftUI에서 스크롤 가능한 카드의 매서리 뷰를 만드는 방법을 단계별로 설명합니다. 다목적 그리드 레이아웃은 다양한 앱에서 필요하며, 이미지를 포함한 카드 형태로 정보를 전시하는 것이 그 예입니다. 튜토리얼의 최종 결과물은 인용문과 이미지를 담고 있는 두 개의 열로 구성된 카드 그리드와 스크롤을 위로 올리는 버튼이 포함된 UI입니다.\n\n첫 단계에서는 카드에 표시할 데이터를 정의하기 위해 Quote 구조체를 생성합니다. 그 후, LazyVGrid를 사용하여 스크롤 가능한 그리드 레이아웃을 설정합니다. 두 번째 단계에서는 카드 뷰인 QuoteCard를 구축하여 각 카드의 이미지와 텍스트를 표시합니다. \n\n세 번째 단계에서는 특정 카드가 두 열을 걸쳐서 표시될 수 있는 기능을 소개하고, 이후에는 스크롤을 맨 위로 이동시키는 버튼을 추가하여 사용자 경험을 향상시킵니다. \n\n마지막으로 TabView에 통합하여 더 큰 애플리케이션의 일부로 사용될 수 있는 방법을 간략히 설명합니다. SwiftUI의 선언형 접근을 통해 복잡한 UI를 간단한 구성 요소로 조합하는 것이 가능함을 강조하고, LazyVGrid와 ScrollViewReader의 사용을 통해 효율적인 레이아웃과 사용자 네비게이션을 구현하는 방법을 제시합니다.\n\n**키워드**: SwiftUI, 매서리 뷰, LazyVGrid, 카드, 스크롤 기능"},{"location":"https:\/\/zottmann.org\/2025\/06\/13\/how-to-use-google-gemini.html","title":"Carlo Zottmann - How to use Google Gemini in Xcode 26 beta","keywords":["DeveloperTools","영어"],"comments":"Proxyman 도구를 활용해서 Xcode 26 코드 인텔리전스 기능에 구글 Gemini 모델을 연동하는 방식을 설명합니다","summary":""},{"location":"https:\/\/david-smith.org\/blog\/2025\/06\/27\/requiring-26\/?","title":"Considerations for New iOS Versions - David Smith, Independent iOS Developer","keywords":["Culture","영어"],"comments":"앱 개발자들에게 새로운 iOS 버전이 정식으로 나오면 기존 사용자를 지원해주는 것과 새로운 버전 사용자를 수용한 것에 대한 딜레마와 고민을 이야기 합니다","summary":"앱 개발자들은 새로운 iOS 버전 출시 시 누가 지원을 중단할 것인지에 대한 고민을 하게 됩니다. 두 가지 주요 고려 사항이 있습니다: 기존 사용자와 새로운 사용자에 대한 영향입니다. 기존 사용자들은 앱을 삭제하지 않는 한 기존 버전에서 계속 사용할 수 있으며, 새로운 업데이트를 받을 수 없습니다. 현재 많은 iOS 사용자들이 최신 버전으로 업데이트하는 경향이 있기 때문에, 예를 들어 최신 버전인 iOS 18만을 요구할 경우 약 13%의 기존 사용자가 영향을 받을 수 있습니다.\n\n반면 새로운 사용자들은 요구하는 iOS 버전이 더 높아지면 앱을 다운로드할 수 없게 됩니다. 새로운 버전 출시 초기에는 사용자가 적어지는 경향이 있어, 최신 버전만을 요구하면 초기 사용자를 크게 줄일 수 있습니다. 예를 들어, iOS 18에서 신규 다운로드가 60%에 달했으나, 이후 40%로 감소한 후 다시 증가했습니다. \n\n개발자는 일반적으로 신규 다운로드에서 손실이 1% 정도로 떨어질 때 요구 버전을 높이기로 결심하며, 그렇게 하지 않을 경우 기술적인 편리함이 비즈니스에 부정적인 영향을 미칠 수 있습니다.\n\n**주요 키워드:** iOS, 앱 개발, 사용자 영향, 신규 다운로드, 비즈니스 고려"},{"location":"https:\/\/daringfireball.net\/2025\/06\/apple_app_store_policy_updates_dma","title":"Daring Fireball: Apple Announces Sweeping but Complicated Policy Changes for Apps in the EU","keywords":["Culture","영어"],"comments":"애플이 유럽 연합의 규정을 준수하기 위해서 꽤 복잡한 변경 사항을 적용한다고 말합니다. 이제 외부 대체 스토어나 시장의 링크를 앱 스토어에서 프로모션할 수 있다고 합니다","summary":"애플은 유럽 연합(DMA)에서의 새로운 규정을 준수하기 위해 앱스토어 정책에 여러 가지 복잡한 변경 사항을 도입한다고 발표했습니다. 주된 내용은 다음과 같습니다.\n\n1. **통신 및 프로모션**: 개발자들은 이제 앱 내에서 디지털 상품 또는 서비스 구매를 위한 제안을 자유롭게 홍보할 수 있으며, 이를 지불할 수 있는 대체 웹사이트나 마켓플레이스 링크를 사용하여 가능합니다.\n\n2. **비즈니스 모델 전환**: 2026년 1월 1일부터 애플은 모든 EU 개발자에게 단일 비즈니스 모델로 전환할 예정입니다. 이 모델에 따라 기존의 기술 수수료(CTF)는 새로운 핵심 기술 위원회 수수료(CTC)로 대체됩니다.\n\n3. **계층형 앱 수수료**: 애플 앱스토어에 배포되는 앱은 13%에 해당하는 판매 수수료를 부담하며, 소규모 비즈니스 프로그램 회원에게는 10%로 할인됩니다. 'Tier One'에 참여할 경우 5% 수수료를 지불하지만, 몇몇 기능은 지원되지 않습니다.\n\n4. **자유로운 링크**: 개발자들은 제안 홍보를 위한 링크를 자유롭게 디자인하고, 그에 따른 트래킹도 가능해졌습니다.\n\n5. **비즈니스 조건 변경**: 새로운 사용자에게 제공된 디지털 상품 및 서비스 구매에 대해 초기 6개월 동안 2% 수수료가 부과되며, 소규모 비즈니스 프로그램 회원에게는 면제됩니다.\n\n전체적으로 애플의 새로운 정책은 복잡성과 불확실성을 더하고 있으며, 많은 개발자들이 새로운 수수료 구조를 이해하는 데 어려움을 겪고 있습니다.\n\n**주요 키워드**: 앱스토어, 디지털 시장법, 비즈니스 모델, 수수료, 개발자 정책"},{"location":"https:\/\/itnext.io\/demystifying-swiftuis-ignoredbylayout-b42d118a8b04","title":"Demystifying SwiftUI’s .ignoredByLayout() — How to Apply Geometry Effects Without Breaking Your Layout | by fatbobman ","keywords":["SwiftUI"],"comments":"`ignoredByLayout` 동작 방식을 여러 사례와 함께 설명하는 게 좋았습니다","summary":""},{"location":"https:\/\/www.donnywals.com\/designing-custom-ui-with-liquid-glass-on-ios-26\/?","title":"Designing custom UI with Liquid Glass on iOS 26 – Donny Wals","keywords":["SwiftUI","pick"],"comments":"디자인 카테고리로 분류하려다보니 리퀴드 글래스로 동작하는 커스텀 메뉴를 만드는 내용이라서 추천드립니다. 당분간 이런 실험이 필요할 것 같네요","summary":""},{"location":"https:\/\/christianselig.com\/2025\/05\/godot-ios-interop\/","title":"Embedding Godot games in iOS apps is easy now","keywords":["Framework","영어"],"comments":"이제 고도 게임 라이브러리를 기반으로 iOS 앱에 게임을 넣는 과정을 설명합니다. 한 번 만들어보고 싶어지더라구요","summary":""},{"location":"https:\/\/www.createwithswift.com\/exploring-a-new-visual-language-liquid-glass\/?","title":"Exploring a new visual language: Liquid Glass","keywords":["Design"],"comments":"리퀴드 글래스 동작과 구현을 한꺼번에 모아서 설명하는 글입니다","summary":""},{"location":"https:\/\/medium.com\/macoclock\/forget-iphone-17-this-is-apples-real-next-step-the-iphone-series-0ccf45e4dcd1","title":"Forget iPhone 17 — This Is Apple’s Real Next Step: The iPhone Series. | Mac O","keywords":["Hardware","영어"],"comments":"슬슬 아이폰 17 하드웨어 목업과 루머가 나오고 있습니다. 이 글은 17 그 다음이 더 흥미롭다고 강조합니다. 언제쯤 페이스아이디 카메라가 사라지고 완벽하게 edge-to-edge로 가득찬 화면이 될까요","summary":""},{"location":"https:\/\/generativeai.pub\/generative-ais-cliffs-of-insanity-36d3c9fffe26","title":"Generative AI’s Cliffs of Insanity | by Michael Long ","keywords":["AI\/ML"],"comments":"","summary":"이 글은 최근 프로그래밍 기사의 문제점을 다루고 있으며, 특히 생성적 AI의 한계를 강조하고 있습니다. 특정 Swift 언어에 대한 기사가 잘못된 정보를 담고 있다는 점을 지적하며, \"isEmpty\"와 \"count\"의 성능 차이에 대한 설명이 부정확하다고 주장합니다. 글쓴이는 생성적 AI가 통계적으로 생성된 응답을 제공하며, 이는 이해가 부족한 독자들에게 잘못된 정보를 퍼뜨릴 수 있다고 경고합니다.\n\n저자는 독자와 글쓴이 모두에게 생성적 AI로 작성된 기사를 사실 확인할 것을 촉구합니다. 저자는 작성자가 AI로 작성한 글을 믿기보다는 검증할 필요가 있음을 강조하며, 잘못된 정보는 코드의 불필요한 부채를 발생시킬 수 있다고 지적합니다. 결국, 생성적 AI는 자신이 제공하는 정보에 대해 신뢰할 수 없는 경향이 있으므로, 독자와 작성자는 정보를 비판적으로 검토해야 한다고 결론 짓습니다.\n\n요약하자면, 생성적 AI의 사용에 따른 정보의 불확실성과 사실 확인의 중요성을 강조하는 글입니다.\n\n**주요 키워드**: 생성적 AI, 사실 확인, Swift 프로그래밍, 정보 정확성, 코드 이해"},{"location":"https:\/\/fatbobman.com\/en\/posts\/how-to-detect-text-truncation-in-swiftui\/","title":"How to Detect Text Truncation in SwiftUI?","keywords":["SwiftUI","영어"],"comments":"문자열 문구가 잘리는 것을 판별하고 싶을 때 표시하는 영역 크기로 판단하는 방식을 제안합니다","summary":""},{"location":"https:\/\/andrewzuo.com\/if-you-ever-wondered-why-llms-suck-at-debugging-apple-has-an-answer-98220c5c83f5","title":"If You Ever Wondered Why LLMs Suck At Debugging Apple Has An Answer | by Andrew Zuo ","keywords":["AI\/ML"],"comments":"한동안 엄청 공격 받았던 애플의 LLM 그 논문에 대한 글입니다. LLM 으로 디버깅을 할 때 오류 수정이 원하는 방향에서 이루어지지 않고 과거의 불필요한 정보를 고집하는 경향성에 대해 언급합니다","summary":"이 글에서는 Apple의 연구 결과를 인용하여 대형 언어 모델(LLM)의 디버깅 능력의 한계를 설명하고 있습니다. LLM은 복잡한 문제를 처리할 때 성능 저하 현상인 '정확도 붕괴'를 경험할 수 있는데, 이는 문제 복잡성이 증가할수록 모델의 정확도가 급격히 낮아지는 현상을 나타냅니다. Apple의 연구는 LLM들이 논리적 사고를 수행할 능력이 부족하며, 단지 훈련 데이터에서 관찰된 추론 단계를 모방할 뿐이라고 주장합니다. \n\n특히, LLM의 오류 수정 과정을 설명하며, LLM이 알고리즘을 주어도 성능이 크게 향상되지 않는 경우가 많다고 지적합니다. 이는 LLM이 주어진 문제를 해결하는 대신 과거의 불필요한 정보를 고집하며, 그로 인해 추론 체인이 탈선할 수 있음을 의미합니다. \n\n마지막으로, 이러한 정확도 붕괴 문제를 해결하기 위해 기업들이 어떠한 접근을 취할지를 주목할 필요가 있으며, 기억의 망각이나 정보를 단순화하는 방법이 해결책이 될 수 있을 것이라고 제안합니다.\n\n**핵심 키워드**:  \n1. LLM  \n2. 디버깅  \n3. 정확도 붕괴  \n4. Apple 연구  \n5. 추론 오류  "},{"location":"https:\/\/medium.com\/macoclock\/is-apple-sabotaging-your-iphones-readability-the-master-plan-behind-ios-26-e51607b17f02","title":"Is Apple Sabotaging Your iPhone’s Readability? The Master Plan Behind iOS 26. | Mac O","keywords":["Culture"],"comments":"애플의 새 디자인 언어가 아이폰을 더 읽기 힘들게 만드는 걸까요? 기존 대비보다 더 밝고 투명해지면서 그런 영향도 있는 것 같기는 합니다. 이번 베타3를 써보니 좀 더 불투명해진 것 같습니다","summary":""},{"location":"https:\/\/uxdesign.cc\/liquid-glass-fragile-ux-and-why-i-wanted-2-weeks-before-writing-about-it-5dccafb5c28f","title":"Liquid glass, fragile UX, and why I wanted 2 weeks before writing about it | by Oleg Safranov ","keywords":["Design"],"comments":"디자이너 관점에서도 리퀴드 글래스와 유동적이면서 반투명한 방식이 꽤 사람들을 혼란스럽게 할 수 있다고 경고합니다","summary":"Apple은 iOS 26에서 'Liquid Glass'라는 새로운 UI를 선보이며 대담한 변화를 시도했습니다. 이 UI는 반투명한 질감과 빛의 굴절을 통해 사용자 경험을 시각적으로 매력적으로 만들어주며, 오래전의 매력적인 'Aqua 스타일'을 부활시킵니다. Liquid Glass는 단순한 시각 효과가 아니라, 실제 물질처럼 동작하고 반응합니다. 이는 사용자에게 즉각적이고 즐거움을 주는 디자인으로서, 매력적인 인터페이스는 사용성도 높아진다는 미적인 사용성 효과를 보여줍니다.\n\n그러나 이러한 변화는 특별히 시각 장애인을 포함한 다양한 사용자의 접근성에 대한 우려도 낳고 있습니다. 인터페이스의 유동적이고 반투명한 특성은 가독성을 떨어뜨리며, 누군가에게는 혼란스러울 수 있습니다. 이러한 이유로 Apple은 'Reduce Motion'과 같은 기능을 제공하여 사용자가 인터페이스를 조정할 수 있도록 돕고 있습니다.\n\nLiquid Glass는 자연적인 깊이와 계층감을 제공하지만, 디자이너들에게는 과도한 사용을 경계할 것을 요구하고 있습니다. 이 변화는 UI 디자인의 미래에 대한 중요한 질문을 던지며, 사용자의 경험과 기술 발전을 함께 고려해야 한다는 필요성을 시사합니다. \n\n- 핵심 키워드: Liquid Glass, UI 디자인, 접근성, 사용자 경험, Apple"},{"location":"https:\/\/medium.com\/@andreask_75652\/m-series-macs-gpu-accelerated-containers-f09d5e54a1b2","title":"M-series Macs & GPU-Accelerated Containers | by Andreas Kunar ","keywords":["AI\/ML","영어","pick"],"comments":"저도 처음 알게된 내용인데 이제 M 시리즈 맥에서 podman 으로 Vulkan API 호출을 하면 격리된 상태로 GPU 가속을 받을 수 있다고 하네요","summary":"M-시리즈 Mac에서 GPU 가속화된 컨테이너를 사용하는 방법에 대한 정보가 제공되어 있습니다. Apple-Silicon Mac에서는 AI와 같은 GPU 집약적 작업을 위해 일반적인 컨테이너 소프트웨어를 사용할 수 없었으나, 이제는 Podman을 통한 Vulkan API 호출을 활용하여 M-시리즈 GPU를 사용할 수 있게 되었습니다. 여기서는 llama.cpp를 예제로 GPU 가속화된 컨테이너를 구축하는 방법을 설명합니다.\n\nPodman과 krunkit을 설치하고 Fedora 40 운영체제를 사용하는 컨테이너의 기본 이미지를 구축한 후, llama.cpp를 설치하고 실행하는 방법이 단계별로 안내됩니다. GPU-컨테이너는 CPU 전용 컨테이너보다 약 40% 느리지만, GPU를 활용하면 프로세스 속도가 3배 빨라지는 것으로 나타났습니다.\n\n시험 결과, M2 Max에서 GPU를 사용할 경우 성능 향상이 있음을 보여주며, CPU 전용 컨테이너와 비교하여 GPU-가속을 사용하는 것이 더 효과적입니다. 이 실험은 AI 관련 다양한 응용 프로그램을 개발하고 사용하기 위해 적합합니다.\n\n요약하자면, M-시리즈 Mac에서 GPU 가속화된 컨테이너를 통해 AI 작업을 보다 효율적으로 수행할 수 있는 방법과 기술적 세부 사항을 제공하는 글입니다.\n\n**키워드:** M-시리즈 Mac, GPU 가속화, Podman, llama.cpp, 컨테이너"},{"location":"https:\/\/medium.com\/macoclock\/macos-finder-still-sucks-in-2025-89803ef03a2f","title":"MacOS Finder Still Sucks in 2025 | Mac O","keywords":["Culture"],"comments":"파인더는 여전히 10년전 인터페이스에서 벗어나지 못한다고 강조합니다. 익숙함과 새로움의 차이에서 더 발전할 부분을 놓치지 않았으면 좋겠네요","summary":""},{"location":"https:\/\/levelup.gitconnected.com\/no-swift-structs-dont-use-copy-on-write-32884d14664e","title":"No, Swift Structs Don’t Use Copy-On-Write | by Michael Long ","keywords":["Swift"],"comments":"스위프트에서 모든 구조체가 COW를 지원하는 건 아니라는 것을 다시 한 번 강조합니다. 개발자가 직접 선언한 구조체는 그냥 복사만 되기 때문에 COW가 필요한 경우는 따로 구현을 해야합니다","summary":"이 글에서는 Swift의 구조체(Struct)와 관련된 잘못된 정보인 'Copy-On-Write' (COW)에 대한 오해를 다룹니다. 많은 개발자들이 Swift의 구조체가 COW를 사용한다고 믿고 있지만, 이는 사실이 아닙니다. Swift의 구조체는 값 의미(value semantics)를 가집니다. 즉, 구조체를 다른 변수에 할당하거나 함수에 전달할 때, 복사본이 만들어지며 본래의 값에는 영향을 주지 않습니다.\n\nCOW는 특정 Swift 표준 라이브러리 타입(예: String, Array 등)에서 구현되어 있어 이들 타입은 내부적으로 참조 카운팅을 사용하여 효율적인 메모리 관리를 수행하지만, 이는 구조체 전반에 해당되지 않습니다. 대부분의 사용자 정의 구조체는 메모리 공유가 없으며, 할당 시 항상 복사됩니다.\n\n또한, 구조체 내에 참조 타입이 포함될 경우는 얕은 복사가 이루어져 참조가 공유될 수 있습니다. 이 때문에 같은 구조체 내에서 값의 변경이 원래 값에 영향을 미칠 수 있습니다. \n\nCOW에 대한 잘못된 정보는 블로그, StackOverflow, AI 시스템 등에서 반복적으로 전파되고 있으며, 특히 초보자들에게 혼란을 주기 때문에 명확히 이해하고 수정할 필요가 있다는 점을 강조했습니다.\n\n**주요 키워드**: Swift, 구조체, Copy-On-Write, 잘못된 정보, 값 의미"},{"location":"https:\/\/blog.stackademic.com\/rip-flutter-apples-ios-26-liquid-glass-just-changed-the-game-what-happened-to-cross-platform-l-dfe2dd7e2a7a","title":"RIP Flutter? Apple’s iOS 26 (Liquid Glass) Just Changed the Game — What Happened to Cross-Platform Languages? | by Koti Avula ","keywords":["Culture"],"comments":"iOS 26에서 디자인 언어 도입으로 플러터처럼 자체 UI 요소를 그리는 경우는 뒤쳐질 수 밖에 없습니다. iOS 사용자 경험을 위해서는 네이티브 앱이 더 필요한 시점입니다","summary":"최근 iOS 26의 \"Liquid Glass\" 디자인 시스템 출시로 인해 크로스 플랫폼 개발이 위기를 맞고 있다는 소식이 전해지고 있습니다. Flutter와 React Native는 과거에는 각각 iOS와 Android 애플리케이션 개발에 큰 기여를 했지만, iOS 26의 혁신적 변화는 두 프레임워크의 한계점을 드러내고 있습니다.\n\niOS 26에서 애플은 Liquid Glass UI를 도입하여 레이아웃의 근본적인 렌더링 방식을 변화시켰습니다. 이 새로운 시스템은 실시간 환경, 화면 곡률, 햅틱 반응 등을 고려해 UI 요소들을 더욱 반응적으로 만듭니다. Flutter는 Skia 렌더러를 사용하고 있어 이러한 새로운 하드웨어 통합을 활용하지 못하고 브랜드 이미지가 고전적으로 보일 위험이 있습니다. 반면 React Native는 네이티브 컴포넌트로의 직접 연결을 통해 개선되었지만, SwiftUI의 고급 기능은 여전히 이식성이 부족한 상황입니다.\n\n애플의 메시지는 명확합니다. 최상의 성능과 사용자 경험을 원한다면 네이티브로 개발해야 하며, 크로스 플랫폼 개발의 미래는 불투명합니다. 개발자들은 SwiftUI를 배우기 시작해야 할 필요성이 커지고 있으며, Flutter와 React Native는 여전히 MVP나 안드로이드 중심의 앱에서 유용하지만, iOS 사용자 경험을 중시하는 경우 네이티브 개발이 필수적이라고 할 수 있습니다.\n\n**핵심 단어:**\n1. 크로스 플랫폼\n2. iOS 26\n3. Liquid Glass\n4. Flutter\n5. React Native"},{"title":"Real-time systems with Combine and WebSockets | by Jacob Bartlett ","keywords":["Framework"],"summary":"이 글에서는 Combine과 WebSocket을 사용해 실시간 시스템을 구축하는 방법을 설명합니다. 저자는 2019년 Combine 출시 당시 중급 개발자로서 이를 활용하여 복잡성을 줄이고 반응형 시스템을 손쉽게 디자인할 수 있었다고 강조합니다. WebSocket은 TCP\/IP 네트워크 스택 위에서 작동하며, 지속적인 양방향 통신을 가능하게 하여 데이터를 효율적으로 전송하는데 적합합니다.\n\n저자가 제시하는 세 가지 실제 예시는 연결된 온도 조절 장치, 실시간 경매 시스템, 온라인 게임입니다. 각각의 경우에서 WebSocket을 통해 실시간 데이터를 수신하고 Combine을 통해 UI와 연결합니다. \n\n1. **연결된 온도 조절 장치**는 WebSocket에서 수신한 데이터를 UI에 바인딩해 변화를 실시간으로 표시합니다.\n2. **실시간 경매**는 Combine을 사용하여 실시간 입찰 데이터를 처리하고, UI에 실시간으로 반영합니다. 이 과정에 백프레셔와 버퍼링을 활용하여 데이터를 적절히 관리합니다.\n3. **온라인 게임**에서는 캐릭터의 위치를 실시간으로 업데이트하는 예제도 보여주며, 중복 데이터 제거 및 필터링을 통해 처리 성능을 높입니다.\n\n결론적으로, Combine은 반응형 경험을 만드는 데 이상적인 도구이며, WebSocket과 함께 사용하면 실시간 상호작용이 매끄럽게 이루어질 수 있습니다.\n\n**키워드:** Combine, WebSocket, 실시간 시스템, SwiftUI, 프로그래밍","comments":"웹소켓을 사용해서 Combine 방식으로 지속적인 양방향 통신을 구현하는 예시를 설명합니다. `URLSessionWebSocketTask` 로 설명하고 있지만 NWProtocolWebSocket 방식과 비교해보는 것도 좋습니다","location":"https:\/\/levelup.gitconnected.com\/real-time-systems-with-combine-and-websockets-25cb56c5e169"},{"title":"Reverse-Engineering Xcode's Coding Intelligence prompt","keywords":["DeveloperTools"],"summary":"","comments":"Proxyman 도구를 사용해서 네트워크 감시를 통해서 Xcode 내부 코딩 인텔리전스 프롬프트를 살펴본 내용입니다. 몇 가지 우선순위가 있는 게 포인트네요","location":"https:\/\/peterfriese.dev\/blog\/2025\/reveng-xcode-coding-intelligence\/?"},{"title":"Schedule a countdown timer with AlarmKit","keywords":["Framework","영어"],"summary":"","comments":"알람키트로 카운트다운 타이머를 만드는 방식을 설명합니다","location":"https:\/\/nilcoalescing.com\/blog\/CountdownTimerWithAlarmKit\/?"},{"title":"Sparkle: Distribution apps in- and out of the Mac App Store - SwiftLee","keywords":["AppKit"],"summary":"","comments":"맥 앱 스토어 외부에서 배포할 때 앱 업데이트를 도와주는 Sparkle 도입과 혼용에 대해 설명합니다","location":"https:\/\/www.avanderlee.com\/xcode\/sparkle-distribution-apps-in-and-out-of-the-mac-app-store\/?"},{"title":"Swift 6.2 Just Changed NotificationCenter Forever — Here’s How to Use It Safely with Type-Safe Messages | by Koti Avula ","keywords":["Swift"],"summary":"","comments":"스위프트 6.2부터 NotificationCenter에 MainActorMessage와 AsyncMessage 확장을 제공합니다. 이거 생각보다 간편하겠네요","location":"https:\/\/blog.stackademic.com\/swift-6-2-just-changed-notificationcenter-forever-heres-how-to-use-it-safely-with-type-safe-5f0897f3e524"},{"title":"Swift 6.2: Approachable Concurrency & Default Actor Isolation Issues | by Michael Long ","keywords":["Swift"],"summary":"Swift 6.2는 새로운 설정을 추가해 'Approachable Concurrency'와 'Default Actor Isolation'을 지원합니다. 이 기능들은 비동기 코드의 이해를 쉽게 하고, 주요 실행 컨텍스트인 MainActor를 사용하게 하여 코드의 효율성을 높입니다. 특히, MainActor에 모든 함수가 기본적으로 속하게 하여 레거시 코드에 간섭을 최소화합니다.\n\n'Approachable Concurrency'는 동기 함수와 비동기 함수의 실행 방식을 통합하여, MainActor의 컨텍스트를 자동으로 상속받게 해 개발자는 비동기 함수의 실행 흐름을 더 쉽게 이해하게 만듭니다. 반면 'Default Actor Isolation'은 코드베이스 전체에 기본 Actor를 설정할 수 있도록 해, 각각의 함수에 MainActor를 명시하기 필요성을 줄입니다. \n\n하지만 모든 코드가 MainThread에서 실행되면 성능 문제가 발생할 수 있습니다. 이러한 경우, Swift 6.2에서는 '@concurrent' 주석을 사용하여 비동기 함수를 별도의 스레드에서 실행하도록 설정하는 방법을 제공합니다. \n\n코드는 Swift 컴파일러 설정에서 두 가지 기능을 활성화할 수 있으며, Xcode 26 이상의 버전에서만 사용할 수 있습니다. 이는 개발자들이 복잡한 비동기 처리를 보다 용이하게 이해하고, 안전하게 사용할 수 있도록 돕는 것이 목표입니다.\n\n**키워드:** Swift 6.2, 비동기 처치, MainActor, @concurrent, 코드베이스","comments":"스위프트 6.2부터는 새로운 설정을 통해서 기본 액터 격리 방식을 지원합니다. 동시성을 지원하면서 함수가 어떤 대상에서 실행되는지 미리 판단하는 게 더 중요해졌습니다","location":"https:\/\/michaellong.medium.com\/swift-6-2-approachable-concurrency-default-actor-isolation-4e537ab21233"},{"summary":"","comments":"스위프트 내부에 안드로이드 워킹그룹이 생기네요. JNI도 지원한다는 데 스위프트가 앞으로 어디까지 확장하게 될까요. ","location":"https:\/\/medium.com\/@sharma-deepak\/swift-on-android-one-language-to-rule-them-all-cd75d9d37328","keywords":["Culture"],"title":"Swift on Android: Apple’s Language Now Officially Supports Android (2025 Guide) | by Deepak Sharma "},{"summary":"","comments":"","location":"https:\/\/levelup.gitconnected.com\/swiftui-search-api-searchable-all-we-need-to-know-all-in-one-d031ccaf7ea0","keywords":["Framework"],"title":"SwiftUI Search API (Searchable): All We Need to Know All In One! | by Itsuki "},{"summary":"","comments":"리퀴드 글래스 버튼 만들어서 이런저런 효과를 준 예시를 보여줍니다. 이게 잘 어울리게 만드는 게 은근 어려울 것 같네요","location":"https:\/\/www.natashatherobot.com\/p\/liquidglass-button-ios-26?","keywords":["SwiftUI","영어"],"title":"The Anatomy of a LiquidGlass Button in iOS 26"},{"summary":"","comments":"이번 macOS Tahoe 설치 버전은 T2 칩이 포함된 인텔맥이 마지막입니다. T2 칩부터 애플 실리콘으로 전환을 준비했다는 설명입니다. ","location":"https:\/\/medium.com\/@sohail_saifi\/the-hidden-arm-processors-in-every-intel-mac-and-why-apple-did-this-69594dbcca1b","keywords":["Hardware"],"title":"The Hidden ARM Processors in Every Intel Mac (And Why Apple Did This) | by Sohail Saifi "},{"summary":"","comments":"`@EnvironmentObject` 내부 동작을 설명합니다. ","location":"https:\/\/medium.com\/@mihaipopa\/under-the-hood-swiftui-environmentobject-6552e5f3bf2b","keywords":["SwiftUI"],"title":"Under the hood: SwiftUI EnvironmentObject | by Mihai Popa "},{"summary":"","comments":"이 글 좋네요. ViewBuilder가 뷰를 만들기 위해 차이를 비교하는 방식을 설명합니다","location":"https:\/\/medium.com\/airbnb-engineering\/understanding-and-improving-swiftui-performance-37b77ac61896","keywords":["SwiftUI","pick"],"title":"Understanding and Improving SwiftUI Performance | by Cal Stephens "},{"summary":"","comments":"이 두 개를 서로 비교할 대상인가 싶긴한데 각각 어떻게 구현하는지 비교해주는 방식이 좋네요","location":"https:\/\/medium.com\/ios-journeys\/viper-vs-tca-what-large-ios-teams-actually-use-0d44887cb0ba","keywords":["Architecture"],"title":"VIPER vs TCA: What Large iOS Teams Actually Use | by Kavya"},{"summary":"","comments":"Xcode 26 으로 진행하는 바이브 코딩 어떠신가요? 아직 완벽하지는 않고 나쁜 부분도 있지만 개인적으로는 만족스러운 편입니다. 여러분들은 어떠세요","location":"https:\/\/www.swiftwithvincent.com\/blog\/vibe-coding-in-xcode-26-is-it-good?","keywords":["DeveloperTools","영어"],"title":"Vibe coding in Xcode 26: is it good? — Swift with Vincent"},{"summary":"","comments":"이제 Swift Testing도 다양한 형식이 추가되면서 예전 XCTest 시절과는 차이가 꽤 벌어지는 것 같습니다. 저도 올해는 더 적극적으로 사용해봐야겠습니다","location":"https:\/\/rachelbrindle.com\/2025\/06\/26\/whats-new-in-testing-swift-6-2\/","keywords":["Testing","영어"],"title":"What's new in Testing, 2025 Edition"},{"summary":"","comments":"개인적으로는 아주 관심이 많은 주제입니다. UI 화면에서 곳곳에 AI 영역이 생겨나고 있는데요 어떤 영역에 어떻게 표시되는 것이 좋은 것인가 고민이 많습니다","location":"https:\/\/uxdesign.cc\/where-should-ai-sit-in-your-ui-1710a258390e","keywords":["Design"],"title":"Where should AI sit in your UI? | by Sharang Sharma "},{"summary":"SwiftUI에서 MVVM(Model-View-ViewModel) 패턴이 실패하는 이유는 SwiftUI가 상태 소유권과 생명주기를 완전히 뒤바꾸기 때문입니다. SwiftUI는 뷰가 상태의 순수 함수로 작동하며, 이는 데이터를 기반으로 한 함수형 프로그래밍에 가깝습니다. 그러나 MVVM 패턴은 객체 지향적인 UI 프레임워크를 기반으로 하여 상태와 동작이 객체 안에 숨겨지는 구조를 유지합니다. MVVM의 사용은 SwiftUI의 데이터 중심 접근 방식을 복잡하게 만들어 결합성과 예측 가능성을 떨어뜨립니다.\n\nMVVM 지지자들은 MVVM의 수많은 장점에 대해 질문을 던지며, 주로 비즈니스 로직 위치와 뷰 테스트 방법 등에서 문제를 제기합니다. 그러나 MVVM은 SwiftUI의 장점을 해치고, 상태와 비즈니스 로직을 함수로 나누어 별도의 객체에 의존하도록 만듭니다. 그러므로 상태를 명시적으로 선언하고 생명주기를 관리하는 것이 더 효율적이며, SwiftUI의 특징인 구성 요소 기반 접근을 통해 더 나은 결과를 얻을 수 있습니다. \n\n결론적으로, SwiftUI에서는 ViewModel 없이 더 간편하고 확장 가능한 애플리케이션 구조가 가능하다는 것입니다.\n\n**핵심 키워드**: SwiftUI, MVVM, 함수형 프로그래밍, 상태 소유권, 데이터 중심 접근.","comments":"SwiftUI은 상태 소유권과 생명주기가 달라서 객체 안에 감춰진 MVVM 방식과 어긋하는 부분이 있어서 실패하기 쉽다고 말합니다","location":"https:\/\/medium.com\/@redhotbits\/why-mvvm-fails-in-swiftui-47f73b05b458","keywords":["Architecture"],"title":"Why MVVM Fails in SwiftUI | by Lazar Otasevic "},{"summary":"","comments":"`#Playground` 매크로 아직 잘 써먹지 못하는데 앞으로는 요긴하게 사용할 수 있을 것 같습니다. ","location":"https:\/\/www.avanderlee.com\/swift\/playground-macro-running-code-snippets-in-xcodes-canvas\/?","keywords":["DeveloperTools","영어"],"title":"`#Playground` Macro: Running Code Snippets in Xcode's canvas - SwiftLee"},{"summary":"","comments":"","location":"https:\/\/medium.com\/macoclock\/liquid-glass-in-ios-26-i-hated-it-cc17710cbc85","keywords":["Culture","영어"],"title":"iOS 26 Liquid Glass: Why I Hated the Redesign at First — And Now I’m Obsessed | Mac O"},{"summary":"Swift에서의 비동기 작업을 처리할 때, `Task {}`와 `Task.detached {}`의 사용에 대한 차이는 매우 중요합니다. `Task {}`는 구조화된 자식 작업을 생성하여 현재의 액터, 우선순위 및 부모 작업 계층을 따릅니다. 이는 작업 취소, 오류 처리 및 자식 작업의 활용에서 예측 가능성을 유지할 수 있게 도와줍니다. 예를 들어, `@MainActor`에서 UI 상태를 안전하게 업데이트할 수 있습니다.\n\n반면, `Task.detached {}`는 모든 것에서 분리된 비구조적 작업을 시작하며, 액터, 우선순위 또는 작업 그룹을 상속하지 않아 큰 위험을 초래할 수 있습니다. 잘못 사용하면 UI를 비동기적으로 업데이트하려 할 때 크래시가 발생할 수 있습니다. `Task.detached`는 의도적으로 백그라운드에서 독립적으로 작업을 수행하고자 할 때 사용되며, 이를 사용할 때는 다시 액터로 재진입하여 데이터를 업데이트해야 합니다.\n\n중요한 사항은 다음과 같습니다:\n1. `Task.detached` 내부에서 실행할 때 현재 메인 스레드에서 실행되는 것 같지만, 실제로는 아니므로 주의가 필요합니다.\n2. `Task.detached`는 취소 계층을 가지지 않아서 부모 작업이 취소되어도 계속 실행됩니다.\n3. 우선순위가 부모 또는 UI 이벤트에서 상속되지 않습니다.\n4. 액터로 격리된 데이터를 직접 접근하면 예기치 않은 상태 오류가 발생할 수 있습니다.\n\n결론적으로, `Task {}`는 안전하게 사용하되, `Task.detached`는 더 큰 제어가 필요할 때만 신중하게 사용해야 합니다.\n\n**키워드**: Swift, 비동기, Task, 작동 방식, 프로그래밍 오류","comments":"`Task.detached {}` 구문도 자주 사용하시나요? 저는 조심해서 쓰려다보니 거의 안 쓰는 것 같기는 합니다. 액터 연결을 완전히 끊는 작업이 필요할 때만 쓸 수 있으니까요","location":"https:\/\/levelup.gitconnected.com\/task-vs-task-detached-in-swift-the-concurrency-trap-3ea81f545fbe","keywords":["Swift"],"title":"in Swift: The Concurrency Trap | by Koti Avula "},{"summary":"","comments":"한국인에게는 익숙한(?) 이름이네요. hello 를 뒤집은 olleh 프로젝트는 애플 파운데이션 모델을 ollama 호환 API로 만들어주는 프레임워크입니다","location":"https:\/\/github.com\/loopwork\/olleh","keywords":["OpenSources","AI\/ML"],"title":"loopwork\/olleh: An Ollama-compatible CLI for Apple's Foundation Models"}]}