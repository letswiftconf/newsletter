{"sequence":115,"releaseAt":752857200,"items":[{"summary":"리누스 토발즈는 단 21줄의 코드로 리눅스 커널의 멀티스레딩 성능을 2.6% 향상시켰습니다. 이 최적화는 x86\/uaccess의 copy_from_user() 함수에서 barrier_nospec()을 제거하는 것으로, 이 코드는 2018년에 발견된 Meltdown과 Spectre 취약점에 대응하기 위해 도입되었습니다. 이 취약점들은 CPU의 \"예측 실행\" 메커니즘을 악용하여 보안 위험을 초래했으나, 이로 인해 성능이 저하되는 문제가 있었습니다. 토발즈는 보안 패치가 불가피하더라도 성능 손실이 과도함을 피해야 한다는 입장이며, pointer masking 기법을 활용해 이런 문제를 해결했습니다.\n\n이 변경사항은 멀티스레드 환경에서 스레드별 운영 성능 벤치마크에서 2.6%의 성능 향상을 가져왔습니다. 이는 수백만 대의 서버와 클라우드 서비스, 로컬 장치들에 큰 이점을 제공합니다. 이 최적화는 다가올 리눅스 6.12 안정 버전의 성능 개선사항에 포함될 예정입니다. 리누스 토발즈의 깊은 x86 아키텍처에 대한 이해가 이번 성능 향상에 기여하였으며, 이는 그가 Transmeta에 고용되어 Crusoe 칩에 대한 저수준 전문 지식을 제공하던 때를 상기시킵니다.\n\n키워드: 리눅스, 성능 최적화, 리누스 토발즈, 멀티스레딩, 보안 취약점.","keywords":["Culture"],"comments":"리눅스 커널 최적화 이야기입니다만 x86 아키텍처 CPU 명령어 중에서 특정 명령어를 우회하도록 21줄 코드로 멀티 스레드에서 2.6% 성능 향상을 가져온다는 얘기입니다. 토르발즈 형님 살아있네요! ","title":"21 Lines of Code Propel Linux Performance by 2.6% | by Dylan Cooper ","location":"https:\/\/blog.stackademic.com\/as-expected-of-linus-21-lines-of-code-propel-linux-performance-by-2-6-bc7c064179d6"},{"comments":"Shadow PC 라고 게임을 위해서 월단위로 결제하고 윈도우즈 PC를 클라우드 기반으로 통째로 제공해주는 서비스가 있습니다. 짧게 써야할 때 필요할 수도 있겠다 싶은 정도입니다 ","location":"https:\/\/medium.com\/coding-beauty\/shadow-pc-e1ef8198bd3e","title":"Shadow PC is amazing | by Tari Ibaba ","keywords":["Culture"],"summary":""},{"keywords":["UIKit"],"location":"https:\/\/blog.stackademic.com\/3-different-custom-styles-for-segment-control-9ca8f7f282b3","summary":"","comments":"iOS에는 한 번에 하나씩만 선택 가능한 Radio Button 대신에 Segment Control 방식을 권장하는 데요 (오랜만에 UIKit 으로) 커스텀 Segment Control 구현 예제라서 가져와봤습니다","title":"3 Different Custom Styles for Segment Control | by Jerry PM "},{"comments":"masOS 세콰이어 새 기능 소개입니다. 개인적으로 엠비언트 배경음이 들어간 게 너무 좋네요. 마음껏 빗소리 들으면서 코딩할 수 있어서요 ","keywords":["Culture"],"title":"6 Essential MacOS Sequoia Features Every User Needs to Know | by Andrii ","location":"https:\/\/medium.com\/@andriizolkin\/6-essential-macos-sequoia-features-every-user-needs-to-know-3f28e4827097","summary":""},{"keywords":["APPLE"],"comments":"앱 스토어 피처링 관련 공식 소식과 번역된 안내글입니다. 앱 스토어도 이제 조금더 열어주는 걸까요","location":"https:\/\/developer.apple.com\/kr\/app-store\/getting-featured\/","title":"App Store 피처링 - App Store - Apple Developer","summary":""},{"location":"https:\/\/www.apple.com\/kr\/newsroom\/2024\/11\/apple-arcade-unwraps-new-games-for-the-holiday-season\/","summary":"","comments":"연말연시 시즌을 맞아서 애플 아케이드에 새로운 게임이 추가된다고 합니다. 애플 아케이드 게임을 잘 안하게 되던데 연말에 가족들과 티비로 해볼 수도 있겠네요","keywords":["APPLE"],"title":"Apple Arcade, 연말연시 시즌을 위한 신규 게임 공개 - Apple (KR)"},{"summary":"애플이 최근 출시한 '애플 인텔리전스'라는 기능은 AI를 통해 사용자 데이터와 활동을 바탕으로 개인화된 결과물을 제공하는 것입니다. 이는 iOS 18.1, iPadOS 18.1, macOS Sequoia 15.1 등 특정 애플 운영 체제에 내장되어 있으며, 문맥을 반영해 사용자 스타일을 모방합니다. 주요 기능으로는 사용자의 연락처를 기반으로 이모티콘을 만들거나 이미지 생성, 시리를 통한 문맥 인식 등이 있습니다. 애플은 이러한 기술이 사용자의 삶을 편리하게 만들어준다고 광고하지만 이러한 기능이 사용자로 하여금 게으르고 비판적 사고 없이, 기술에 의존하게 만들어 잠재적으로 부정적인 영향을 끼칠 수 있다고 우려합니다. \n\n인공지능이 사용자의 이메일 등 개인 데이터를 활용해 결과를 도출하고, 이를 통해 개인의 자주성을 약화시킬 위험성을 지적합니다. 결국 저자는 애플이 사람들에게 보다 의존적인 사용자가 되길 원하거나, 이미 그렇게 생각하고 있다고 비판하며, 기술에 대한 맹목적인 의존이 궁극적으로 인간의 지적·감정적 능력을 저해할 수 있음을 경고합니다.\n\n주요 키워드: 애플 인텔리전스, 개인화 AI, 데이터 의존성, 사용자 비판, 기술의존 문제.","title":"Apple Intelligence’s Plan to Make You Stupid | by The Evidence Files ","location":"https:\/\/medium.com\/ai-ai-oh\/apple-intelligences-plan-to-make-you-stupid-6a0ae7688925","comments":"애플 인텔리전스 뿐만 아니라 인공지능 도구를 사용하다보면 우리는 직접할 수 없게 되고 점점 더 멍청해지는 걸까요. 비판적인 사고가 없이 살아가는 미래의 나를 상상해봅니다","keywords":["AI\/ML","영어"]},{"keywords":["APPLE"],"location":"https:\/\/www.apple.com\/kr\/newsroom\/2024\/11\/final-cut-pro-11-begins-a-new-chapter-for-video-editing-on-mac\/","title":"Apple, 새로운 Final Cut Pro 11을 비롯한 프로 앱 업데이트 발표 - Apple (KR)","comments":"파이널컷 프로나 모션에도 인공지능 기반 도구가 추가되었습니다. 영상 편집도 더 편리해지는 시대가 됐네요. 이제 키노트도 좀 업데이트해주세요","summary":""},{"comments":"터치 스크린이 익숙해지고 있지만 여전히 물리 버튼이 가지는 매력과 직관적인 필요가 있습니다. 앞으로 물리버튼은 영원히 사라지게 될까요","title":"Are physical buttons going extinct? | by Daley Wilhelm ","location":"https:\/\/uxdesign.cc\/are-physical-buttons-going-extinct-d67eb8f1435f","summary":"이 글은 터치스크린 기술의 발전과 물리적 버튼의 미래에 대해 논의한다. 터치스크린은 1965년부터 시작되어 다양한 분야로 확산되었으며, 스마트폰과 자동차 등에서 중요한 역할을 하고 있다. iPhone의 경우 홈 버튼이 2017년에 제거된 후 최근 모델은 액션 버튼과 카메라 컨트롤 버튼을 소개하면서 물리적 버튼을 일부 다시 도입하였다. 이는 사용자가 피드백과 높은 직관성을 위해 물리적 버튼을 선호할 수 있음을 나타낸다.\n\n자동차의 경우 대부분의 차량이 터치스크린을 기본으로 제공하지만, 물리적 버튼이 운전 중 사용하는 데 있어서 더 안전하고 직관적이라는 의견이 있다. 터치스크린은 사용 중 집중을 요해 운전자의 주의를 산만하게 할 수 있어 사고 위험을 높일 수 있다. 반면 물리적 버튼은 눈을 떼지 않고도 사용할 수 있다는 장점이 있다.\n\n따라서 터치스크린과 물리적 버튼은 서로를 보완하여 공존할 가능성이 높으며, 이는 더욱 안전하고 사용자 친화적인 인터페이스를 제공할 수 있다.\n\n키포인트 키워드:\n1. 터치스크린발전\n2. 물리적버튼반복귀\n3. iPhone액션버튼\n4. 자동차안전성\n5. 인터페이스공존","keywords":["Design","pick"]},{"summary":"","location":"https:\/\/blog.stackademic.com\/binary-trees-in-swift-574f3b3ec2df","title":"Binary Trees in Swift. A Simple Data Structure! | by Steven Curtis ","keywords":["Swift"],"comments":"이진 트리를 만들어서 써야 하는 경우가 아주 드물게 있겠죠. 학부 시절에 숙제하던 게 생각나는 글이라서 가져와 봤습니다 "},{"comments":"ChatGPT 맥용 앱이 Xcode 나 VSCode 내용을 보고 읽고 대화할 수 있습니다. 굳이 캡처해서 설명하지 않아도 되는 정도인데요 몇 가지 리뷰를 같이 보시면 될 것 같습니다. ","keywords":["DeveloperTools"],"location":"https:\/\/generativeai.pub\/chatgpt-can-now-access-mac-apps-to-write-code-for-you-e2295bbf1e25","title":"ChatGPT Can Now Access Mac Apps to Write Code for You | by Jim Clyde Monge ","summary":""},{"keywords":["Framework","영어"],"summary":"이 기사는 인앱 구독에 대한 '연동 가격'이라는 새로운 기능을 소개합니다. 연동 가격은 다른 구독에 이미 가입한 사용자에게 할인된 구독 가격을 제공하는 방식입니다. 이를 통해 사용자를 유지하고 새로운 고객을 끌어들이는 효과를 거둘 수 있습니다. 애플은 2023년 12월에 이 기능을 발표하고 몇몇 개발자와 함께 파일럿 프로젝트를 시작했습니다. 이 기능을 통해 개발자는 다른 개발자와 함께 앱 번들 제공을 할 수 있으며, 서로 교차로 프로모션을 진행할 수 있습니다.\n\n예시로, RocketSim과 Helm 앱의 경우, 한 앱에 연간 구독 가입 시 다른 앱에서 30% 할인을 받을 수 있습니다. 사용자들은 앱 내에서 또는 마케팅 채널을 통해 이러한 할인을 발견할 수 있으며, App Store를 통해서도 확인 가능합니다.\n\n연동 가격의 가입은 애플이 제공하는 온라인 폼을 통해 가능하며, 할인 구독의 정의와 관련된 몇 가지 사항을 입력해야 합니다. 사용자가 구독을 취소할 경우, 할인 요금 체계는 기본 요금으로 변경됩니다.\n\n연동 가격은 macOS도 지원하지만, 현재 마케팅 채널 제공이 부족하여 자체 홍보가 필요합니다. RocketSim과 Helm의 파트너십을 통해 더 많은 앱 개발자가 이점을 누릴 수 있도록 하며, 연동 가격은 앱의 이탈률(churn rate)을 줄이는 데 긍정적인 효과가 있습니다.\n\n키워드: 연동 가격, 인앱 구독, 할인 프로모션, 앱 번들, 사용자 유지.","location":"https:\/\/www.avanderlee.com\/optimization\/contingent-pricing-for-in-app-subscriptions\/?","title":"Contingent pricing for in-app subscriptions - SwiftLee","comments":"앱 개발사의 서로 다른 앱을 구독할 때 가격을 연동해서 할인해 줄 수 있는 인앱 구매 방식이 생겼습니다."},{"title":"Creating an iOS Screen Time Tracking App Using SwiftUI and Apple’s DeviceActivity Framework | by Muhammad Danish Qureshi ","keywords":["Framework"],"summary":"iOS 15에서 Apple은 Family Controls, Managed Settings, Device Activity라는 세 가지 새로운 프레임워크와 함께 Screen Time API를 도입했습니다. iOS 16에서는 이러한 API에 새로운 기능이 추가되어 사용자가 각 앱에 사용한 시간을 추적하고 iPhone에서 일일 사용 시간을 확인할 수 있게 되었습니다. 이 글에서는 SwiftUI와 Apple's DeviceActivity Framework를 사용하여 iOS 화면 시간 추적 앱을 만드는 방법을 설명합니다.\n\n1. **새 앱 만들기**: \"Create a New App\"에서 원하는 이름으로 앱을 생성합니다.\n2. **앱 구조 수정**: `@main App` 구조에서 `WindowGroup`을 수정하여 사용 권한 요청 코드를 추가합니다.\n3. **ContentView 구현**: `DeviceActivity`와 `FamilyControls`를 가져와 `ContentView`를 구성하고 앱 사용 시간을 보고하는 UI를 만듭니다.\n4. **Device Activity Report Extension 추가**: 새로운 타겟으로 `Device Activity Report Extension`을 추가하고, 이 확장에서만 작업해야 합니다.\n5. **모니터 확장 정의**: `monitorExtension`을 정의하여 활동 보고서를 표시할 사용자 정의 `DeviceActivityReportExtension`을 만듭니다.\n6. **앱별 활동 데이터 표시**: `TotalActivityView`에서 각 앱의 사용 시간을 리스트 형식으로 사용자에게 보여줍니다.\n\n이 앱은 각 앱별 사용 시간을 보여주는 진행 막대를 포함한 사용자 친화적인 인터페이스를 제공합니다. 하지만 Apple의 제한으로 인해 확장 외부에서는 이 데이터를 사용할 수 없으며, 디버깅을 위한 출력이나 데이터 저장도 불가능합니다.\n\n**주요 키워드**: iOS Screen Time API, DeviceActivity Framework, SwiftUI, 앱 사용 시간 추적, Device Activity Report Extension.","location":"https:\/\/medium.com\/@danisharfin1\/creating-an-ios-screen-time-tracking-app-using-swiftui-and-apples-deviceactivity-framework-e999c6f37930","comments":"스크린 타임 API - DeviceActivity 프레임워크로 사용 시간을 추적하는 방식을 설명합니다"},{"keywords":["SwiftUI"],"comments":"실용적인 관점에서 SwiftUI 화면 커스텀 내비게이션 방식을 제안합니다. 이거 좀 애플에서 정리를 해주면 좋겠는데 말이죠 여전히 다양한 케이스가 나오는 것 같습니다","summary":"","title":"Custom Navigation in SwiftUI: A Practical Solution | by ilyapaddubny ","location":"https:\/\/medium.com\/@ilyapaddubny\/custom-navigation-in-swiftui-a-practical-solution-0e5dc8a21b90"},{"keywords":["AI\/ML"],"title":"Exploring Apple Intelligence: Writing Tools","summary":"애플 인텔리전스의 글쓰기 도구는 애플 기기를 통해 사용자에게 더욱 쉽고 정확하며 효율적인 글쓰기 경험을 제공하는 AI 기반 도구 세트입니다. 이메일, 문서, 메시지, 노트에서 원활하게 작성을 돕고, 편집 과정에서 맞춤법 및 문법 오류를 자동으로 검토 및 수정합니다. 사용자는 전문적이거나 친근한 느낌의 표현을 선택해 문장을 다시 쓸 수 있으며, 긴 문장을 요약해 읽기 쉽게 변환할 수 있는 기능도 제공합니다.\n\n작성 도구는 iOS와 macOS에서 사용 가능하며, 사용자 인터페이스의 다양한 요소와 자연스럽게 통합돼 앱 개발자가 추가적인 업데이트 없이도 사용할 수 있습니다. SwiftUI와 UIKit에서의 통합은 사용자가 직접 설정할 수 있으며, 특정 수정 가능한 옵션을 통해 사용자에게 맞춤형 편집 경험을 제공합니다.\n\n현재 iOS 18.2 베타 1 및 macOS 15.2 베타 버전에서는 일부 기능이 지원되지 않지만, 향후 더 많은 개발자 API가 제공돼 사용자 맞춤형 경험을 강화할 예정입니다.\n\n- 키포인트 키워드:\n1. 애플 인텔리전스\n2. AI 기반 도구\n3. 작문 편집 지원\n4. SwiftUI 및 UIKit 통합\n5. 기능 확장 예고","comments":"글쓰기 도구를 앱에서 지원하려면 뷰에서 행동을 정의해줘야 하는데요. SwiftUI 와 UIKit 에서 각각 어떻게 지원 가능한지 설명합니다. ","location":"https:\/\/www.createwithswift.com\/exploring-apple-intelligence-writing-tools\/?"},{"summary":"이 문서는 Qwen2-Audio라는 멀티 모달 언어 모델을 사용하여 음악을 악보로 자동 변환하는 방법에 대해 설명합니다. 음악 트랜스크립션의 현재 최첨단 기술은 구글 브레인 팀의 Magenta 프로젝트에서 개발된 AI 기반 모델을 활용하며, 이들은 Transformer 구조를 사용하여 음성 파일을 MIDI 형식의 토큰으로 변환합니다. 하지만 이러한 전문 모델들은 고도의 훈련 자원과 특정 도메인에 집중된 작은 어휘의 사용으로 인해 유연성 문제가 있습니다. Qwen2-Audio 모델은 OpenAI의 Whisper를 활용하여 음성을 텍스트로 변환하며, 멀티모달 아키텍처를 통해 다양한 입력을 처리합니다.\n\n저자는 Qwen2-Audio를 미세 조정하여 음악 트랜스크립션 작업의 시작점을 제공하려고 하였으나, 모델의 크기나 사전 훈련이 충분하지 않아 기본적인 음악 작업에서 좋은 성능을 보이지 못했습니다. 실험은 실패했지만 향후 더 진전된 사전 훈련 모델 개발과 다양한 음악 훈련 데이터셋의 확대, 정교한 보상 함수 개발 등의 새로운 연구 방향을 제시했습니다.\n\n키워드: 멀티 모달 모델, 음악 트랜스크립션, Qwen2-Audio, ABC 표기법, 강화학습(PPO)","comments":"Qwen2-Audio 라는 멀티 모달 언어 모델을 사용하면 음악을 악보로 바꿀 수 있다는 트랜스폼을 설명합니다. 크고 복잡한 모델들이지만 여전히 어휘가 풍부하지는 못하다고 합니다.","title":"Exploring Music Transcription with Multi-Modal Language Models | by Jon Flynn ","location":"https:\/\/towardsdatascience.com\/exploring-music-transcription-with-multi-modal-language-models-af352105db56","keywords":["AI\/ML"]},{"comments":"구글 독점 문제와 함께 크롬 사업부를 매각하라는 의견을 법원에 건의했다는 소식이 전해졌죠. 구글의 독점 소송은 어떤 결과로 이어질까요","keywords":["Culture"],"summary":"코리 닥터로우는 구글의 독점 문제와 이를 해결하기 위한 구조적 분리 방안을 제안합니다. 최근 미국 법원이 구글을 '독점 기업'으로 판결하고 데이터 수집 방식이 문제의 핵심임을 지적하며 해결책을 요구했습니다. 일부 경쟁업체는 구글의 클릭 및 쿼리 데이터를 공유해야 한다고 주장했지만, 이는 프라이버시 문제가 심각하다고 비판합니다. 구글이 18개월 동안 클릭 및 쿼리 데이터를 보관한다고 알려져 있지만, 실제로는 검색 이력으로 인한 추론을 무기한 보관할 수 있어, 개인정보 보호법의 필요성이 강조됩니다.\n\n구글의 데이터 외에도 구글의 검색 인덱스는 경쟁업체에게 유용할 수 있습니다. 최근 DOJ는 구글에게 크롬을 매각하도록 요구하고, 안드로이드의 매각은 논의에서 제외했습니다. 구조적 분리는 기업 간의 불공정 경쟁을 방지하기 위한 중요한 방법입니다. 이러한 사례로 Standard Oil와 AT&T가 있었습니다. DOJ의 최근 조치는 이러한 원칙을 적용하여 경쟁을 촉진하려는 시도로 보입니다. 하지만 다음 정부에서도 이러한 방침이 이어질지는 미지수입니다.\n\n키워드: 구글 독점, 구조적 분리, 프라이버시, 크롬 매각, DOJ 조치.","title":"Forcing Google to spin off Chrome (and Android?) | by Cory Doctorow ","location":"https:\/\/doctorow.medium.com\/https-pluralistic-net-2024-11-19-breaking-up-is-hard-to-do-shiny-and-chrome-5b6eaf08bb5a"},{"comments":"많은 회사들이 제품을 개발하면서 사용성과 기능성을 양자택일 하는 경우가 많다는 지적입니다. 직관적이고 쉽고 쓰기 편한 제품이 이상적이지만, 사용자들은 점점 더 기능이 많고 복잡한 것을 원하기도 하니까요","summary":"이 기사는 제품 개발에서 사용성(Usability)과 유용성(Utility) 간의 대립에 대한 문제를 다루고 있습니다. 많은 기업이 이 두 가지 간의 선택을 강요받는 가운데, 이상적인 해결책은 이 둘을 최대한 조화롭게 결합하는 것이라고 강조합니다. 사용성을 강조하다 보면 기능이 부족하여 제품 자체의 가치가 떨어지게 되고, 반대로 기능만을 강조하면 복잡성이 증가하여 사용자가 불편함을 느끼게 됩니다. 그러므로 좋은 제품은 사용자가 필요로 하는 기능을 직관적으로 사용할 수 있도록 단계적으로 제공해야 합니다. 제품의 성공은 기능성 자체보다 사용자가 그것을 통해 무엇을 이룰 수 있는가에 달려 있습니다. 따라서 제품 팀은 사용자 성공을 우선시하여, 기능 목록이나 디자인 원칙에 치중하기보다는 사용자가 제품을 통해 가치를 창출할 수 있도록 해야 합니다. 이상적인 제품은 사용성과 유용성을 동시에 갖추어 사용자에게 만족감을 줄 수 있어야 하며, 사용자들이 자신이 원하는 것을 쉽게 달성할 수 있도록 돕습니다.\n\n키포인트 키워드:\n1. 사용성과 유용성의 조화\n2. 사용자 중심 가치\n3. 복잡성의 단계적 도입\n4. 기능과 사용성 균형\n5. 사용자 성공과 제품 가치","keywords":["Design"],"title":"Great products transcend the Usability vs. Utility debate | by Avi Siegel ","location":"https:\/\/uxdesign.cc\/great-products-transcend-the-usability-vs-utility-debate-93d76c2ab398"},{"keywords":["Swift"],"location":"https:\/\/stevenpcurtis.medium.com\/handling-unknown-enum-cases-in-swift-4ca7492939dd","title":"Handling Unknown Enum Cases in Swift | by Steven Curtis ","summary":"","comments":"enum 선언 시점에 아예 의도적으로 Unknown을 선언하면 어떻게 될까요. 모르겠지만 알아서 처리해야 하는 상황에 대해 설명합니다."},{"comments":"동형 암호화 방식에 대한 회의적인 글입니다. 이 분 글은 많은 글이 냉소적이긴 한데요 특히 동형 암호화 기술에 대한 음모 이론을 제시하는 부분이 특이하네요","keywords":["Culture","영어"],"location":"https:\/\/andrewzuo.com\/homomorphic-encryption-is-not-encryption-5af4ca4d710c","title":"Homomorphic Encryption Is Not Encryption | by Andrew Zuo ","summary":"기사는 동형 암호화(Homomorphic Encryption)에 대한 회의적인 시각을 다루고 있습니다. 동형 암호화는 암호화된 데이터를 해독하지 않고도 연산을 수행할 수 있게 해주는 기술입니다. 저자는 법집행 기관이 암호화 약화를 주장하며 시스템에 백도어를 삽입하려던 시도와 유사하게 동형 암호화가 실제로는 강력한 암호화가 아닌, 복잡한 형태의 데이터 변형에 불과하다고 주장합니다. 동형 암호화는 운영 환경 내에서도 데이터 보안을 유지시킨다는 장점이 있으나, 이를 실제로 악용하여 데이터를 역추적할 수 있다는 점을 지적합니다. \n\n안전한 데이터 처리 방법으로 신뢰 실행 환경(TEE: Trusted Execution Environment)을 예로 들며, 이는 이미 애플의 Secure Enclave와 같은 소비자 기기에 구현되어 있다고 설명합니다. 저자는 보다 신뢰할 수 있는 실행 환경에 집중하는 것이 더 효과적이라고 주장하며, 동형 암호화가 NSA의 암호화 약화를 위한 캠페인이란 의혹을 제기합니다.\n\n**핵심 키워드:** 동형 암호화, NSA, 데이터 보안, 신뢰 실행 환경, 암호화 약화."},{"keywords":["SwiftUI","pick"],"location":"https:\/\/canopas.com\/integrating-live-activity-and-dynamic-island-in-i-os-a-complete-guide?","summary":"","comments":"라이브 액티비티와 다이나믹 아일랜드 연동하는 방식을 상세하게 설명하고 있습니다. 두루 살펴보기 좋은 자료라서 추천합니다","title":"Integrating Live Activity and Dynamic Island in iOS: A Complete Guide"},{"title":"Lazy vars in @Observable classes in Swift","summary":"이번 게시물에서는 ObservableObject 프로토콜을 @Observable 매크로로 전환하면서 발생한 지연 변수 사용 문제와 그 해결 방법에 대해 설명하고 있습니다. 기존의 ObservableObject 클래스를 사용하는 경우와 @Observable 매크로로 바꾼 경우의 코드 차이를 예시로 보여줍니다. @Observable 매크로를 사용하는 경우 클래스 내 모든 변수에 대한 관찰 로직을 자동으로 생성하게 되는데, lazy 변수를 사용하려면 @ObservationIgnored 애노테이션을 추가하여 관찰 로직 생성을 생략해야 합니다. 이는 Swift 포럼에서의 토론을 통해 찾은 해결책입니다.\n\n핵심 키워드: Swift, SwiftUI, @Observable, 지연 변수, 블랙 프라이데이 행사.","keywords":["Swift","영어"],"location":"https:\/\/nilcoalescing.com\/blog\/LazyVarsInObservableClasses\/?","comments":"`@Observable` 매크로를 사용하는 경우 lazy var 의도한 것처럼 사용하지 못할 수 있어서 무시하도록 설정하는 방식을 설명합니다"},{"location":"https:\/\/towardsdatascience.com\/lora-fine-tuning-on-your-apple-silicon-macbook-432c7dab614a","comments":"당장 제가 꼼꼼하게 읽어봐야 하는 내용이네요. MLX 환경을 준비해서 미세 조정을 위해 LoRA 방식으로 추가 학습하는 방식을 설명합니다","keywords":["AI\/ML","pick"],"title":"LoRA Fine-Tuning On Your Apple Silicon MacBook | by Matthew Gunton ","summary":"이 글은 Apple Silicon MacBook에서 MLX 라이브러리를 사용하여 LLM(대규모 언어 모델)을 로컬에서 미세 조정하는 방법에 대해 설명합니다. Apple의 커스텀 실리콘 덕분에 MLX는 CPU와 GPU가 같은 메모리를 공유하는 방식으로 설계되어, 메모리 전송 효율을 높여 LLM을 효과적으로 실행합니다. Intel 프로세서를 사용하는 Mac에서는 이를 활용할 수 없다는 점을 유의해야 합니다.\n\nMLX 설치는 가상 환경을 구축하여 pip 명령어로 진행합니다. 이후, Microsoft의 Phi 모델을 다운로드하여 로컬에서 간단한 추론을 수행할 수 있습니다. Fine-Tuning(미세조정) 단계에서는 JSON 형식으로 응답하는 모델로 만들기 위해 일정한 스키마를 사용하는 데이터셋으로 모델을 조정합니다. 이를 위해 SQuAD v2 데이터셋을 특정 스키마에 맞추어 처리한 파이썬 스크립트가 소개됩니다.\n\n로라(LoRA) 방식으로 미세 조정을 수행하며, 학습 데이터셋을 사용하여 모델을 조정해 최종 검증 손실을 얻습니다. 모델의 성능을 유지하면서 메모리 사용량을 줄이고 속도를 올리기 위해 모델 양자화(Quantization)를 진행하고, 이렇게 변환된 모델에 대해 QLoRA를 수행합니다. 결과적으로, QLoRA를 통해 메모리 사용량과 토큰 생성 속도를 크게 개선했습니다. \n\n각 단계에서는 MLX 명령어를 적절히 사용하며, 자세한 코드 및 설정 파일 정보는 GitHub Repository에서 확인할 수 있습니다.\n\n**키워드:**\n1. Apple Silicon\n2. MLX\n3. Fine-Tuning(미세조정)\n4. Quantization(양자화)\n5. LoRA\/QLoRA"},{"title":"M4 Mac mini — is it really THAT good? | by David Lewis ","comments":"M4 맥 미니 리뷰가 쏟아져 나오고 있네요. 입문 모델은 호평 일색인 것 같습니다","location":"https:\/\/medium.com\/macoclock\/m4-mac-mini-is-it-really-that-good-2eaccd5750e0","keywords":["Hardware"],"summary":""},{"summary":"Swift 5.5에서 도입된 MainActor는 전역 액터로, 주요 스레드에서 작업을 수행하는 실행자를 제공한다. iOS 앱 개발 시 UI 업데이트는 반드시 주요 스레드에서 이루어져야 하며, 여러 백그라운드 스레드를 사용할 때 이를 보장하는 것이 도전적일 수 있다. @MainActor 속성을 사용하면 UI 작업이 항상 주요 스레드에서 수행되도록 할 수 있다. MainActor는 글로벌 액터 프로토콜을 상속하여 정의되며, 동일한 전역 액터로부터 다른 작업과 동기화되어 선언에 대한 상호 배타적 접근이 보장된다.\n\nMainActor는 속성, 메서드, 인스턴스, 클로저와 함께 사용할 수 있다. MVVM 패턴을 사용하는 SwiftUI에서는 뷰 다시 그리기를 주요 스레드에서만 발생시키기 위해 MainActor를 사용하는 것이 좋다. Xcode 16에서는 비동기 컨텍스트에서 이를 호출함으로써 메서드가 언제 주요 스레드로 디스패치되는지를 알려준다. 이전의 DispatchQueue.main.async를 사용하는 대신, MainActor.run을 사용할 수 있다. 그러나 글로벌 액터 속성을 사용하여 주요 스레드 액세스를 제한하는 것이 좋다.\n\n글로벌 액터는 프로젝트 내의 데이터 경합을 방지하는 데 유용하며, Swift 6에서는 @MainActor가 메인 스레드 실행을 항상 보장하지 않는다는 점에 주의해야 한다. 동기 메서드가 호출자의 스레드에서 실행되므로, 메인 스레드가 아닌 곳에서 메인 액터가 호출되는 문제가 생길 수 있다. Swift 6 언어 모드를 사용하면 이러한 오류를 컴파일러가 잡아준다.\n\n주요 키워드:\n- Swift 5.5\n- MainActor\n- 글로벌 액터\n- 데이터 경합 방지\n- 동기화된 작업 수행","comments":"메인 액터의 동작에 대해 상세하게 설명하고 있습니다. 글로벌 액터와 구분해서 어떤 것을 고립해서 사용할 수 있는지 읽어보시길 추천드립니다","keywords":["Swift"],"title":"MainActor usage in Swift explained to dispatch to the main thread","location":"https:\/\/www.avanderlee.com\/swift\/mainactor-dispatch-main-thread\/?"},{"keywords":["UIKit"],"comments":"iOS 앱들은 이제 Setting 설정 앱에서 값을 바꾸기 보다는 앱 내부에 설정 화면을 어떻게 만들 것인가 논의하는 쪽으로 바뀌는 것 같네요. 직관적이고 접근성이 높은 설정 화면을 만드는 것은 어디부터 시작해야 할까요","location":"https:\/\/code.likeagirl.io\/anatomy-of-an-ios-settings-page-3ae1c7536d04","summary":"iOS 설정 페이지 구축에 관한 글은 'FocusPasta'라는 앱 개발 경험을 바탕으로 사용자 친화적이고 스타일리시한 설정 페이지를 만드는 과정을 설명하고 있습니다. 개발자 델피나 수간디는 다양한 앱에서 사용하는 설정 페이지의 중요성을 인식하고, 'FocusPasta'에 적용하기 위해 설정 페이지의 기본 구성 요소들을 분석하였습니다.\n\n설정 페이지는 일반적으로 UINavigationController, UIViewController, UITableView와 같은 핵심 컴포넌트로 구성됩니다. UINavigationController는 원활한 페이지 전환을, UIViewController는 전체 레이아웃과 UI 요소 관리를 담당하며, UITableView는 설정 옵션을 정리하여 보여주는 역할을 합니다. 이를 통해 설정 페이지는 직관적이고 접근성이 높은 사용자 경험을 제공합니다.\n\nUISwitch, UISlider, UITextField 등의 입력 요소를 사용하여 사용자 설정을 수집하고 저장하는데, 이러한 작업은 UserDefaults를 활용하여 간편하게 구현됩니다. UserDefaults는 앱 세션 간 사용자 설정을 유지해주는 간단하고 효과적인 도구로 소개되었습니다.\n\n다양한 기본 컴포넌트와 직관적인 입력 옵션을 활용하면 사용자 친화적인 설정 페이지를 쉽게 구축할 수 있으며, UserDefaults를 통해 설정 저장을 간편하게 처리할 수 있습니다.\n\n키워드: iOS 설정 페이지, UINavigationController, UITableView, UserDefaults, 사용자 친화적 인터페이스.","title":"Master the Anatomy of a Great iOS Settings Page | by Delfina Sugandi "},{"location":"https:\/\/fatbobman.com\/en\/posts\/mastering-data-tracking-and-notifications-in-core-data-and-swiftdata\/?","comments":"CoreData와 SwiftData 데이터 추적과 알림 방식에 대한 심도 깊은 설명입니다. 데이터 동기화 문제를 해결할 수 있도록 도와주는 트랜잭션과 이력 관리 기능을 추천하고 있습니다.","title":"Mastering Data Tracking and Notifications in Core Data and SwiftData | Fatbobman","keywords":["Framework"],"summary":" 본 글에서는 Apple의 지속성 프레임워크인 Core Data와 SwiftData에서 데이터 추적 및 알림을 관리하는 방법에 대해 다룹니다. Core Data와 SwiftData는 @FetchRequest 및 @Query와 같은 선언적 데이터 청취 도구뿐만 아니라, 복잡한 데이터 동기화 시나리오에 대응할 수 있는 완전한 데이터 추적 및 알림 메커니즘을 제공합니다. 작성자 Fatbobman은 사용자 정의 알림부터 Persistent History Tracking 및 SwiftData History 같은 강력한 기능까지 여러 솔루션을 제안해, 개발자가 다양한 데이터 동기화 문제를 해결할 수 있도록 돕습니다.\n\n### 주요 내용 요약:\n\n1. **사용자 정의 알림**: 개발자가 데이터를 조작할 때 발생하는 이벤트를 커스텀 알림을 통해 감지함으로써 유연성을 높일 수 있지만, 모든 데이터 변경을 자동 감지하지는 못한다는 단점이 있습니다.\n\n2. **NSManagedObject 클래스를 확장하는 방법**: 객체의 생명 주기에 따라 특정 시점에 알림을 발생시켜 복잡한 데이터 상태 관리를 통해 보다 정교한 알림을 제공할 수 있습니다.\n\n3. **컨텍스트의 알림 기능**: 데이터의 변경 및 저장과 관련된 세 가지 종류의 알림을 제공하지만, 동일한 프로세스 내에서만 작동하며, 대규모의 데이터 작업에는 부적합합니다.\n\n4. **Persistent History Tracking (PHT) 및 SwiftData History**: 데이터가 어떤 소스에서 왔든 관계없이 모든 데이터 작업을 기록하며, 여러 프로세스와 데이터 동기화를 지원합니다. 하지만 응답 성능이 낮고, 데이터베이스 조회가 추가로 필요합니다.\n\n이러한 메커니즘은 각각 장단점을 가지고 있으며, 개발자는 유연성과 성능, 프로젝트 요구 사항을 고려해 최적의 알림 메커니즘을 선택해야 합니다.\n\n**키워드**: 데이터 추적, 사용자 정의 알림, NSManagedObject, Persistent History Tracking, SwiftData History"},{"comments":"Sendable 프로토콜이 이제 꼭 알아야 하는 필수 지식이 되어버렸습니다. 컴파일러가 스레드 안정성을 확보할 수 있도록 명시하거나 액터를 지정하여 분리하는 방식을 학습할 수 있도록 설명합니다.","keywords":["Swift"],"location":"https:\/\/medium.com\/@wesleymatlock\/mastering-sendable-in-swift-6-e13d04d86820","summary":"Swift 6에서의 Sendable은 단순한 프로토콜이 아니라, 안정적이고 동시성-안전한 코드베이스를 유지하는 데 필수적인 요소로 떠올랐습니다. Sendable은 컴파일 시간 체크를 통해 작업 경계에서 데이터 안전성을 보장합니다. 이는 작업 간 공유될 수 있는 타입을 제한하고, 동시 접근에 안전하지 않은 가변적인 타입을 식별하여 개발자들에게 더 안전한 패턴을 사용하도록 유도합니다.\n\n동시성 맥락에서 Sendable의 중요성은 Task.init { }나 async 메서드를 호출할 때 Swift가 각 객체를 평가해 무가공의 동시 변이 위험성을 제거하는 데 있습니다. Sendable은 이러한 평가를 컴파일 시간 계약으로 수행하여, 스레드 간 안전하게 전송될 수 있는 타입을 보증합니다. 예를 들어, Sendable을 준수함으로써 값들이 다양한 작업 경계에서 안전하게 사용될 수 있도록 합니다.\n\nSendable의 가장 큰 장점은 컴파일러에서 스레드 안전성을 확인하는 것입니다. 이는 실행 시간 오류를 줄이며, 동시성 관련 버그를 사전에 방지합니다. 복잡하고 자동으로 Sendable을 만족하지 않는 타입들은 명시적으로 준수할 수 있으며, 뮤터블 상태를 다루는 클래스들은 더 안전한 \"actor\"를 사용하여 Sendable을 준수할 수 있습니다.\n\n또한 @Sendable 클로저를 사용하여 비-Sendable 참조를 캡처하지 않고 안전하게 사용 가능하도록 하고, SwiftUI 앱과의 긴밀한 통합을 통해 Swift 6의 @Observable은 스레드 안전성과 UI 업데이트를 개선합니다.\n\n결론적으로, Sendable을 통해 Swift는 컴파일 시간에서 높은 수준의 동시성 안전성을 보장합니다. 이는 특히 실시간 채팅 앱과 같은 응용 프로그램에서 다양한 비동기 작업 간에 메시지 및 사용자 상태가 안전하게 처리되도록 하여 실질적인 이점을 제공하며, 이러한 동시성 원칙의 숙달은 현재 높은 수요의 숙련도를 반영합니다.\n\n키워드: Swift6, Sendable, 동시성, 컴파일러 검사, @Sendable 클로저","title":"Mastering Sendable in Swift 6 | by Wesley Matlock "},{"summary":"","title":"My Favourite Software Architecture Patterns | by Matt Bentley ","comments":"iOS 아키텍처에 대한 글은 아니고 일반적인 소프트웨어 아키텍처에 대한 글입니다. 앱 구조로만 생각하기보다는 더 지평을 넓힐 수 있는 구조를 경험할 수 있습니다","location":"https:\/\/levelup.gitconnected.com\/my-favourite-software-architecture-patterns-0e57073b4be1","keywords":["Architecture"]},{"location":"https:\/\/towardsdatascience.com\/game-theory-part-2-nice-guys-finished-first-8cd9022a935f","keywords":["Culture","영어"],"title":"Nice Guys Finished First | by Saankhya Mondal ","comments":"보통 나쁜 사람들이 빨리 끝내고 착한 사람들이 늦게 끝내는 인식과 다르게 게임 이론에서 협력적이고 착한 사람들이 우승할 수 있다는 것을 보여주는 글입니다. 배신이냐 협력이냐 현실적인 고민이 게임 속에서도 좋은 영향력을 발휘할 수 있을까요","summary":"게임 이론에서는 일반적으로 착한 사람들이 마지막에 끝난다는 인식과는 달리 착한 사람들이 우승할 수 있음을 보여줍니다. 이 기사에서는 반복되는 죄수의 딜레마 문제를 통해 이 흥미로운 현상을 탐구합니다. 반복되는 죄수의 딜레마에서는 두 스파이, 크라티카와 이시타가 매일 가격 경쟁 게임을 진행하면서 최적의 이익을 추구합니다. 매일 가격을 낮추는 선택(배신)을 지속하면 사소한 이익만을 얻지만, 협력하면 더 많은 이익을 얻을 수 있음을 알고 전략을 수정합니다.\n\n크라티카는 다양한 전략을 사용하여 라운드 로빈 토너먼트를 시뮬레이션했습니다. 여러 전략 중에서 \"눈에는 눈\"(Tit-for-tat) 전략이 가장 높은 평균 수익을 내는 것으로 나타났습니다. 이 전략은 상대방의 행동을 모방하며 협력으로 시작하는 전략입니다. 이후 또 다른 전략 \"두 번의 배신에 대한 눈에는 눈\"(Tit-for-two-tats)이 시뮬레이션에서 더 나은 성과를 보였다고 보고되었습니다.\n\n정치 과학자 로버트 액셀로드는 비슷한 대회를 통해 단순한 전략인 눈에는 눈 전략이 가장 효과적임을 밝혔습니다. 그는 이 전략들이 인간 행동과 밀접한 관련이 있으며, 협력적이며, 용서하고, 보복할 줄 아는 전략이 반복적인 상호작용에서 더 나은 결과를 가져온다고 주장했습니다.\n\n이 기사는 게임 이론이 현실의 다양한 상황에서 활용될 수 있는 가능성을 보여주며, \"착한 사람이 우승할 수 있다\"는 결론을 강조합니다.\n\n키워드:\n1. 반복되는 죄수의 딜레마\n2. 게임 이론\n3. 눈에는 눈 전략\n4. 전략 시뮬레이션\n5. 협력과 보복"},{"comments":"iOS 18에서 앱 아이콘 색을 단순화해서 원하는 색으로 바꿀 수 있다보니 디자이너 입장에서는 일이 늘어난 것처럼 느낄 것 같습니다. iOS가 대신 처리해 주는 부분이 있지만 스캐치 앱은 단순하고 색칠된 아이콘을 그대로 느낄 수 있도록 고민했다고 하네요","keywords":["Design","영어"],"title":"Oh no, I need to design a tinted iOS 18 app icon — how to do it right · Sketch","location":"https:\/\/www.sketch.com\/blog\/tinted-app-icons\/?","summary":""},{"summary":"Swift Package Manager(SPM)를 사용해 프라이빗 Swift 패키지를 안전하고 효율적으로 배포하는 방법에 대해 설명합니다. 저자는 전통적인 .xcframework 방식으로 iOS 프레임워크를 배포하던 경험을 공유하며, 업데이트의 어려움과 기술 지원의 비효율성을 언급합니다. 이를 해결하기 위해 SPM을 통한 바이너리 프레임워크 배포를 추천하며, 소스 코드 노출 없이 보안성을 강화할 수 있는 이점에 대해 설명합니다.\n\nSPM을 사용해 프라이빗 배포를 하기 위해서는, 먼저 프라이빗 GitHub 저장소에 패키지를 푸시합니다. 이어서, GitHub의 '잘게 설정된 토큰(fine-grained tokens)'을 생성하여 접근 권한을 제어할 수 있습니다. 이 토큰을 이용해 사용자에게 특별 URL을 제공하여 그들이 Xcode에서 패키지를 쉽게 설치할 수 있도록 합니다. 이 방식은 패키지를 비공개로 유지하면서도 공공 패키지처럼 간편하게 설치할 수 있는 장점을 제공합니다.\n\n이 방법은 개발자의 코드 보안을 유지하면서도 사용자에게 원활한 경험을 제공하며, 패키지 접근에 대한 완전한 통제력을 유지할 수 있습니다. Nuclei에서는 이러한 접근 방식을 통해 SDK를 프라이빗하게 배포하고 통합 문제들을 해결했습니다.\n\n- 개선된 비공개 Swift 배포\n- SPM과 .xcframework 사용\n- GitHub 비공개 저장소 활용\n- Fine-grained tokens 통한 안전한 접근 관리\n- 사용자 친화적 설치 및 업데이트\n\n키워드: Swift Package Manager, .xcframework, GitHub, 비공개 배포, 보안성 강화.","comments":"SPM 방식으로 private 감춰진 패키지를 안전하면서도 효율적으로 배포하는 방식에 대한 설명입니다. private 깃헙 저장소와 토큰을 활용한 접근 제어도 흥미롭네요","title":"Private Swift Package Manager: A Better Way to Share Your Code | by Ajay Prabhakar ","keywords":["Swift","DeveloperTools"],"location":"https:\/\/medium.com\/macoclock\/private-swift-package-manager-a-better-way-to-share-your-code-96e863d31c27"},{"keywords":["Culture","한국어"],"title":"SHOWCASE24 | Apple 디벨로퍼 아카데미","location":"https:\/\/developeracademy.postech.ac.kr\/showcase24","summary":"","comments":"포항에 있는 애플 아카데미도 올해의 쇼케이스 행사를 진행한다고 합니다. 12월 5일 다음주 목요일이네요. 저도 올해는 쇼케이스 행사에 들려봐야겠습니다"},{"keywords":["Swift","SwiftUI","영어"],"comments":"제품에서 스위프트나 SwiftUI 코드 자체를 보여줘야 하는 개발자 관련 도구를 개발한다면 스위프트 문법 하일라이트를 직접 개발해야 할까요? Swift-Syntax라는 프로젝트를 활용한 경험을 소개합니다","location":"https:\/\/sahandnayebaziz.org\/blog\/syntax-highlighting-swiftui-with-swift-syntax?","summary":"Sahand Nayebaziz는 최근에 DetailsPro 애플리케이션에 SwiftUI 코드의 구문 강조 표시 기능을 추가했습니다. 이 기능은 앱 릴리스 초기에부터 요청되었던 것으로, 구현이 복잡할 것이라고 생각해 미루어왔습니다. 하지만 Swift 언어를 이용하여 구문 파싱 및 강조를 쉽게 구현할 수 있었습니다.\n\nSwift-syntax 라이브러리를 사용하여 SwiftUI 코드에서 구문 강조를 수행했습니다. 이 라이브러리는 주어진 Swift 코드를 추상적으로 표현한 후를 탐색하고 조작하는 데 도움을 줍니다. 특히 코드 파싱 및 탐색 기능을 통해 구문 강조 처리를 구현했습니다.\n\n세부적인 구현에서는 'SyntaxVisitor'를 생성하여 관심 있는 코드 부분에 도달할 때마다 특정 행동을 수행합니다. 예를 들어, SwiftUI의 간단한 뷰 선언에 출현하는 노드 유형에 맞춰 방문자를 구성하였고, 각 노드의 범위를 이용하여 AttributedString에 속성을 추가했습니다.\n\nSwift-syntax를 사용할 때 중요하게 알아야 할 두 가지는 'trivia'라는 개념과 'SyntaxVisitor' 함수의 반환 값입니다. 'trivia'는 공백이나 주석 등 Swift 코드에서 눈에 보이지 않는 영역을 의미하며, 이를 활용해 주석 등을 강조할 수 있습니다. 'SyntaxVisitor' 함수에서는 하위 노드를 방문할지를 결정하는 반환 값이 필요한데, 이는 구문 강조 깊이를 조절하는 데 중요합니다.\n\n결과적으로 DetailsPro는 사용자 디자인 선택 시 실시간으로 SwiftUI 코드를 구문 강조해줍니다. 이 기능은 Swift 커뮤니티의 지원을 통해 신뢰할 수 있는 성능을 기대할 수 있습니다.\n\n**키워드:** Swift-syntax, 구문 강조, DetailsPro, SwiftUI, 코딩 기능.","title":"Sahand Nayebaziz: Syntax Highlighting SwiftUI Code with Swift Syntax"},{"summary":"","title":"Shazam, 음악 인식 이용 건수 1,000억 회 돌파 - Apple (KR)","comments":"샤잠을 인수하고 서비스로 내장한 것도 꽤 오래된 것 같네요. ShazamKit도 생겼으니 앱에서 써먹을 수 있을려나요 ","keywords":["APPLE"],"location":"https:\/\/www.apple.com\/kr\/newsroom\/2024\/11\/shazam-hits-100-billion-song-recognitions\/"},{"keywords":["Swift","Architecture"],"summary":"","comments":"싱글톤은 안그래도 안티패턴으로 조심해서 써야하는 방식이지만 스위프트 6가 되면서 더 눈에 띄게 나빠진 것처럼 보입니다. 싱글톤 관련 에러가 많이 보이니까 그런가봅니다. 어떻게 개선할 수 있을까요","title":"Stop Making Singletons in Swift: A Dependency Injection Guide | by Ilia Kuznetsov ","location":"https:\/\/medium.com\/@ivkuznetsov\/how-to-stop-making-singletons-in-swift-a-dependency-injection-guide-dd7bd55abe4d"},{"location":"https:\/\/troz.net\/post\/2024\/swift_format\/?","comments":"Xcode 16부터 지원하는 Swift Format 기능으로 코드를 이쁘게(?) 형식화할 수 있는 방식을 소개합니다. lint와 비슷한 기능도 있지만 제한도 있어서 앞으로가 더 기대됩니다 ","keywords":["DeveloperTools","영어"],"title":"Swift Format in Xcode :: TrozWare — Mac books & articles","summary":"Apple은 Xcode 16 버전에서 Swift 파일을 형식화할 수 있는 'Swift Format' 기능을 도입했습니다. 사용자는 이 기능이 코드 일관성을 높이고 이해도를 향상시켜 개발 생산성을 높일 수 있다고 설명합니다. 작성자는 기존의 SwiftLint를 활용하여 개발을 진행해 왔으나, Swift Format이 Xcode에 내장되어 있어 편리성을 위해 이를 시도하였습니다.\n\nSwift Format은 SwiftLint와는 다른 도구로 SwiftLint와 Prettier와 비교하여 그 기능을 테스트하였습니다. SwiftLint는 몇 가지 문법 수정 기능이 있지만, 기본적으로 공백 문제를 해결하는 데 그쳤습니다. Prettier는 보다 향상된 포맷팅 기능을 제공하였으며, Visual Studio Code와 연동하여 코드 저장 시 자동으로 적용되었습니다. \n\nSwift Format은 표준 설정 파일을 만들 수 있으며, 사용자 설정에 따라 Xcode에서 직접 포맷팅 기능을 제공합니다. 설정 파일을 홈 디렉토리에 '빈칸이 있는 파일'의 형식으로 저장함으로써 모든 Xcode 프로젝트에 적용될 수 있도록 설정할 수 있습니다.\n\n이 도구는 'lint' 옵션을 제공하여 코드를 검토하는 기능도 있으며, 여러가지 방식으로 개인화 할 수 있습니다. 작성자는 swift-format이 Xcode에 내장된 점을 높이 평가하며, 프로젝트에 적용할 예정입니다. Swift Format은 실시간 저장 포맷팅과 같은 기능은 제한되어 있지만, 지속적인 설정 수정을 통해 적합하게 사용할 계획입니다. \n\n주요 키워드: Swift Format, Xcode, 코드 일관성, SwiftLint, 포맷 설정."},{"keywords":["SwiftUI"],"comments":"UICollectionView 처럼 크기에 따라 레이아웃이 조정되는 Flow Layout을 SwiftUI 에서 구현하려고 Layout 프로토콜로 CardLayout을 구현합니다 (그냥 콜랙션 뷰 쓰면 안되나요)","location":"https:\/\/useyourloaf.com\/blog\/swiftui-self-sizing-flow-layouts\/?","summary":"","title":"SwiftUI Self-Sizing Flow Layouts"},{"comments":"맥에 있는 PasteBoard 를 다루는 PasteBoardManager를 만드는 과정을 설명합니다. 맥용 앱 중에 복사된 내용을 찾아서 보여주는 앱 같은 것을 만들 때 유용하겠네요","location":"https:\/\/levelup.gitconnected.com\/swiftui-macos-working-with-nspasteboard-b5811f98d5d1","title":"SwiftUI\/MacOS: Working with NSPasteboard | by Itsuki ","keywords":["AppKit"],"summary":""},{"title":"SwiftUIFX – Swift Package Index","location":"https:\/\/swiftpackageindex.com\/finnvoor\/SwiftUIFX?","keywords":["OpenSources"],"comments":"이거 재밌는 프로젝트군요. SwiftUI 화면을 파이널 컷에서 렌더링해서 보여줄 수 있는 플러그인 코드입니다. 뷰로 애니메이션 만들고 영상 만들기는 좋겠네요!","summary":""},{"keywords":["Design"],"location":"https:\/\/medium.com\/@joeyabanks\/techniques-for-using-auto-layout-in-figma-fb2c874940ae","title":"Techniques for Using Auto Layout in Figma | by Joey Banks ","summary":"Figma에서 자동 레이아웃을 활용하는 기술에 대한 Joey Banks의 글은 디자인 요소를 만들고 최적화하는 방법에 대한 심도 있는 설명을 제공한다. Joey는 Figma에서 제약 조건과 자동 레이아웃을 사용하여 반응형 및 유연한 컴포넌트를 구축하는 데 있어 자신의 경험과 팁을 공유한다. 자동 레이아웃은 콘텐츠의 크기 변화에 따라 컴포넌트 크기를 조정하고, 디자이너가 제품 내 다양한 레이아웃에 맞게 조정할 수 있도록 해준다. 주요 크기 조정 옵션에는 고정(Fixed), 채우기(Fill), 껴안기(Hug)가 있으며, 각각의 특성에 맞게 컴포넌트의 동작을 설정할 수 있다. \n\nJoey는 자동 레이아웃을 처음 활용할 때의 어려움과 그 해결책으로 발견한 방법을 공유한다. 그는 컴포넌트를 만들고 인스턴스를 생성한 후 다양한 사이즈로 테스트하여 문제점을 발견하고 수정하는 접근법을 설명한다. 이를 통해 콘텐츠가 다양한 상황에서도 올바르게 표시되도록 할 수 있다. 이 방법은 컴포넌트를 최적화하고 디자이너 팀이 컴포넌트를 효과적으로 사용할 수 있도록 돕는다. Joey는 이러한 과정에서의 직관적인 피드백을 강조하며, 이를 통해 더 나은 자동 레이아웃 설정과 컴포넌트 디자인을 할 수 있다고 설명한다.\n\n키워드: Figma, 자동 레이아웃, 제약 조건, 반응형 디자인, 컴포넌트 최적화.","comments":"피그마에서 오토 레이아웃을 미리 시뮬레이션할 수 없으니 다양한 사이즈로 테스트하고 문제점을 발견해서 해결하는 방식을 제안합니다 (인터페이스 빌더를 알려주고 싶네요)"},{"keywords":["AI\/ML"],"title":"The Hidden Benefits of Apple Intelligence’s Notification Summaries | by The Useful Tech ","comments":"애플 인텔리전스 Notification 요약 기능에 대한 설명입니다. 지금은 영어만 지원하다보니 한국어도 읽고 영어로 요약해주더군요","summary":"애플은 사용자들의 집중을 돕기 위해 최신 iOS, iPadOS, macOS 업데이트에 '알림 요약(Notification Summaries)' 기능을 도입했습니다. 이 기능은 기기 내 인공지능을 사용해 알림을 요약하는데, 사용자에게 중요한 알림만 제공하여 불필요한 방해를 줄이고 생산성을 높입니다. 알림 요약 기능은 iPhone 15 Pro, iPhone 16, M시리즈 iPad, Apple Silicon Mac에서 사용할 수 있으며, 데이터가 기기를 떠나지 않으므로 개인 정보의 안전성도 보장됩니다.\n\n알림 요약의 주요 숨겨진 이점은 세 가지로 나눌 수 있습니다. 첫 번째로, 작업 중단을 최소화하여 집중력을 향상 시키고 작은 알림에 의한 방해를 줄입니다. 두 번째는 정보 소화능력을 개선한다는 점입니다. 예를 들어, 여러 개의 이메일이나 메시지가 있을 경우 이를 요약하여 보여줌으로써 사용자에게 필요한 중요한 정보만 전달됩니다. 세 번째로, 앱 관리 개선에 기여하여, 사용자가 우선순위를 두고 싶은 앱의 알림만 실시간으로 받게 조정할 수 있습니다. 이러한 기능은 개인화된 경험을 제공하며, 생산성을 높이는 데 중요한 역할을 합니다.\n\n애플은 이 기능을 통해 사용자에게 더욱 효율적이고 스트레스 없는 디지털 환경을 제공합니다. 개인화된 앱 알림 관리와 요약된 알림의 효과적인 활용은 사용자가 중요한 업무에 집중할 수 있도록 도와줍니다. 주요 키워드는 '애플 인텔리전스', '알림 요약', '집중력 향상', '정보 소화능력', '앱 관리 개선'입니다.","location":"https:\/\/medium.com\/macoclock\/the-hidden-benefits-of-apple-intelligences-notification-summaries-90c64f68da00"},{"summary":"객체 지향 프로그래밍(OOP)의 기원에 대한 이야기에서, OOP는 1960년대에 시작되어 지금까지 가장 인기 있는 프로그래밍 패러다임으로 자리잡고 있습니다. OOP의 시초는 1967년의 Simula 67로, 이는 일반 목적의 객체 지향 언어로 탄생했습니다. 최초로 OOP 구조를 공식적으로 도입한 시스템인 Sketchpad는 그래픽에 중점을 두었지만, Simula는 주로 시뮬레이션에 집중하였습니다.\n\nKristen Nygaard와 Ole-Johan Dahl은 시뮬레이션 언어 개발 중에 Simula를 만들었으며, 초기에는 Algol의 전처리 언어로서 구상되었습니다. Simula 1은 클래스를 'activity', 객체(인스턴스)를 'process'로 부르며, 초기 OOP의 기초를 닦았습니다. Simula 67은 이후 일반 목적의 언어로 발전, 다양한 프로그래밍 작업에 활용되었고, 이는 C++와 Java 같은 현대 언어에 큰 영향을 미쳤습니다.\n\nSimula는 객체를 프로세스로 취급하여 서로의 실행을 일시 정지하고 다른 프로세스로 제어를 전환하는 방식으로, 이는 오늘날 여러 언어에서의 co-routines와 유사한 개념입니다. OOP는 본래 시뮬레이션을 위한 DSL로 시작되었으나, 이후 다양한 분야로 확장되었습니다. 이와 별도로 Smalltalk와 같은 순수 객체 지향 언어 또한 독자적으로 발전했습니다.\n\n**주요 키워드: Simula, 객체 지향 프로그래밍, Sketchpad, Algol, 프로세스**","comments":"저도 아직 꼼꼼하게 읽어보지 못했는데요. 범용 목적의 객체 지향 언어로 탄생한 Simula 에 대한 소개입니다. 지금 봐도 67년도 당시에 클래스와 객체 개념을 최초로 도입했다는 것이 참 신기합니다","title":"The Origin Story of Objects: The Birth of Simula | by Aleena ","location":"https:\/\/code.likeagirl.io\/the-origin-story-of-objects-the-birth-of-simula-e45a29fa4437","keywords":["Culture"]},{"comments":"","keywords":["SwiftUI"],"location":"https:\/\/medium.com\/@amin-softtech\/top-10-swiftui-errors-developers-face-and-how-to-fix-them-23f14a181d51","title":"Top 10 SwiftUI Errors Developers Face and How to Fix Them | by Amin Softtech ","summary":""},{"location":"https:\/\/fatbobman.com\/en\/posts\/understanding-swiftui-view-update-mechanism\/?","summary":"이 글은 SwiftUI에서의 자동 뷰 업데이트 메커니즘과 이를 이해하기 위한 사례로 `TimelineView` 업데이트 문제를 탐구합니다. 특히 두 개의 이모지가 다른 업데이트 행동을 보이는 현상을 분석합니다. SwiftUI는 뷰 선언 값의 계산을 특정 조건(예: 상태 변화)에 의해 다시 평가합니다. SwiftUI는 뷰 트리에서 변화가 발생할 경우, 해당 변경 사항을 추적하고 필요시 뷰 선언 값을 재계산하여 사용자 인터페이스를 업데이트합니다. 이때 각 뷰의 인스턴스 값을 저장하고 변화가 발생할 때만 다시 계산하는 효율적인 구조를 가집니다. 이러한 메커니즘을 이해하는 것은 성능 개선에 크게 도움이 됩니다.\n\n주요 내용으로는 SwiftUI에서 뷰가 상태 변화에 응답하여 어떻게 업데이트되는지, 선언형과 반응형 특성, 뷰 타입과 선언의 중요성, 최적화에 대한 고려 사항 등이 포함됩니다. 특히, 복잡한 연산을 피하고 뷰 구조를 적절히 분리하여 성능 최적화를 달성할 수 있음을 강조합니다.\n\n키워드: SwiftUI, 뷰 업데이트 메커니즘, 상태 변화, 성능 최적화, TimelineView 문제.","comments":"여전히 SwiftUI 뷰 렌더링과 업데이트 방식을 투명하게 안내하고 있지 않기 때문에 이 글처럼 여러 실험을 통해서 확인하는 것 같습니다. 상태 변화를 감지하고 반응하여 업데이트되는 흐름에서 최적화를 고려해야 하는 부분을 짚어줍니다.","title":"Understanding SwiftUI's View Update Mechanism - Starting from a TimelineView Update Issue | Fatbobman","keywords":["SwiftUI"]},{"title":"Unveiling My Surprises and Disappointments about the Mac Mini M4 | Mac O","location":"https:\/\/medium.com\/macoclock\/unveiling-my-surprises-and-disappointments-about-the-mac-mini-m4-5daf7d06f5a7","comments":"또 다른 M4 맥 미니 소개글입니다. 전원 버튼이나 작은 팬과 공기 흐름 여러 단점이 있지만 그래도 추천할 만하다고 하네요 (갖고싶다 갖고싶다)","summary":"","keywords":["Hardware"]},{"comments":"웹 어셈블리 기반 런타임 Wasmer 5.0 성능이 향상되고 iOS를 지원한다고 합니다. 저도 아직 동작을 확인하지는 못했지만 이제 iOS 에서도 wasm 코드를 사용할 수 있는걸까요","summary":"Wasmer 5.0은 WebAssembly 기반의 런타임의 최신 안정 버전으로, 여러 플랫폼에서 고성능 애플리케이션을 실행할 수 있는 기능을 크게 강화하여 iOS 장치에까지 지원 범위를 확장했습니다. Wasmer는 WebAssembly 모듈과 패키지를 다양한 플랫폼에서 효율적으로 실행하기 위해 설계된 엔진입니다. 최신 버전인 Wasmer 5.0은 V8 JavaScript\/WebAssembly 엔진, Wasmi 인터프리터, WebAssembly Micro Runtime(WAMR)을 백엔드로 활용하여 iOS 기기에서 WebAssembly 모듈을 실행할 수 있게 합니다.\n\n이 기능은 애플 생태계에서 고성능 애플리케이션의 개발 가능성을 열어줍니다. 특히 모바일 플랫폼에서 고성능 애플리케이션이 가능해지면서 개발자들은 이전에 성능 문제로 제한되었던 혁신적 사례들을 탐색할 수 있게 되었습니다. 이번 버전에서는 코드베이스의 간소화를 중점적으로 다루어 불필요한 부분을 제거하고, 개발 속도를 더욱 빠르게 하는 데 주력했습니다. 이를 통해 20,000줄의 코드가 삭제되었으며, 더욱 효율적인 개발 환경이 조성되었습니다.\n\n성능 개선 또한 여러 면에서 나타났습니다. Module::deserialize나 'wasmer run'을 통한 모듈 실행 시 디시얼라이제이션 속도가 최대 50% 빨라졌고, LLVM 18을 포함한 툴체인의 최신 최적화를 사용할 수 있습니다. Cranelift 컴파일러 백엔드를 사용한 결과, 이전 버전과 비교해 8%의 속도가 향상되었습니다.\n\n이처럼 Wasmer 5.0은 iOS 기기를 포함한 여러 플랫폼에 고성능 애플리케이션을 가져오는 중요한 계기를 마련하였습니다. 코드베이스의 간소화와 성능의 향상은 빠른 개발과 새로운 기능의 마련을 가능하게 하며, 이는 커뮤니티의 생태계 유연성과 적응성을 유지하려는 헌신을 잘 보여줍니다.\n\n**키워드: WebAssembly, Wasmer 5.0, iOS 지원, 고성능 애플리케이션, 코드 간소화**","keywords":["DeveloperTools"],"title":"Wasmer 5.0 Brings High-Performance Applications to iOS Devices | by Valentin Podkamennyi ","location":"https:\/\/medium.com\/majordigest\/wasmer-5-0-brings-high-performance-applications-to-ios-devices-1877d5390d17"},{"title":"What is a Crash?. An exceptional deep dive | by Jacob Bartlett ","comments":"매일 만나는 크래시. 스위프트 런타임과 XNU 다윈 커널이 어떤 경우에 시스템 수준에서 크래시를 발생하는 지 여러 가지 경우를 설명합니다. BAD_ACCESS 에러를 드디어 피할 수 있으려나요","location":"https:\/\/levelup.gitconnected.com\/what-is-a-crash-b7fb494e1977","keywords":["AI\/ML","Swift","OpenSources"],"summary":"앱이 \"크래시\"하는 이유에 대한 심도 깊은 분석이었습니다. 크래시는 앱이 예기치 않게 종료될 때 발생하지만, 이는 사실 특정한 상황에서 시스템이 기기 안전을 위해 앱을 의도적으로 종료시키는 것입니다. 크래시는 사용자를 보호하기 위한 예방책으로, 데이터 손실이나 보안 침해와 같은 더 심각한 문제를 방지합니다.\n\niOS 앱에서 크래시는 주로 두 가지 출처에서 발생합니다: Swift 런타임과 XNU 커널입니다. Swift 런타임은 메모리 안전 위반을 감지하면 프로세스를 종료하고, 이는 보통 비할당 메모리에 접근하는 경우 발생합니다. XNU 커널은 운영 체제의 핵심으로, 앱이 메모리 접근 위반을 시도할 때 시스템 수준에서 크래시를 유도합니다.\n\n크래시는 예를 들어 Watchdog가 메인 스레드를 20초 이상 차단했을 때와 같은 경우 시스템이 프로세스를 종료시키는 즉, 앱을 충돌시키는 수많은 방식 중 하나로 발생할 수 있습니다. XNU의 Mach 서브시스템은 가상 메모리 관리 담당으로, EXC_BAD_ACCESS와 같은 예외를 처리하여 메모리 주소 공간의 무결성을 보호합니다.\n\nSwift 런타임의 \"Unowned\" 참조 충돌은 메모리가 이미 비할당된 객체에 접근하려 할 때 발생하며, XNU 커널의 EXC_BAD_ACCESS는 안전하지 않은 Swift 코드로 인해 발생할 수 있습니다. 이러한 크래시들은 시스템을 보호하고 잠재적인 위협으로부터 사용자를 방어하는 중요한 기능입니다.\n\n키워드: \n- 크래시 개념\n- Swift 런타임\n- XNU 커널\n- 메모리 안전\n- 시스템 보호"},{"keywords":["Culture"],"summary":"Julian Cosky는 Bear 앱이 Apple Notes보다 선호되는 이유를 설명합니다. 그는 기본적으로 폴더보다 태그를 사용하는 것이 더 나은 노트 정리 방법이라고 주장하며, Bear 앱이 이 부분에서 매우 우수하다고 강조합니다. Bear 앱은 태그 기반의 정리를 지원하며, 이 태그는 텍스트 내부에 자유롭게 삽입될 수 있습니다. 이와 대조적으로, Apple Notes의 iCloud 동기화가 잘 동작하지 않아 기기 간 데이터 불일치를 경험했다고 말합니다. 또한 Apple의 스마트 폴더는 하위 폴더 생성이 불가능하여 사용에 제한성이 있다고 언급합니다.\n\nBear 앱은 또한 중첩된 태그를 통해 사용자가 메모를 더욱 유연하게 관리할 수 있게 해줍니다. Bear의 '정보 패널'은 노트에 대한 중요한 정보를 제공하며, 마크다운을 지원하여 다양한 포맷 옵션을 제공합니다. 길고 복잡한 문서 내부에서도 링크를 추가하거나 관리할 수 있어, Bear에서의 문서 관리가 더 효과적입니다.\n\n그러나 Apple Notes는 Apple Pencil을 통한 손글씨 입력 기능에서는 더 유리하다고 평가합니다. Bear는 일정 구독료를 요구하지만, 이는 iCloud 동기화, 다양한 테마 및 아이콘 제공, 전체 노트 검색 기능 등을 포함하여 충분한 가치를 제공한다고 설명합니다. Cosky는 Bear 앱을 통해 노트 작성이 더욱 간편해졌으며, 그는 이 앱이 자신의 노트 작성 플랫폼임을 강조합니다.\n\n**핵심 키워드:** Bear 앱, Apple Notes, 태그 정리, iCloud 동기화, 정보 패널.","title":"Why Bear App Is My Favourite Notes App | by Julian Cosky ","comments":"한동안 떠오르는 메모 앱으로 Bear를 꼽았었는 데요. 유료 지만 태그도 지원하고 문서 관리가 더 편하다는 것을 강조합니다. Bear 사용자분들 계신가요","location":"https:\/\/medium.com\/productivity-matters\/why-bear-app-is-my-favourite-notes-app-83d2377abde9"},{"summary":"Apple의 M4 Mac Mini의 전원 버튼이 하단에 배치된 것에 대해 논쟁이 있습니다. 많은 사람들이 이를 설계상의 오류로 보고 있으며, 이전의 Magic Mouse 충전 포트 위치와 비교하기도 합니다. 가장 최근 모델에서는 전원 버튼이 장치 하단에 있어 사용자가 컴퓨터를 켜기 위해 기기를 들어올리거나 앞으로 기울여야 한다는 문제점이 지적되고 있습니다.\n\n이러한 결정이 단순한 실수일까, 아니면 의도된 설계일까에 대한 논의가 진행 중입니다. 이전 Mac Mini 모델들은 대체로 후면에 전원 버튼을 배치하여 사용자가 뒤로 손을 뻗어 접근하도록 했습니다. Mac Mini의 하단에 전원 버튼을 배치함으로써 Apple은 사용자들이 물리적인 전원 버튼과 자주 상호작용할 필요가 없다고 판단했을 가능성이 큽니다.\n\nApple의 마케팅 전략에 따르면 Mac Mini는 대부분 한 번 설치하고 움직이지 않는 데스크톱 컴퓨터로 간주되며, 매일 전원을 끄는 것보다 절전 모드를 선호하는 현대 컴퓨터 습관에 기반하고 있습니다. 이는 전원 버튼의 하단 배치가 과도한 디자인처럼 보일 수 있지만, 미적 청결과 공간 최적화, 실수로 인한 셧다운 방지 등 여러 설계상의 이점을 제공합니다.\n\n결론적으로, M4 Mac Mini의 하단 전원 버튼은 현대 사용자 습관과 Apple의 최소주의 디자인 철학을 반영한 의도적인 설계 선택일 가능성이 높습니다.\n\n키워드: Mac Mini, 전원 버튼, 디자인 논란, 사용자 습관, 미니멀리즘","comments":"맥 미니 하단으로 옮긴 전원 버튼에 대해 이야기합니다. 대부분 미니를 끄지 않는 사람들이 더 많아서 괜찮다고 생각하고 과감하게 설계한 게 아닐까요","location":"https:\/\/uxdesign.cc\/why-is-the-mac-mini-power-button-on-the-bottom-5f82dfe2e564","title":"Why is the Mac mini power button on the bottom? | by Elvis Hsiao ","keywords":["Hardware"]},{"location":"https:\/\/blog.protein.tech\/xcode-chatgpt-official-support-is-available-now-dc21998f3653","comments":"ChatGPT 플러그인 연결 과정에 대한 또 다른 글입니다. 같이 읽어보시면 좋겠네요. 코파일럿 플러그인도 써봤는데 IDE에서 동작하는 것과 화면에 대해 설명하는 것은 또 다른 느낌이더군요","title":"Xcode & ChatGPT: Official Support | Medium ","summary":"","keywords":["DeveloperTools"]},{"summary":"","keywords":["Swift"],"location":"https:\/\/paigeshin1991.medium.com\/mastering-actor-isolation-with-swifts-nonisolated-and-isolated-keywords-ce571ae0ced8","comments":"액터가 동작할 때 특정 속성을 분리해서 처리할 지, 분리하지 않아도 되는지 isolated 와 nonisolated 키워드에 대해 설명합니다. 아직 직관적으로 나누지 못하시겠다면 조금씩 바꿔보는 것도 좋겠습니다","title":"iftMastering Actor Isolation with Swift’s Nonisolated and Isolated Keywords | by KD Knowledge Diet "},{"location":"https:\/\/github.com\/mRs-\/Black-Friday-Deals?","title":"mRs-\/Black-Friday-Deals: Black Friday Deals for macOS \/ iOS Software & Books","keywords":["Culture"],"comments":"ㅎㅎ 매년 딱 이맘때만 업데이트하는 바로 그 저장소. 올해도 블랙 프라이데이 딜을 소개하는 저장소입니다","summary":""},{"comments":"맥 화면 아래 Dock 타일을 변경할 수 있는 플러그인 만드는 예제 코드라고 합니다","keywords":["OpenSources"],"title":"marioaguzman\/NSDockTilePlugIn-Example","summary":"","location":"https:\/\/github.com\/marioaguzman\/NSDockTilePlugIn-Example?"},{"comments":"SwiftUI로 만든 여러가지 화면들 쇼케이스라고 합니다. 특이한 동작이 많이 있으니까 구경해보세요","keywords":["OpenSources","SwiftUI"],"title":"mikelikesdesign\/SwiftUI-experiments: Examples with SwiftUI that showcase various interactions, animations and more","location":"https:\/\/github.com\/mikelikesdesign\/SwiftUI-experiments?","summary":""}],"version":"1.0"}