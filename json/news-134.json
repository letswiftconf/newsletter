{"items":[{"location":"https:\/\/swift-pal.com\/7-swift-string-interpolation-tricks-that-will-make-you-a-better-developer-5d08cc9c55aa","keywords":["Swift"],"summary":"이 글은 Swift 프로그래밍에서 문자열 보간(String Interpolation)을 효율적이고 강력하게 활용하는 방법에 대한 심층 가이드입니다. 저자는 여러 해의 iOS 개발 경험과 코드 리뷰를 통해 문자열 처리의 성능, 가독성, 유지보수성에 큰 영향을 미치는 핵심 기법들을 소개합니다.\n\n첫 번째로, 커스텀 문자열 보간 방법을 만들어 자신만의 타입에 맞는 설명문을 작성하는 법을 설명합니다. 이를 통해 복잡한 객체를 디버깅할 때 시간과 노력을 크게 절약할 수 있습니다. 두 번째는 숫자 포매팅 기술로, Currency, Percent 등의 포맷팅을 Helper 확장 함수로 만들어 재사용하는 방법을 안내합니다. 이는 미숙한 수작업 포맷팅의 문제점을 해결하는 'Professional'한 방법입니다.\n\n세 번째로, 문자열 보간이 성능에 미치는 영향을 살펴봅니다. 매 반복마다 불필요한 Date, UUID 객체를 새로 생성하는 코드를 피하고, 문자열 빌더를 활용하여 효율적인 문자열 생성법을 제시합니다. 네 번째, SwiftUI와의 연계성을 강조하며, 조건부, 복잡한 포맷팅, 국제화 등을 자연스럽게 통합하는 실용적인 예제들을 보여줍니다.\n\n다섯 번째는 앱 내 텍스트를 다국어로 로컬라이즈하는 방법입니다. 문자열을 하드코딩하는 대신, NSLocalizedString과 커스터마이징된 String 확장을 활용해 깔끔하고 유지보수하기 쉬운 해결법을 소개합니다. 여섯 번째로, 커스텀 문자열 보간 확장을 통해 날짜, JSON, 선택적 값 등을 손쉽게 포맷하는 기법을 설명하여 디버깅, 로그 출력에서 큰 도움이 될 수 있음을 강조합니다. 마지막으로, 일상 디버깅용 인터폴레이션을 만들어 디버그 메시지를 풍부하게 하고, 파일명과 라인 정보를 첨가하는 팁도 제공됩니다.\n\n이 글은 문자열 보간이 단순한 구문이 아니라, 성능 최적화, 디버깅, 국제화, 코드 가독성 향상에 핵심 역할을 하는 강력한 도구임을 강조하며, 다양한 예제와 함께 실무에 바로 적용 가능한 기법들을 상세히 소개합니다.\n\n키워드: Swift, 문자열 보간, 커스텀 포맷팅, 성능 최적화, 디버깅","title":"7 Swift String Interpolation Tricks That Will Make You a Better Developer | by Karan Pal ","comments":"문자열을 만드실 때 어떻게 만들고 계신가요. 다양하고 깔끔하게 만드는 방식을 소개합니다"},{"location":"https:\/\/medium.com\/@lewisjdoyle\/7-ways-android-is-better-than-ios-c940f4dd6791","keywords":["Culture"],"summary":"이 글은 주로 iPhone 사용자이자 삼성 Galaxy 사용자인 저자가 Android, 특히 Samsung One UI가 iOS보다 우수하다고 느끼는 여러 기능들을 소개하는 내용입니다. 저자는 자신의 iPhone 16 Pro Max와 Galaxy를 병행 사용하면서 각 플랫폼의 강점과 차이점을 비교하고 있습니다.\n\n먼저, 앱 내비게이션의 편리성에 대해 언급하며, Galaxy 기기에서는 하나의 손가락으로 빠르게 앱 목록을 열어 앱을 찾을 수 있어 매우 직관적이라고 평가합니다. 이어서 위젯 커스터마이징 기능에서는 특히 배경에 어울리도록 투명하게 만들 수 있는 Samsung 위젯이 깔끔하고 유용하다고 언급합니다.\n\n스마트폰의 계속 스크린샷 기능도 강조하는데, 여러 페이지를 하나의 이미지로 캡처할 수 있어 온라인 주문 정보나 메뉴 공유 시 유용하다고 합니다. 멀티태스킹 역시 Galaxy에서 효율성을 높이는 강력한 기능으로 소개되고, 특히 폴더블 기기에서는 더욱 뛰어날 것이라고 기대를 표합니다. 또한, 엣지 패널을 통해 빠르게 필요한 정보를 찾거나 앱에 접근하는 편리성을 높이 평가합니다.\n\nGalaxy AI는 웹 페이지 요약 기능으로 중요한 내용을 신속하게 파악할 수 있어 일상생활에 큰 도움을 준다고 합니다. 마지막으로 ‘Universal Back’ 기능을 통해 안드로이드에서는 복잡한 탐색 없이 쉽게 이전 화면으로 돌아올 수 있으며, 이는 iPhone에서 일관성 있게 작동하지 않는 문제와 비교되어 소개됩니다.\n\n저자는 이러한 기능들이 iPhone보다 Android을 더 편리하고 직관적이라고 느끼게 하는 중요한 이유라고 평가하며, 플랫폼 간 전환 시 고려할 만한 점들을 제시하고 있습니다. 전반적으로 Android의 앱 검색, 위젯, 스크린샷, 멀티태스킹, 엣지 패널, AI 지원, 그리고 일관된 뒤로가기 기능 등 다양한 면에서 강점을 강조하는 글입니다.\n\n주요 키워드: Android, Galaxy, 앱내비게이션, 위젯, 멀티태스킹, AI, Universal Back","title":"7 Ways Android is Better than IOS | by Lewis J Doyle ","comments":"아이폰과 iOS가 새로 나와도 갤럭시와 안드로이드에 이미 있는 기능인 경우가 많죠. 삼성 One UI가 더 편한 부분들을 비교하는 글입니다 "},{"location":"https:\/\/www.avanderlee.com\/swiftui\/viewbuilder\/?","keywords":["SwiftUI"],"summary":"","title":"@ViewBuilder usage explained with code examples - SwiftLee","comments":"뷰 빌더 직접 만들어서 사용하고 계신가요? body만 구현해도 뷰 빌더이긴 한데 세밀하게 다루기 위한 방식을 예제 코드로 설명합니다"},{"location":"https:\/\/medium.com\/@itsuki.enjoy\/a-simple-gui-for-apple-container-like-the-docker-desktop-f16148c8bcc0","keywords":["AppKit"],"summary":"","title":"A Simple GUI For Apple Container. Like the Docker Desktop! | by Itsuki ","comments":"애플 컨테이너를 쉽게 조작할 수 있는 데스크톱 GUI 앱을 만들었네요. 이제 컨테이너 기반으로 배포하는 맥 앱들이 꽤 나오지 않을까요?"},{"location":"https:\/\/levelup.gitconnected.com\/advanced-keyframe-animations-in-swiftui-5e5de2df9e33","keywords":["SwiftUI"],"summary":"","title":"Advanced Keyframe Animations in SwiftUI | by Jacob Bartlett ","comments":"타이밍이 다 동일하지 않아서 키 프레임 애니메이션이 꼭 필요한 경우가 있죠. 상세하게 설명하는 글이라 좋습니다"},{"location":"https:\/\/medium.com\/macoclock\/airpods-pro-3-huge-things-are-promised-71263c682e59","keywords":["Hardware"],"summary":"","title":"AirPods Pro 3 — huge things are promised | by David Lewis ","comments":"에어팟 프로 2가 살짝 기대에 못 미쳤다고 생각하신다면 이번 에어팟 프로 3가 딱 좋을 것 같네요. 실시간 번역 기능 써보고 싶네요 ㅎㅎ"},{"location":"https:\/\/swiftpackageindex.com\/dagronf\/AppKitUI","keywords":["OpenSources","AppKit"],"summary":"","title":"AppKitUI – Swift Package Index","comments":"NSView 화면 내용을 XIB 없이 SwiftUI 처럼 쉽게 만들 수 있도록 도와주는 라이브러입니다"},{"location":"https:\/\/blog.stackademic.com\/apple-rejected-my-app-here-is-the-reason-e2b8a6bac6ef","keywords":["Culture"],"summary":"이 글은 iOS 앱 개발자가 앱 심사 과정에서 겪은 경험과 교훈을 다루고 있습니다. 저자는 자신의 앱이 '승인'되지 않아, 그 이유가 단순히 버튼 텍스트 문제였음을 알게 되었습니다. 구체적으로, 사용자 허가 요청 화면에서 “Allow”라는 버튼을 사용했는데, 이는 애플의 가이드라인에 위배되는 것으로, iOS의 시스템 권한 요청은 이미 “Allow”와 “Don't Allow” 버튼이 제공되기 때문에, 개발자가 별도 버튼에 “Allow”라고 표기하면 사용자에게 오해를 불러일으키고, 이는 ‘dark pattern’(사용자를 속이거나 유도하는 설계)로 간주됩니다.\n\n애플은 사용자에게 권한 허가를 유도하는 것이 아니라, 공식 시스템 다이얼로그를 통해 결정하게 해야 한다고 강조합니다. 따라서 개발자는 “Allow” 대신 “Continue”라는 중립적인 단어를 사용하도록 변경해야 하며, 안드로이드의 경우에는 “Allow”를 유지하는 것이 허용됩니다. 이 변경으로 저자의 앱은 승인받았고, 이는 심사 기준이 엄격하더라도 공식 가이드라인을 준수하는 것이 중요하다는 교훈을 제공합니다.\n\n이 경험을 통해 개발자는 애플이 코드보다 사용자 심리와 선택권을 더욱 중요시한다는 사실을 깨닫게 되었으며, 작은 단어 하나도 앱 승인에 영향을 미칠 수 있음을 알게 되었습니다. 궁극적으로, 사용자에게 신뢰와 선택권을 보장하는 것이 앱과 플랫폼의 건강한 생태계를 유지하는 핵심임을 강조합니다.\n\n핵심 키워드: iOS 권한 승인, dark pattern, 사용자 심리, 가이드라인 준수, 앱 승인 성공","title":"Apple Rejected My App. Here is the Reason | by Mobile App Developer ","comments":"사소하게도 \"승인\" 버튼 타이틀 때문에 스토어 심사 리젝당한 사례를 공유합니다. 시스템 권한 요청시 시스템 다이얼로그는 \"Allow\" 허용이 가능하지만, 개발자가 만드는 경우는 \"Continue\" 계속한다는 중립적인 의미로 사용하라고 권장합니다 "},{"location":"https:\/\/medium.com\/@topbrains\/apples-local-ai-revolution-12a65b92c158","keywords":["AI\/ML"],"summary":"이 기사에서는 애플이 추진하는 현지 AI(로컬 AI) 혁신과 그 잠재력을 집중적으로 분석합니다. 현재 시장에서는 대형 언어모델(LLM)이 웹에서 데이터를 수집하고 이를 기반으로 하는 것들이 주도하고 있지만, 애플은 개인정보보호와 로컬 처리에 중점을 둔 차별화 전략을 택하고 있습니다. 애플은 챗GPT와 경쟁하는 대신 자체 개발한 UICoder라는 AI 기술을 통해 SwiftUI 개발을 간소화하며 개발자와 일반 사용자 모두에게 강력한 도구를 제공하려 하고 있습니다.\n\nUICoder는 온디바이스에서 작동하는 자기 학습형 LLM로, 사용자 데이터를 절대 클라우드에 의존하지 않으며, 개인정보 보호를 철저히 지키는 것이 특징입니다. 이 모델은 반복적인 피드백을 통해 인간이 배우는 방식과 유사하게 스스로 학습하며, SwiftUI 코드 자동 생성 능력으로 개발 효율성을 크게 향상시키고 있습니다. 특히, Xcode 26과 같은 애플의 최신 개발 환경에서는 UICoder가 실시간으로 UI 추천, 프로토타입 제작, 코드 검증 등을 제공하여 개발자의 작업을 크게 단축시킬 것으로 기대됩니다.\n\n이와 함께 애플의 최첨단 M시리즈 칩의 성능과 메모리 아키텍처 덕분에, 초고속, 대용량의 데이터를 온디바이스에서 처리하며 개인정보도 보호하는 것이 가능해졌습니다. 향후 '울트라-RAM' 등 차세대 메모리 기술은 더 큰 데이터와 빠른 인퍼런스를 가능하게 하여, 완전히 온디바이스 기반의 AI 생태계를 구축하는 데 핵심 역할을 할 전망입니다.\n\n이 기술은 단순히 개발자 편의성을 넘어서, 영어(혹은 모국어)로 앱 개발이 가능하게 함으로써, 교차 플랫폼 개발의 한계를 뛰어넘는 혁신을 기대케 합니다. 애플은 이 전략적 온디바이스 AI 생태계를 아이폰, 아이패드, 맥, 심지어 애플워치까지 확대하는 계획입니다.\n\n요약하면, 애플의 로컬 AI 전략은 데이터 프라이버시, 개발자 편의성, 하드웨어 성능의 융합을 통해 차세대 인공지능 생태계를 만들어내는 방향성을 보여주고 있으며, 이는 기존 클라우드 기반 AI와는 차별화된, 강력하고 신뢰성 높은 새로운 패러다임을 제시합니다.\n\n키워드: 애플, 로컬 AI, UICoder, SwiftUI, M시리즈","title":"Apple’s Local AI Revolution | by R. F. Dace ","comments":"애플은 여전히 온디바이스 AI 전략으로 로컬에서 파운데이션 모델을 제공하면서 프라이버시와 개발자 편의성을 동시에 만족시키려고 한다고 말합니다. UICoder 라는 에이전트가 본격적으로 도입이 되려나요"},{"location":"https:\/\/uxdesign.cc\/auditing-your-design-system-for-accessibility-49784d15ae56","keywords":["Accessibility"],"summary":"이 글은 디자인 시스템의 접근성(Accessibility) 점검과 개선 방법에 대한 가이드입니다. 웹 접근성은 후처리할 것이 아니라, 처음부터 설계에 반영되어야 하며, 이를 위해 시스템 수준에서 장애를 줄이는 노력이 필수적입니다. 접근성 결함이 발견되면, 이를 개별 UI 요소나 제품에 일일이 수정하는 대신 시스템 전체에 영향을 미치는 방식으로 해결하는 것이 효과적입니다. 예를 들어, 버튼의 색상 대비 문제가 WCAG 기준에 미치지 못한다면, 이를 시스템 차원에서 수정하면 모든 제품에 일괄 적용됩니다.\n\n접근성을 설계 시스템에 내재화하는 장점은 맞춤형 재작업을 줄이고, 개발 속도를 높이며, 포용적 디자인을 촉진하는 데 있습니다. 이를 위해서는 먼저 감사(audit)를 위한 준비가 필요하며, 전체 시스템의 범위를 정하고 적합한 도구와 기준을 선택하는 것부터 시작해야 합니다. 감사는 주로 색상, 타이포그래피, UI 컴포넌트, 패턴 등 핵심 요소를 체크하는 단계로 나뉘며, 수작업과 자동화 도구를 병행해 검증합니다. WCAG 가이드라인에 따르며, 유럽연합이나 미국 연방정부와 같은 특정 정책을 준수하는 기준을 세울 수 있습니다.\n\n감사 과정에서는 먼저 시스템 전체를 리스트화하고, 각 항목별 문제를 기록하며, 심각도(중대, 대수, 경미)와 해결 난이도(작은 수정, 구조적 변경, 재구성)에 따라 우선순위를 정하는 것이 중요합니다. 이를 통해 빠른 개선이 가능한 ‘퀵 윈(s)’부터 큰 문제를 해결하는 전략적 프로젝트까지 체계적으로 접근할 수 있습니다.\n\n이처럼 접근성 점검은 체계적이고 단계별로 진행되어야 하며, 일회성이 아니라 지속적인 품질 관리를 통해 포용적이고 접근 가능한 디자인 시스템을 구축하는 것이 핵심입니다. 빠른 수정과 적절한 우선순위 선정이 더 나은 사용자 경험 제공과 법적 준수에 도움을 줄 수 있으며, 결국 모든 사용자에게 더 포용적이고 접근하기 쉬운 디지털 환경을 만들어 줍니다.\n\n**핵심 키워드:**  \n접근성, 디자인 시스템, WCAG, 감사(에어듀트), 우선순위","title":"Auditing your Design system for accessibility | by Allie Paschal ","comments":"디자인 시스템에 대해 접근성 관점에서 점검하고 개선하기 위한 기준을 제안합니다"},{"location":"https:\/\/elegantchaos.com\/2025\/08\/28\/action-builder.html","keywords":["DeveloperTools","영어"],"summary":"이 글은 Swift 개발환경에서 GitHub Actions 워크플로우 자동화 도구를 재개발하는 과정을 설명합니다. 이전에는 Action Status라는 macOS 앱의 일부로 CI 모니터링 기능과 함께 워크플로우 파일을 자동 생성하는 도구를 만들었으며, 후에 Swift 플러그인 지원의 등장으로 별도 플러그인 개발도 시도했지만, Swift 플러그인 지원의 미성숙과 의존성 문제로 어려움을 겪었습니다. 그래서 이 기능을 독립적인 도구로 다시 개발하는 방향으로 전환하고자 합니다.\n\n이 도구는 Swift 패키지 소스 폴더를 가리키면 적절한 Github Actions 워크플로우 YAML 파일을 자동으로 생성하며, 적은 설정으로도 작동하게 디자인하고자 합니다. 이를 위해 대부분의 필요한 정보를 패키지 매니페스트에서 추출하는 방식을 고려 중이며, Swift 버전 및 환경 설정 문제도 Swiftly와 같은 도구를 활용하여 해결하려 합니다. 특히, 다양한 Apple 플랫폼(iOS, tvOS, watchOS, visionOS)에 대해 지원하는 과정이 도전적이지만, Xcode와 Swift Package Manager가 점차 통합 방향으로 나아가고 있어 기대하고 있습니다.\n\n현재는 ActionBuilderCore의 커맨드라인 도구를 재부활시켜 Swift 6.0, 6.1, 6.2-snapshot 버전까지 대응하는 작업을 진행 중입니다. 미래에는 더 간소화된, '제로-설정' 환경을 목표로 하며, 대부분의 작업은 수동이 아니라 자동으로 처리될 수 있는 방향으로 발전시키고 있습니다. 이 프로젝트는 개발자들이 보다 쉽게 Swift 프로젝트에 맞는 CI\/CD 워크플로우를 만들 수 있도록 돕는 것을 목표로 하고 있습니다.\n\n키워드: \n1. GitHub Actions\n2. Swift 자동 워크플로우\n3. 개발 도구 재개발\n4. 플랫폼 지원 문제\n5. Zero-configuration","title":"Automating Github Action Workflows For Swift","comments":"깃헙 액션 모니터링 앱을 만들었다가 패키지를 선택하면 워크플로우 YAML 파일을 자동으로 만들어주는 도구까지 만든 배경을 설명합니다. 내용에 저장소 링크도 있으니 같이 살펴보시면 좋겠네요"},{"location":"https:\/\/swiftwithmajid.com\/2025\/08\/19\/building-ai-features-using-foundation-models\/","keywords":["AI\/ML","영어"],"summary":"이 글은 Apple이 새롭게 도입한 Foundation Models 프레임워크를 이용하여 앱 내 AI 기능을 구현하는 방법을 설명합니다. 이 프레임워크는 타입 안전 API를 제공하며, Apple Intelligence 모델을 활용해 텍스트 생성, 추천, 또는 자연어 처리 기능을 쉽게 통합할 수 있도록 도와줍니다. \n\n먼저, FoundationModels 프레임워크를 import하고, 디바이스가 모델을 지원하는지 여부를 체크하는 것이 중요합니다. 지원하지 않는 경우에는 사용자에게 알림을 통해 활성화를 요청하는 방식을 추천합니다. 이를 위해 SystemLanguageModel의 isAvailable 및 availability 속성을 활용하여 더 세분화된 상태 체크도 가능합니다.\n\nAI 세션을 개시하는 방법도 간단합니다. LanguageModelSession을 생성하고 respond() 함수를 호출하면, 자연어 입력에 대한 답변이나 추천 결과를 받아올 수 있어 매우 직관적입니다. 예를 들어, 식단 분석과 추천 생성과 같이 자연어 기반 작업도 쉽게 수행할 수 있습니다.\n\n여기서 중요한 점은, 모델에 전달하는 프롬프트(지시문)과 함께 GenerationOptions를 활용하여 출력 결과를 조절하는 것인데, 이때 temperature 값(0~1 범위)은 생성의 창의성과 다양성을 조절하며, sampling 모드와 seed는 일관성을 유지하거나 특정 일자별 추천 등을 가능하게 합니다. 예를 들어, seed를 활용하면 매일 다른 추천을 제공하거나, 일관된 추천을 보여줄 수 있습니다.\n\n전반적으로, Foundation Models 프레임워크는 직관적이고 개발자 친화적으로 설계되어 있어, 개인화 추천, 지능형 워크플로우 등 다양한 AI 기능을 간단히 통합할 수 있습니다. 다양한 옵션을 실험하며 최적의 결과를 찾는 것이 핵심이며, 궁금증이 생기면 개발자 커뮤니티와 소통하기를 추천합니다.\n\n키워드: Foundation Models, AI 통합, 자연어 처리, 커스터마이징, Swift 개발","title":"Building AI features using Foundation Models | Swift with Majid","comments":"시스템 파운데이션 모델을 활용하는 예제가 조금씩 느리게 공유되는 것 같습니다. 다양한 사례가 더 많이 나오면 좋겠네요"},{"location":"https:\/\/www.swiftbysundell.com\/articles\/building-a-design-system-at-genius-scan\/?","keywords":["SwiftUI","UIKit","영어"],"summary":"이 글은 Swift 기반의 앱 개발에서 UI 일관성 유지와 코드 재사용성을 높이기 위해 '디자인 시스템'을 구축하는 방법에 대해 설명합니다. 특히, 개발팀이 직면하는 UI 구성요소의 버전차이, 중복된 수정 과제, 그리고 복잡한 UI 코드를 해결하는 효과적인 전략으로서의 디자인 시스템 설계에 초점을 맞추고 있습니다.\n\n초기 문제점은 여러 리스트 뷰에서 UI 일관성 유지의 어려움으로, 이로 인해 버그 및 코드 중복이 발생하는 점이었습니다. 이를 해결하기 위해, 개발자는 리스트 구조를 표준화하는 방향으로 접근하며, 이 과정에서 재사용성과 유연성을 고려한 컴포넌트 설계가 중요하다고 강조합니다.\n\n글에서는 SwiftUI의 강력한 컴포지션(구성) 원칙을 활용해 기본 `Row` 컴포넌트를 만들고, 이를 바탕으로 텍스트 입력 등의 복합 UI 요소를 확장하는 예제를 제시합니다. 이러한 구성요소들은 변화하는 요구사항에 쉽게 맞춰 조정 가능하며, 코드를 재사용하는 동시에 사용 사례별 커스터마이징도 용이하게 설계됩니다.\n\n환경(Environment) 값을 활용해 다양한 스타일이나 색상, 간격 등의 UI 속성을 중앙에서 관리하는 방법도 설명하며, 이를 통해 디자인 시스템의 일관성과 유연성을 극대화할 수 있음을 보여줍니다. 특정 스타일을 선택하는 API 역시 환경 변수를 이용하여 구현하여, 별도의 수정 없이 스타일을 교체할 수 있도록 설계하는 방식입니다.\n\n이와 같은 점진적 접근법은 새로운 컴포넌트 추가, 디자인 변경에 따른 확장성에 유리하며, 궁극적으로 개발자와 디자이너 간의 협업 효율을 높입니다. 글은 \"규모가 커지고 복잡성이 높아질 때\"에 더욱 빛나는 디자인 시스템의 이점을 강조하며, 지속적인 발전과 개선을 통해 앱의 성장에 맞춘 유연성을 제공하는 중요한 전략임을 설명합니다.\n\n이 글은 SwiftUI 기반 앱에서 UI 일관성 유지와 효율적인 재사용을 위해, 컴포지션 원칙을 활용한 유연한 디자인 시스템 구축 방법을 사례 중심으로 소개하며, 점진적 개발과 환경 변수 활용의 중요성을 강조합니다.\n\n키워드:  \n1. SwiftUI  \n2. 디자인 시스템  \n3. 컴포지션  \n4. 환경(Environment) 활용  \n5. 재사용성","title":"Building a design system at Genius Scan | Swift by Sundell","comments":"SwiftUI 기반 앱에서 UI 일관성 유지와 효율적인 재사용을 위해, 컴포지션 원칙을 활용한 유연한 디자인 시스템 구축 방법을 사례 중심으로 소개합니다. 역시 선델이네요"},{"location":"https:\/\/medium.com\/@victorbaro\/custom-swiftui-transitions-with-metal-680d4e31a49b","keywords":["SwiftUI","영어"],"summary":"","title":"Custom SwiftUI transitions with Metal | by Victor Baro ","comments":"이런 메탈 관련 글보면 메탈 쉐이더 잘쓰고 싶네요. 커스텀 트랜지션 만들기입니다"},{"location":"https:\/\/azamsharp.medium.com\/effective-communication-between-observable-stores-in-swiftui-7e81590da355","keywords":["SwiftUI"],"summary":"","title":"Effective Communication Between Observable Stores in SwiftUI | by Mohammad Azam ","comments":"관찰 가능한 저장값을 확인하고 처리하는 다양한 구현 패턴을 비교하고 소개합니다. 어떤 방식을 선호하시는지 비교해보시죠"},{"location":"https:\/\/medium.com\/synergyboat\/flutter-vs-react-native-vs-native-2025-benchmark-comparison-82271b3fbb05","keywords":["Culture"],"summary":"2025년 기준으로 Flutter, React Native, 네이티브(iOS\/Android) 개발 프레임워크를 성능, 안정성, 개발 편의성 등을 기준으로 비교한 벤치마크 분석입니다. 동일한 플래시카드 생성 앱을 세 프레임워크로 제작하여 실험했고, 실 기기에서 반복 수행해 객관적 데이터를 수집했습니다. 주요 내용을 요약하면 다음과 같습니다.\n\n성능 비교:\n- 프레임 부드러움: Flutter는 60\/120Hz에서 가장 여유롭게 작동하며, 네이티브 안드로이드도 높은 성능을 유지. React Native는 안정적이지만 프레임 드랍이나 메모리 증가가 존재.\n- 시작 시간(TTFF): Flutter가 가장 빠르고, 네이티브도 빠름. React Native는 다소 느리지만 안정적.\n- 메모리 사용: 네이티브가 가장 적게 사용, Flutter는 적당, React Native는 증가하는 경향.\n- 안정성: 프레임 안정도는 대체로 일정하지만, 바쁜 순간에 프레임 데드라인을 지키는 것 대처가 과제.\n- 앱 크기: 네이티브는 가장 작으며, Flutter는 중간, React Native(Expo 포함)는 가장 크고, 최적화 가능.\n- 빌드 시간: 네이티브가 가장 빠르고, Flutter는 느리지만 예측 가능, React Native는 중간.\n- 데이터 처리: Flutter와 네이티브는 ORM를 사용, React Native는 SQLite 직접 접근으로 경량화.\n\n개발 경험:\n- Flutter는 통합된 위젯으로 UI 제작이 용이하며, 커스터마이징 용이. Dart라는 친숙한 언어.\n- React Native는 빠른 학습 곡선과 생태계를 갖췄으며, Expo 통합으로 간편 개발 가능.\n- 네이티브는 플랫폼별 최적화를 통해 최고의 성능 제공, 그러나 개발이 복잡하고 노력 필요.\n\n벤치마크 방법:\n- 정교한 조건 조성, 동일 UI\/기능 수행, 반복 측정 통해 성능 평가.\n- 화면 스크롤, 시작 시간, 프레임 안정성, 메모리, 빌드시간 등 다수 지표 분석.\n- 실기기 환경에서 벤치마킹했고, OS별 차이를 고려해 정량적 수치 제시.\n\n주요 수치 결과:\n- Flutter는 저평균 프레임 시간, 낮은 드랍 및 지연율 기록, 가장 적은 전체 시스템 부담과 빠른 시작 시간.\n- React Native는 일부 지표에서 약간 뒤쳐지지만, 최신 파이프라인 활용 시 경쟁력 유지.\n- 네이티브는 가장 뛰어난 성능, 작은 앱 크기, 빠른 빌드\/시작 속도, 안정성을 보여줌.\n\n종합 의견:\n- 애니메이션 강조 또는 성능 안정성을 최우선시하는 경우 Flutter 추천.\n- 플랫폼 최적화, 작은 바이너리, native API 통합이 중요한 경우 네이티브 개발이 유리.\n- 빠른 개발과 배포, 웹 친화적 팀은 React Native 고려.\n- 성능 편차를 줄이기 위해 프레임 재설계와 최적화 방안을 함께 검토할 것.\n- 성능 평가는 평균보다 최악 사례(꼭짓점 지표)를 우선 고려하는 것이 사용자 경험 향상 핵심.\n\n각 프레임워크는 저마다 강점과 한계가 있으며, 제품 목표와 팀 역량, 필요 유지보수 지점에 따라 선택이 달라질 수 있습니다. 하지만 사용자 관점에서 중요한 것은 ‘최악의 순간도 안정적 유지’임을 기억해야 합니다.\n\n핵심 키워드:\n- Flutter, React Native, 네이티브 성능 비교\n- 프레임 안정성, 시작 시간, 메모리\n- 앱 크기, 빌드 속도, 데이터 처리\n- 사용자 경험 품질 우선\n- 적합한 프레임워크 선택 전략\n\n","title":"Flutter vs React Native vs Native: 2025 Benchmark Comparison | Build Better with SynergyBoat","comments":"오랜만에 2025년 기준으로 네이티브와 크로스 플랫폼을 비교한 글이네요. 제품 목표나 팀이 익숙한 역량 뿐만 아니라 유지보수할 부분까지 고려해야 합니다. 네이티브보다 모두 다 좋은 건 없으니까요"},{"location":"https:\/\/swiftui-garden.com\/Articles\/Handling-different-iOS-versions-in-a-View-body?","keywords":["SwiftUI"],"summary":"","title":"Handling different iOS versions in a View body | SwiftUI Garden","comments":"새로운 IOS 버전이 나오면 뷰와 관련된 내용도 추가되거나 바뀌기 때문에 버전에 따라 분기처리가 필요하죠. 특히 이번 iOS 26에서는 은근 변화가 있습니다"},{"location":"https:\/\/medium.com\/design-bootcamp\/how-do-computer-fonts-work-102b6c8ae16e","keywords":["Design","pick"],"summary":"이 글에서는 디지털 타이포그래피의 역사와 원리, 그리고 폰트가 우리 감정과 인지에 끼치는 영향을 깊이 탐구한다. 우리가 사용하는 폰트는 단순한 문자 모양이 아니라 수 세기에 걸친 예술적, 기술적 발전의 결과물이다. 처음 인류는 점토판이나 벽화에 그림 문자와 문자 형태를 새기며 문자와 형식을 발전시켰고, 고대 그리스와 로마 시대를 거치면서 섬세한 서체와 글자에 의미를 부여하는 기술을 고안했다. 이후 15세기 구텐베르크의 금속 활자 인쇄술 발명으로 ‘폰트’라는 개념이 탄생했고, 이는 오늘날 디지털 환경에서도 계속 발전하고 있다.\n\n현대에 와서 컴퓨터 폰트는 디지털 파일로 저장되며, 이들이 나타내는 문자 형상인 ‘글리프’를 기초로 한다. 초기에는 픽셀 단위로 정의된 비트맵 폰트가 있었으나, 확대와 축소에 한계가 있어 벡터 기반의 아웃라인 폰트(예: TrueType, PostScript)가 등장했다. 이 아웃라인 폰트는 곡선과 선으로 기술된 수학적 지시를 통해 어떤 크기에서도 깔끔하고 부드럽게 렌더링되도록 설계되어 있으며, 이를 위해 힌팅(hinting) 기술이 필요하다. 힌팅은 작은 크기에서도 글자들이 명확히 읽히도록 글리프의 특성을 미세하게 조정하는 기술이다.\n\n또한, 최근에는 디스플레이 환경의 변화에 따라 글씨의 선명도를 높이기 위한 서브픽셀 렌더링, 즉 LCD 화면의 RGB 하위픽셀을 이용한 방법이 개발되어, 글자의 선명도와 가독성을 크게 향상시켰다. 이와 함께, 폰트 과학은 단순한 기술적 요소를 넘어서 인간의 심리와 감정을 자극하는 도구로 재조명되고 있으며, 폰트 선택이 신뢰도와 이해도를 높여주는 중요한 역할을 한다. 최근에는 가변 폰트(variable fonts)라는 혁신적 기술이 도입되어, 한 폰트 파일이 다양한 두께, 너비, 기울기 등 연속적인 스타일 변화를 지원하며, 웹과 모바일 환경의 반응형 설계에 활용되고 있다.\n\n궁극적으로, 폰트는 예술과 과학, 그리고 심리학이 융합된 결과물로서, 기술적 정밀성과 인간의 감성적 요구를 동시에 충족시키는 복합체이다. 디지털 타이포그래피의 발전은 우리가 글자를 통해 감정을 전달하고, 메시지를 설계하는 방식을 혁신적으로 변화시키고 있다. 이러한 기술적, 예술적 노력이 결합됨으로써, 우리는 더 나은 가독성과 더 깊은 감정적 연결을 경험하게 된다.\n\n핵심 키워드: 디지털 타이포그래피, 아웃라인 폰트, 힌팅, 서브픽셀 렌더링, 가변 폰트","title":"How do computer fonts work?. Why fonts make us feel before we think | by Kartscrut ","comments":"디지털 타이포그래피의 역사와 원리, 글꼴을 볼 때 우리가 느끼는 감정과 인지에 대한 영향까지 설명하는 글입니다. 추천드려요"},{"location":"https:\/\/swift-pal.com\/i-spent-5-years-debugging-swift-apps-wrong-heres-what-i-wish-i-knew-day-one-0965f9294ab3","keywords":["DeveloperTools"],"summary":"이 글은 iOS 개발자 Karan Pal이 자신의 5년간 Swift와 Xcode를 활용한 디버깅 경험을 바탕으로, 효과적인 디버깅 방법과 도구들을 소개하는 내용입니다. 그는 초기에는 단순히 print()문을 남발하며 디버깅했지만, 이 방식이 비효율적이고 관리 어렵다는 것을 깨닫고, 보다 체계적이고 강력한 디버깅 기술을 습득하는 것이 중요하다고 강조합니다.\n\n과거의 잘못된 디버깅 습관, 예를 들어 print문 남용, 임시 주석 처리, 하드코딩된 값 등은 개발 속도와 품질을 떨어뜨리는 원인임을 지적합니다. 이후, 그는 Xcode의 고급 디버깅 기능들을 소개합니다. 조건부 브레이크포인트, 액션 브레이크포인트, 상징적 브레이크포인트 등은 문제를 정확한 위치에서 빠르게 잡아내는 데 유용하며, LLDB 명령어를 활용하여 앱 내부 상태를 실시간으로 변경하거나 탐색할 수 있다고 설명합니다.\n\nView Debugger를 통한 UI 구조 분석, 커스텀 디버그 문자열, 애플의 통합 로그 시스템, Instruments를 통한 성능 분석 방법도 상세하게 다루며, 특히 프로덕션 환경에서의 디버깅과 로깅 전략도 중요하게 언급합니다. #if DEBUG 조건문을 활용하여 디버깅 코드를 배포 버전에서 제외하는 방법, 원격 로깅 등을 통해 문제를 체계적으로 해결하는 사례도 포함됩니다.\n\n그의 디버깅 프로세스 변화와 현대적 워크플로우를 제시하면서, 적절한 도구와 습관을 통해 디버깅이 단순한 버그 수정이 아니라 코드 이해와 앱 안정성을 높이는 중요한 과정임을 강조합니다. 이를 통해 개발자는 더 빠르고 신뢰성 높은 앱을 만들 수 있으며, 개발 과정도 훨씬 즐거워질 것이라고 조언합니다.\n\n최신 Xcode 기능 활용, 체계적인 디버깅 전략, 성능 도구 활용, production 환경에서의 안전한 로깅, 그리고 디버깅 습관 개선이 핵심 메시지입니다.\n\n키워드: 디버깅, Xcode, 조건부 브레이크포인트, LLDB, 성능 분석","title":"I Spent 5 Years Debugging Swift Apps Wrong — Here’s What I Wish I Knew Day One | by Karan Pal ","comments":"요즘 여기 사이트 글이 자주 눈에 띄네요. 하면 나쁜 습관이 있는지 않은지 다양한 디버깅 방식을 구경하는 정도로 살펴보세요. "},{"location":"https:\/\/medium.com\/@maatheusgois\/inject-everything-services-and-viewmodels-in-swiftui-44aff4762a9e","keywords":["Architecture","SwiftUI"],"summary":"이 글은 SwiftUI에서 의존성 주입(DI)을 구현하는 실용적인 방법을 설명하며, 프로토콜, 환경키(Environment Keys), 작은 DI 컨테이너를 활용하여 모듈화되고 테스트 가능한 앱을 만드는 방법을 다루고 있습니다. 핵심 아이디어는 뷰(View)가 서비스 인스턴스를 직접 생성하지 않고, 대신 최상위에서 DI 컨테이너와 환경키를 통해 의존성을 주입받아 사용함으로써, 깔끔하고 유연한 구조를 만드는 것에 초점이 맞춰져 있습니다.\n\n주요 내용은 다음과 같습니다:\n\n1. **DI의 장점**: 뷰와 뷰모델이 서비스 구현체에 의존하지 않게 되어 테스트와 유지보수가 용이하며, 환경별(디버그, 릴리즈, 테스트)로 유연하게 서비스 구현을 교체할 수 있습니다. 이를 통해 글로벌 싱글톤 사용 문제를 피하고, 네트워크, 디스크, 키체인 등 부작용을 안정적으로 분리할 수 있습니다.\n\n2. **간단한 DI 컨테이너 구축**: 문자열 키를 사용하는 매우 가벼운 싱글톤 컨테이너로, 서비스 구현체 또는 프로토콜 등록이 가능하며, 앱 시작이나 테스트 시 용이하게 사용할 수 있습니다. 단, 문자열 키 대신 타입이나 ObjectIdentifier를 활용하는 것이 더 안전합니다.\n\n3. **환경키 활용**: SwiftUI의 `EnvironmentKey`와 `enviroment()` 수정자를 통해, 서비스 인스턴스를 뷰 계층 전체에 쉽게 주입하고 공유할 수 있습니다. 예를 들어, `UserService`를 환경에 등록하고, 하위 뷰는 `@Environment`로 읽어 사용할 수 있게 됩니다. 이는 서비스 재구성이나 특성별 변경이 용이합니다.\n\n4. **프로토콜과 서비스 구현**: 서비스는 작은 프로토콜로 설계하며, 실제와 목(Mock) 구현을 별도로 만들어 제공할 수 있습니다. 이를 통해 테스트 시 특정 행동을 모방할 수 있고, 네트워크 호출이나 영구 저장 등 부작용이 포함된 서비스를 손쉽게 모킹할 수 있습니다.\n\n5. **뷰모델의 의존성 주입**: `ViewModel`은 서비스 프로토콜을 초기화 매개변수로 받고, 필요시 컨테이너에서 resolve하여 주입받거나, `Environment`를 통해서도 주입할 수 있습니다. 이렇게 하면, 테스트 시 목 버전으로 쉽게 교체 가능하며, 비즈니스 로직은 깔끔하게 분리됩니다.\n\n6. **실제 예제**: `UserViewModel`이 `UserServiceProtocol`을 의존하며, 버튼 클릭 시 데이터를 로드하는 흐름과, `ContentView`에서 환경 키를 통해 서비스 읽기, UI에서 발생하는 호출 등을 구체적으로 설명합니다. 또한, 목 Mock 서비스와 실제 서비스 간의 전환도 용이하게 설계되어 있습니다.\n\n7. **장점과 실무 활용**: 스몰 컨테이너와 환경키을 적절히 활용하면 SwiftUI 앱의 대부분 요구 사항을 충족시킬 수 있으며, 의존성 주입을 통해 테스트 용이성, 유지보수성, 유연성을 크게 향상시킬 수 있습니다. 특히 네비게이션이나 딥 링크 처리, 상태 복원에서도 유리하다고 설명합니다.\n\n이 글은 SwiftUI에서 의존성 주입을 도입하여, 코드의 결합도를 낮추고, 테스트와 환경별 구성을 용이하게 하며, 앱의 구조를 더 깔끔하고 확장 가능하게 만드는 실용적 방법론을 제시합니다. \n\n---\n\n키포인트 키워드:  \n- SwiftUI 의존성 주입  \n- DI 컨테이너  \n- Environment Keys  \n- 프로토콜 기반 서비스  \n- ViewModel 테스트","title":"Inject Everything: Services and ViewModels in SwiftUI | by Gois ","comments":"SwiftUI에서 의존성 주입을 도입하여, 코드의 결합도를 낮추고 테스트와 환경별 구성을 용이하게 앱의 구조를 더 깔끔하고 확장 가능하게 만드는 실용적 방법들을 소개합니다"},{"location":"https:\/\/www.scottberrevoets.com\/2025\/08\/20\/managing-code-deprecations-on-ios\/?","keywords":["Swift","영어"],"summary":"","title":"Managing code deprecations on iOS - Scott Berrevoets","comments":"새 버전이 나오면 새로운 기능이 생기기도 하지만 반대로 사라지기도 합니다. 코드 버전관리가 필요할 때 필요한 내용들을 포함하고 있습니다"},{"location":"https:\/\/medium.com\/bricksnbrackets\/maybe-the-iphone-air-does-make-sense-after-all-955000edbf04","keywords":["Hardware"],"summary":"","title":"Maybe The iPhone Air Does Make Sense After All | by Attila Vágó ","comments":"애플 이벤트 리뷰 글 중에서 가장 무난한 것 같습니다. 카메라 섬에 모든 회로를 몰빵한 아이폰 에어에 납득이 되셨나요?"},{"location":"https:\/\/www.swiftjectivec.com\/open-intent-additions-ios26-in-appintents\/?","keywords":["Framework","영어"],"summary":"","title":"Open Intent in iOS 26 | Swiftjective-C","comments":"바뀐 OpenIntent 를 적용하는 방식입니다"},{"location":"https:\/\/blog.stackademic.com\/raw-identifiers-in-swift-6-2-func-this-is-a-raw-function-1d00b0abb161","keywords":["Swift"],"summary":"","title":"Raw Identifiers in Swift 6.2 | by Mobile App Developer ","comments":"스위프트 6.2 소소하게 변경이 꽤 있네요. 함수 이름에 공백 넣는거 꼭 필요할까요 ㅎㅎ "},{"location":"https:\/\/medium.com\/@hiren6997\/swift-6-the-features-that-will-redefine-ios-development-3978fa7c3100","keywords":["Swift"],"summary":"Swift 6는 iOS 개발에 혁신적인 변화를 가져오는 중요한 업그레이드입니다. 이번 버전은 안전성, 성능, 개발자의 생산성을 동시에 향상시키는 다양한 기능을 포함하고 있으며, 특히 다음과 같은 핵심 포인트들이 주목받고 있습니다.\n\n첫째, \"데이타 레이스 안전성\"이 눈에 띄는 주요 기능입니다. Swift 6는 컴파일 시점에서 경쟁 조건을 검사하여 예상치 못한 크래시를 미연에 방지하는 안전성 검사를 도입했습니다. 이전에는 스레드 문제로 인한 크래시가 흔했지만, 이제는 안전한 코드 작성이 훨씬 수월해졌습니다. 예를 들어, @MainActor와 함께 쓰면 UI 업데이트가 항상 메인 스레드에서 이루어지도록 강제하여, UI 관련 버그를 크게 줄일 수 있습니다.\n\n둘째, \"Typed Throws\"는 오류처리 방식을 개선하여, 어떤 오류가 발생할지 명확히 정해진 경우에만 throw 할 수 있게 함으로써 예외 처리 과정에서의 실수를 방지하고, 자동완성과 검증 기능을 강화했습니다. 이는 오류처리의 신뢰도를 높이고, 버그를 줄이는 데 도움을 줍니다.\n\n셋째, \"패킷 반복\"개념을 활용한 제네릭 함수가 크게 발전했습니다. Swift 6는 가변 개수의 파라미터를 하나의 함수로 처리할 수 있게 하여, 여러 Overload를 대체하고, 더욱 간결하고 유연한 코드 작성을 가능하게 했습니다.\n\n넷째, \"동시성(concurrency)\" 관련 기능이 강화되었습니다. @MainActor의 엄격한 적용으로 UI 작업이 항상 적절한 스레드에서 처리되도록 하며, 비동기 코드 작성 시 발생할 수 있는 실수를 줄였습니다. 이로 인해 앱의 안정성과 효율성이 크게 향상됩니다.\n\n마지막으로, Swift 6는 성능 향상과 더불어 크로스 플랫폼 지원, 고정밀 계산 지원, 임베디드 환경용 Swift, C++ 인터옵러빌리티 등 다양한 개발 환경에 맞춘 기능도 강화되었습니다. 이러한 변화는 iOS뿐만 아니라 다양한 플랫폼에서 Swift의 미래를 견고하게 만듭니다.\n\n이전 버전에서 시작된 마이그레이션은 점진적이고 신중하게 진행하는 것이 권장되며, 새로운 기능들을 활용하여 개발 효율성을 극대화할 수 있습니다. 이번 업데이트는 안전성과 성능, 생산성을 모두 향상시켜, Swift가 시스템 프로그래밍 언어 수준으로 성장하는 계기가 될 것입니다.\n\n요약 키워드: 데이터 레이스 안전성, typed throws, 패킷 반복, 동시성 막강 강화, 크로스 플랫폼 지원","title":"Swift 6: The Features That Will Redefine iOS Development | Medium","comments":"스위프트 6로 마이그레이션 하고 계신가요? 크래시가 발생할 가능성을 줄이는 코드 스타일 적용할 때가 된 것 같습니다"},{"location":"https:\/\/useyourloaf.com\/blog\/swift-default-value-in-string-interpolations\/?","keywords":["Swift","영어"],"summary":"","title":"Swift Default Value in String Interpolations","comments":"디폴트 값 지정하는 방식이 명확해졌네요"},{"location":"https:\/\/swift-pal.com\/swift-enums-in-2025-associated-values-pattern-matching-advanced-techniques-every-ios-developer-90a2b6e3f97c","keywords":["Swift"],"summary":"","title":"Swift Enums in 2025: Associated Values, Pattern Matching & Advanced Techniques EVERY IOS DEVELOPER SHOULD MASTER | by Karan Pal ","comments":"enum 얼마나 복잡하게 사용해보셨나요. 다양한 확장 문법들 제대로 잘 쓰면 구조체 + 클래스만큼 좋습니다"},{"location":"https:\/\/medium.com\/@karan.pal\/swift-type-aliases-the-secret-weapon-senior-developers-use-for-cleaner-code-c3c098093101","keywords":["Swift"],"summary":"","title":"Swift Type Aliases: The Secret Weapon Senior Developers Use for Cleaner Code | by Karan Pal ","comments":"새로운 타입이 필요할 때 타입 앨리어스가 대안이 될 수 있을까요?"},{"location":"https:\/\/levelup.gitconnected.com\/swift-run-code-at-specific-time-runloop-vs-dispatchqueue-de134c19ca97","keywords":["Swift"],"summary":"이 글은 Swift에서 특정 시간에 코드를 실행하는 두 가지 방법인 RunLoop + Timer와 DispatchQueue를 비교하고 설명합니다. 주로 이벤트 기반 작업 예약과 반복성, 그리고 취소 방법에 초점을 맞추어 다루고 있습니다.\n\n먼저, DispatchQueue의 asyncAfter(deadline:execute:)는 간단하게 일정 시간 후에 실행하기 편리하며, 즉시 실행이 가능하나 반복 예약(recurrence)에는 적합하지 않습니다. 반면, RunLoop와 Timer는 특정 시간에 작업을 예약하고 실행하며, 반복 기능(repeats)을 통해 주기적인 작업을 쉽게 구성할 수 있습니다. 하지만, Timer는 이전 타이머를 제거하지 않으면, 반복 시 배경에서 여러 타이머가 쌓여 문제가 발생할 수 있는데, 이를 해결하려면 Timer 객체를 저장해서 필요할 때 invalidate()로 중단할 수 있어야 합니다.\n\n예제 코드를 통해, 두 방식을 실제로 사용했을 때 List UI에 색상 변경이 어떻게 반영되는지 보여줍니다. 또한, 반복 예약과 무한 루프 방지 문제, 즉 재귀적 호출 시 기존 타이머를 무시하지 않으면 여러 타이머가 동시에 작동하는 문제를 설명하며, RunLoop Timer는 invalidate()을 사용해 이전 타이머를 끌 수 있어 안전하게 반복을 제어할 수 있다고 설명합니다.\n\n결론적으로, 특정 시간에 코드를 실행하면서 타이머를 중단하거나 재설정이 중요한 경우에는 RunLoop + Timer 방식이 유리하다. DispatchQueue는 단일 작업 예약에는 적합하지만, 반복 예약이나 정교한 제어가 필요할 땐 RunLoop + Timer가 더 강력하다고 결론 내립니다. 마지막으로, runLoop Timer에 사용자 정보를 전달하는 방법과 이를 활용한 파라미터 전달 팁도 소개합니다.\n\n핵심 키워드:\n- RunLoop + Timer\n- DispatchQueue\n- 타이머 invalidation\n- 재귀 반복 제어\n- 특정 시점 실행","title":"Swift: Run Code At Specific Time. RunLoop vs DispatchQueue | by Itsuki ","comments":"이벤트 기반 작업을 예약하거나 반복하고 취소가 쉽게 특정 시간에 코드를 실행하도록 하려면 어떤 방법이 있을까 비교한 글입니다"},{"location":"https:\/\/ravi6997.medium.com\/swiftuis-new-layout-protocol-the-secret-to-creating-complex-high-performance-ui-353137f2e7cf","keywords":["SwiftUI"],"summary":"이 글은 SwiftUI의 새로운 Layout 프로토콜에 대한 소개와 그 활용법, 그리고 개발에 끼치는 영향을 설명합니다. 현재 iOS 개발자들은 복잡한 레이아웃을 구현하는데 많은 시간과 노력을 투자하며, 기존의 Stack이나 Grid 같은 표준 레이아웃이 한계에 부딪히고 있습니다. 이에 대해 Apple은 \"Layout\"이라는 혁신적 프로토콜을 공개했으며, 이를 통해 커스텀 레이아웃을 UIKit 수준의 성능으로 빠르게 제작할 수 있게 되었습니다. 이 프로토콜은 두 가지 핵심 기능으로 구성되어 있는데, 하나는 `sizeThatFits`로 레이아웃에 필요한 공간을 계산하고, 다른 하나는 `placeSubviews`로 각각의 서브뷰를 정확한 위치에 배치하는 역할을 합니다.\n\n핀터레스트 스타일의 육각형 혹은 타일형 Masonry 레이아웃을 쉽게 구현할 수 있으며, 기존보다 최대 40% 빠른 성능 향상을 기대할 수 있습니다. 이 프로토콜은 애니메이션과 캐시, 동적 타입과 접근성도 자연스럽게 지원하며, 다양한 SwiftUI 기능과 무리 없이 통합됩니다. 따라서 복잡한 레이아웃 문제를 해결하거나, 상호작용이 많은 UI를 설계하는 데 매우 유용합니다.\n\n이 프로토콜을 활용하여 개발자는 성능이 우수하고, 유지보수도 쉬운 사용자 인터페이스를 만들 수 있으며, 이를 통해 사용자 경험 향상과 애플리케이션 경쟁력을 높일 수 있습니다. 초보자는 표준 레이아웃부터 시작해 점차 커스텀 레이아웃을 설계하는 방식으로 발전시키는 것이 권장됩니다. 전반적으로 이 새로운 기능은 SwiftUI의 성숙과 발전을 보여주는 중요한 지표로 평가받고 있으며, iOS 18과 SwiftUI의 미래를 이끄는 핵심 기술로 자리 잡고 있습니다.\n\n**핵심 키워드**: Layout 프로토콜, 커스텀 레이아웃, 성능 향상, 동적 콘텐츠, SwiftUI의 발전","title":"SwiftUI Layout Protocol: Build High-Performance Custom Layouts in iOS 2025 | Medium","comments":"`Layout` 프로토콜로 필요한 공간을 계산하고 서브뷰를 원하는 위치에 지정하기 위한 좋은 방식이라고 설명합니다"},{"location":"https:\/\/medium.com\/@matgnt\/swiftui-redraw-system-in-depth-attributes-recomputation-diffing-and-observation-66b469fdcada","keywords":["SwiftUI","pick"],"summary":"이 글은 SwiftUI의 내부 동작 원리를 심도 있게 분석한 기술적 설명입니다. 2019년 등장한 SwiftUI는 기존 UIKit과 달리 UIView 등의 클래스 기반이 아닌 값 타입(Struct)을 사용하며, 프로토콜 지향 프로그래밍(POP)을 강화했습니다. 이로 인해 뷰는 매번 생성되고 소멸되는 구조인데, 그렇다고 상태 유지가 불가능한 것은 아니며, 이 점에서 @State와 같은 속성 래퍼의 역할이 중요해집니다.\n\n핵심 과정은 네 단계로 나뉩니다. 첫째, 의존성에 따라 속성의 무효화(invalidation)와 갱신(flagging), 둘째, body 재계산(recomputation), 셋째, 구조와 콘텐츠의 차이점(diffing), 넷째, 변경된 부분만을 효율적으로 다시 그리기(redraw)입니다. SwiftUI는 상태값의 변화가 일어났을 때 이를 감지하고, 어떤 뷰의 body를 재계산할지 결정합니다. body는 상태에 따라 업데이트된 데이터를 기반으로 새 구조를 만들어내며, 이 과정에서 사용하지 않는 상태는 무시됩니다. 따라서 불필요한 재계산을 피하는 것이 성능 최적화의 핵심입니다.\n\n상태 관리에서 @State는 뷰의 내부 상태를 관리하며, 참조 대상인 프로퍼티의 변경시 해당 뷰와 연결된 의존성 그래프를 통해 종속된 요소만 재계산합니다. 이때, 뷰의 식별아이디(ID)가 불변인 경우에 한해 상태 유지가 보장됩니다. 또, 뷰의 객체들이 컴파일러에 의해 비교될 때는 Equatable 프로토콜과 _isPOD() 함수에 의존하는데, 이 과정에서 특정 속성들이 변경되어도 전체 구조를 재계산하지 않도록 최적화됩니다. 이를 위해 SwiftUI는 .equatable()이나 EquatableView와 같은 방식을 이용할 수 있으며, 이를 통해 재계산을 최소화할 수 있습니다.\n\n또한, SwiftUI는 Combine 기반의 관찰(observation) 시스템이나, 최신 @Observable 마이크로를 통해 데이터 변경을 감지하지만, 이 역시 모든 종속 뷰를 무차별적으로 재계산하는 한계가 있었습니다. 최신 시스템인 @Observable는 KeyPath와는 달리 더욱 정밀한 의존성 추적이 가능해, 불필요한 재계산을 방지합니다.\n\n이외에도, SwiftUI는 내부적으로 diffing과 유사한 비교 알고리즘(Comparison)을 수행하여 화면 업데이트를 최적화합니다. 예를 들어, 리스트처럼 많은 항목이 있을 경우, 변화된 항목만 업데이트하는 방식으로 성능을 유지하며, 효과적인 디버깅 및 최적화를 위해 Instruments의 Effect Graph와 Core Animation Profiler를 적극 활용할 수 있습니다.\n\n요약하자면, SwiftUI는 값 타입 구조와 의존성 그래프, diffing, 그리고 데이터 관찰 시스템을 결합하여, 내부적으로 어떤 요소가 변경되었는지 파악하고 필요 최소한의 재계산 및 재그리기를 수행하는 효율적 구조를 갖추고 있습니다. 이러한 내부 작동 방식을 이해하면, 성능 최적화와 디버깅이 훨씬 수월해지며, 프레임워크의 ‘마법’이 아닌 원리 기반의 예측 가능한 시스템으로 활용할 수 있게 됩니다.\n\n키포인트 키워드: \n1. State Management (상태 관리)\n2. Body Recalculation 및 Diffing (재계산과 diffing)\n3. Dependency Graph (의존성 그래프)\n4. View Diffing & Optimization (뷰 차이 비교와 최적화)\n5. Observation System (관찰 시스템)","title":"SwiftUI Redraw System In Depth: Attributes, Recomputation, Diffing and Observation. | by Mathis Gaignet ","comments":"SwiftUI 뷰 빌더가 속성의 변화에 따라서 다시 렌더링하기 때문에 불필요한 재계산을 피하고 다시 그리는 부분을 최소화하기 위한 전략을 설명합니다"},{"location":"https:\/\/www.avanderlee.com\/swiftui\/toggle-switch-a-complete-guide\/?","keywords":["SwiftUI"],"summary":"","title":"SwiftUI Toggle: A Complete Guide - SwiftLee","comments":""},{"location":"https:\/\/troz.net\/post\/2025\/swiftui-webview\/","keywords":["SwiftUI","영어"],"summary":"","title":"SwiftUI WebView","comments":""},{"location":"https:\/\/github.com\/TaeJoongYoon\/SwiftWebSocketClient","keywords":["OpenSources"],"summary":"","title":"TaeJoongYoon\/SwiftWebSocketClient: A modern, easy-to-use WebSocket client for Swift","comments":"태중님께서 웹 소켓을 다루기 위해 오픈 소스를 공개하셨네요. URLSessionTask 기반과 Network.framework 를 선택할 수 있어서 더 좋은 것 같습니다"},{"location":"https:\/\/wezzard.com\/post\/2025\/08\/the-cupertino-ghost-in-the-machine-9ee3","keywords":["DeveloperTools"],"summary":"Xcode 26의 새 AI 어시스턴트는 강력하면서도 정책에 기반한 구조를 갖춘 시스템으로, 깊이 있는 Apple 개발 생태계와 긴밀하게 통합되어 있습니다. 이 AI는 사용자 요청에 대해 엄격한 플래너-이그제큐터(계획자-실행자) 모델을 활용하며, external prompt 텍스트 파일을 통해 행동 기준과 성격을 제어합니다. 그 결과, 높은 일관성과 신뢰성을 유지하며, Apple의 기술 스택(Swift, Objective-C, Swift Concurrency, Swift Testing)을 우선시하고, 사용자 코드 및 문서 검색, 파일 변경 등 명령을 엄격하게 지침화합니다.\n\n이 시스템은 tool-calling API를 통해 다양한 도구를 지원하는데, 검색, 파일 읽기\/수정, 새 파일 생성 등을 포함하며, 특히 'search_additional_documentation' 도구를 활용하여 최신 Apple 기술 정보를 업데이트합니다. 중요한 점은 이 AI가 사용자 파일 시스템에 대해 직접 접근하지 않고, sandboxed 환경 내에서 동작한다는 것. 이는 안전성과 제어권 확보를 위한 설계이며, 파일과 데이터는 tool을 이용해 단계별로 처리됩니다.\n\n개발자는 외부 prompts와 도구 공급자를 수정하거나 교체하여 AI의 행동이나 기능을 커스터마이징할 수 있는데, 이는 전체 프레임워크의 유연성과 확장성을 확보하는 방향입니다. 그러나, 이러한 수정은 코드 서명 우회 등 지원되지 않는 방법을 수반할 수 있어 안전성과 안정성에 유의해야 합니다.\n\n이 AI 어시스턴트는 Apple 주도 정책을 강하게 반영하며, Swift와 최신 Apple 기술을 적극적으로 권장하는 행동 규범을 갖추고, 대화 내용과 IDE 맥락을 지속적으로 주입하여 관련성을 유지합니다. 경쟁사와 달리, 구조화된 흐름과 엄격한 정책 적용으로 인해 개발의 통제권과 일관성을 유지하는 동시에, 사용자 맞춤형 수정도 가능하다는 점이 특징입니다.\n\n앞으로의 과제와 열린 질문은, 이 AI가 단순 생산성 도구를 넘어 Apple 생태계와의 정합성을 강화하며, 플랫폼 내부 정책을 강화하거나 확장성 등을 어떻게 조율할지에 관한 것입니다. 또한, IDE를 벗어난 워크플로우 연계와 사용자와의 상호작용 방식을 어떻게 발전시킬지도 관전 포인트입니다.\n\n---\n\n**핵심 키워드**:  \n1. 정책 기반 AI 시스템  \n2. 플래너-이그제큐터 아키텍처  \n3. 엄격한 프롬프트와 도구 제어  \n4. SDK 수정 및 확장 가능성  \n5. Apple 생태계 중심 디자인","title":"The Cupertino Ghost in the Machine: An Analysis of Xcode's New AI Assistant | Pieces of My Soul","comments":"Xcode 26에 포함된 코드 인텔리전스 써보셨나요. 앞으로 개발 환경의 단순 생산성을 넘어서 개발 과정 전반에 어떤 변화가 필요할까요. 상상해보건데 git 이나 배포 환경도 AI에 적합한 방식으로 변화가 필요하지 않을까요"},{"location":"https:\/\/blog.stackademic.com\/the-death-of-swift-or-the-birth-of-something-bigger-e4260d748a03","keywords":["Swift"],"summary":"이 글은 Swift 프로그래밍 언어에 대한 현재와 미래에 관한 깊은 분석이다. 많은 개발자들은 Swift의 발전이 느려지고, 업데이트가 적어지면서 언어의 종말을 의심하는 목소리를 내고 있지만, 사실 이는 오해이며 언어가 성숙기의 단계에 접어들고 있다는 점을 설명한다. Swift는 초기 빠른 성장과 많은 혁신을 거쳐 이제 안정성과 성숙성을 갖춘 상태로, 수년간 큰 변화와 업데이트를 통해 안정된 프레임워크와 생태계를 구축해왔다.\n\n과거에 비해 Swift의 미묘한 조용함은 언어의 핵심 기능보다 플랫폼 전략에 집중하면서 나타난 현상이다. Apple은 더 이상 언어 자체를 과시하기보다는 Swift를 기반으로 하는 UI 프레임워크(예: SwiftUI), 데이터 저장소(SwiftData), Vision Pro, 서버용 Swift 등 다양한 새로운 영역으로 확장시키고 있다. 이러한 변화는 Swift가 다양한 플랫폼과 기술에 점차 깊숙이 침투하며, 사실상 \"보이지 않는 곳에서\" 중요한 역할을 담당하는 것으로 볼 수 있다.\n\n또한, Swift는 Objective-C, Java, Python 등과 같이 시간이 지나도 사라지지 않고 계속해서 발전하는 언어들의 예에서 알 수 있듯, \"죽는 언어\"가 아니라 \"성숙한 언어\"로서의 단계로 진입했음을 강조한다. Swift는 향후에도 더 강력한 동시성, 성능 개선, 서버에서의 활용, WebAssembly 등 새로운 환경에 적응하며 지속 발전할 예정이다.\n\n마지막으로, 언어의 진화는 단순한 새 기능 추가가 아니라, 이미 전 분야에 걸쳐 치밀하게 자리 잡고 있으며, 조용히 함수형 프로그래밍, 서버 개발, AI 등에 활용되며 언어 자체보다 생태계와 플랫폼 확장에 더 집중하는 모습으로 변화하고 있음을 보여준다. 따라서, Swift는 사망하는 것이 아니라, 더 크고 넓은 영역으로 확장, 진화하는 과정임을 강조한다.\n\n**핵심 키워드:**  \n1. Swift 성숙기  \n2. 안정성과 확장성  \n3. 플랫폼 통합 및 확장  \n4. 조용한 진화  \n5. 미래 성장 가능","title":"The Death of Swift? Or the Birth of Something Bigger? | by Mobile App Developer ","comments":"스위프트 언어 발전이 느려지고 혁신이 사라지면서 죽어가느냐고 걱정하지만, 함수형이나 서버 개발, AI 활용까지 더 넓어지고 있다고 말합니다"},{"location":"https:\/\/medium.com\/@mega-blog\/the-hunt-for-our-1-ios-crash-d8ba6f46a19a","keywords":["Testing"],"summary":"이 글은 MEGA iOS 개발팀이 2024년부터 진행한 클라우드 드라이브 모듈 재구축 과정과 그 과정에서 겪은 iOS 크래시 문제 해결 이야기를 다루고 있습니다. 9년된 Objective-C와 Swift, 스토리보드, XIB가 혼합된 레거시 구조를 SwiftUI와 MVVM 아키텍처로 전환하는 데 성공했지만, 배포 후 예상치 못한 새 크래시가 발생하면서 문제 해결 여정이 시작되었습니다. 이 크래시는 iOS 18을 사용하는 사용자에서 주로 발생했고, 점차 전체 iOS 기기에서 급증하여 크래시 지표 순위 1위를 차지했습니다.\n\n초기 분석은 크래시 발생 위치가 불명확했고, 스택 트레이스와 Crashlytics 데이터를 통해 UIKit과 SwiftUI 사이의 상호작용 문제임이 드러났습니다. 특히, background thread에서 UIImageView같은 UI 요소를 수정하는 것과 관련된 문제로 추정했습니다. 여러 시도, 예를 들어 async 함수 검증, Main Thread Checker, Swift 6로의 언어 모드 변경, SwiftUI와 UIKit의 경계 문제를 점검했지만 문제는 계속 persisted.\n\n반복된 시도와 조사를 거쳐, WWDC 2025 세션에서 SwiftUI가 배경 스레드에서 일부 렌더링 최적화를 수행한다는 사실이 밝혀졌습니다. 이로써 UIKit 구성 요소들이 SwiftUI 렌더링 과정에서 잘못된 시점에 호출된 것이 문제임이 확실해졌고, 이 문제의 핵심은 UIKit 내부 UIButton이 UIImageView를 통해 이미지를 렌더링하는 구조였습니다.\n\n최종 해결책은 UIKit 버튼인 UIButtonWrapper를 SwiftUI와 별도로 분리하여, 이미지 렌더링을 SwiftUI로 옮기고 상호작용만 UIButton이 담당하게 한 것입니다. 이 변경 후 크래시가 완전히 사라졌으며, 안정성과 성능이 크게 향상되었습니다.\n\n이 경험을 통해 배운 핵심 교훈은 다음과 같습니다:\n1. 크래시의 원인은 단편적 추측이 아니라 깊게 파고들어야 함\n2. SwiftUI와 UIKit의 경계는 예기치 않은 문제가 많고 신중해야 함\n3. 정밀한Instrumentation과 로그 수집이 문제 해결에 필수적\n4. 코드 리뷰와 리팩토링은 유지보수성과 안정성을 높임\n5. 커뮤니티와 공식 문서 활용, 끈기와 협력이 성공 비결임\n\n이 사례는 개발 과정의 끈기, 협력, 꼼꼼한 문제 분석과 해결 전략의 중요성을 보여주며, MEGA의 안전하고 현대적인 iOS 앱 개발에 대한 노력을 잘 드러내고 있습니다.\n\n키워드: iOS 크래시, SwiftUI, UIKit, Background Rendering, 문제 해결","title":"The Hunt for Our #1 iOS Crash. Introduction | by MEGA ","comments":"아키텍처를 바꾸고 나서 원인 모를 크래시가 발생하고 원인을 밝혀서 해결하기까지 과정을 설명합니다. SwiftUI 와 UIKit 연결은 불확실한 영역이 존재하는군요"},{"location":"https:\/\/medium.com\/macoclock\/the-iphone-17-is-easily-the-best-iphone-for-most-people-3853f2b32e8e","keywords":["Hardware"],"summary":"","title":"The iPhone 17 is Easily the Best iPhone for Most People | by Michael Swengel ","comments":"기존 프로 모델에서만 제공하던 사양들이 이제 아이폰 17에서도 제공되고 가격이나 색상 등에서 선택지가 많은 일반 모델도 충분하다고 설명합니다"},{"location":"https:\/\/uxdesign.cc\/three-hours-of-vibe-design-01fb78349142","keywords":["Design"],"summary":"이 글은 디자이너이자 HBO 맥스 제품 디자인 부사장인 마이클 맥워터스가 AI 기반 프로토타이핑과 ‘바이브 디자인(vibe design)’ 방식을 활용하며 경험한 내용을 다루고 있습니다. 그는 기존 디자인 도구인 피그마(Figma)의 한계와, AI와 프로세스를 결합한 새로운 접근 방식에 대해 설명합니다. 핵심은 전통적인 설계는 시간과 노력이 많이 들지만, AI 도구와 바이브 디자인 기법을 활용하면 빠른 프로토타입 제작과 아이디어 검증이 가능하다는 점입니다. \n\n그는 먼저 문제 정의와 전략수립이 중요하다고 강조하며, 간단한 스케치와 명확한 브리프(지침)를 통해 아이디어를 구체화한다고 합니다. 이후 AI 도구를 활용해 아이디어를 빠르게 시각화하고, 반복적인 프롬프트 조정을 통해 인터랙션과 미세한 디테일까지 다듬는 과정을 비유적으로 ‘유화물감처럼’ 다루는 작업에 비유했습니다. 전통적 도구가 ‘픽셀 감옥’이라면, 이번 방법은 유화의 채색 과정처럼 유기적이고 유연하다고 평가하며, 이러한 모방과 반복이 창작과 실험의 자유로움을 가져온다고 하였습니다.\n\n글은 프로토타입 제작 시간과 피드백 과정을 소개하며, AI 프로토타이핑이 디자인에 혁신적 영향을 미치고 있음을 보여줍니다. 그러나 저자는 AI 도구의 사용이 디자이너의 사고력과 창의력을 대체하는 것이 아니라, 보조와 확장하는 역할임을 다시 한 번 강조합니다. 또한, AI와 전통적 설계를 병행하며, 특정 순간에는 빠른 실행, 다른 순간에는 신중한 개발이 필요하다고 명확하게 제시합니다.\n\n마지막으로, 그는 AI 도구가 “재료(material)”처럼 느껴지며, 이는 작업의 유기성과 우연성을 증진시켜 줍니다. 전체적으로, 이 글은 AI와 바이브 디자인을 활용한 프로토타이핑의 가능성과, 디자이너의 역량이 여전히 중요한 역할을 한다는 메시지를 전달하며, 앞으로도 전통적 기술과 신기술의 조화가 중요하다는 결론을 내립니다.\n\n**핵심 키워드:** AI 프로토타이핑, 바이브 디자인, 전략수립, 디자이너 역할, 창의력 보조","title":"Three hours of vibe design | by Michael McWatters ","comments":"디자이너이자 HBO 맥스 제품 디자인 부사장인 마이클 맥워터스가 AI 기반 프로토타이핑과 바이브 디자인 경험담을 공유합니다"},{"location":"https:\/\/tuist.dev\/blog\/2025\/08\/11\/tuist-ai-whitepaper","keywords":["AI\/ML"],"summary":"Tuist는 Apple 앱 개발의 혁신을 목표로 AI 기술을 적극 도입하고 있으며, 이를 통해 개발 과정의 속도와 효율성을 크게 향상시키고자 합니다. 이 백서에서는 AI를 활용한 다양한 개발 지원 방안을 소개하며, 기존 워크플로우와의 조화를 강조하고 있습니다.\n\nTuist는 ‘에이전트 기반 코딩’(agentic coding)에 초점을 맞춰, AI 에이전트가 SwiftUI 뷰 수정이나 네트워킹 재구성 등의 작업을 실시간 피드백으로 수행하도록 합니다. 이를 위해 빠른 빌드 시스템과 바이너리 캐싱, 진보된 빌드 인사이트 시스템을 구축하며, 애플리케이션 빌드 및 처리를 극대화하기 위한 인프라 마련에 힘쓰고 있습니다. 이는 개발자가 즉각적이고 신속한 피드백을 받으며 반복할 수 있게 하는 핵심 기반입니다.\n\n또한, Tuist는 자동화된 QA(품질보증) 시스템인 Tuist QA를 개발하여, 수동 테스트의 한계와 비용 문제를 해결하려고 합니다. AI 에이전트는 PR(풀 리퀘스트) 검토 후 자동으로 테스트 환경을 구축하고, 사용자 관점의 테스트를 수행하며 상세한 분석 보고서를 제공합니다. 이 방식은 코드 변경 후 몇 분 만에 종합적 피드백을 가능하게 하여, QA 비용 절감과 품질 향상에 기여할 수 있습니다.\n\n즉석 미리보기(Instant previews) 기능도 중요한 부분입니다. 현재 애플의 서명 정책으로 인해 미리보기 공개가 어렵지만, Tuist는 설치 시 서명 방식을 활용하여 실시간 공유를 가능하게 하는 방식을 도입했습니다. 이를 통해 개발자는 빠르게 피드백 받고, 팀원이나 고객과 즉시 공유할 수 있도록 합니다.\n\n데이터 접근성 측면에서 Tuist는 애플의 폐쇄적 생태계의 한계를 극복하는 데 집중합니다. 빌드 로그, 테스트 결과, 런타임 행동 등을 구조화된 형태로 파싱하고, 이 데이터를 AI 에이전트가 적극 활용할 수 있도록 지원합니다. 이를 통해, 빌드 병목, 플러키 테스트, 성능 문제 등을 빠르게 분석하고 최적화할 수 있습니다.\n\n이와 함께, 아이디어 단계에서부터 프로토타입 완성까지의 과정을 단축하는 ‘Ignite’ 프로젝트도 추진됩니다. 이는 번거로운 환경설정 없이 바로 개발을 시작하고, 실시간 미리보기를 통해 검증하는 솔루션으로, 원격 또는 이동 중 개발자들의 생산성을 높이기 위한 시도입니다.\n\n전반적으로 Tuist는 Apple 개발 생태계의 내부 구조를 이해하고, 그 한계 내에서 AI와 자동화 도구를 활용한 맞춤형 솔루션을 제공하는 데 강점을 보입니다. 앞으로도 커뮤니티와 협력하여 개발 속도, 품질, 즐거움을 높이는 방향으로 발걸음을 계속할 예정입니다.\n\n핵심 키워드\n1. AI 에이전트 및 실시간 피드백\n2. 빠른 빌드와 바이너리 캐싱\n3. AI 기반 QA 자동화\n4. 즉석 미리보기와 신속 공유\n5. 데이터 접근성 및 생태계 혁신\n\n(총 글자수: 약 1,970자)","title":"Tuist's AI whitepaper","comments":"Tuist 가 개발 과정에서 AI 에이전트 기반 코딩과 자동화된 QA를 만들기도 하면서 애플 생태계 내부에 적합한 맞춤형 솔루션을 제공하려고 노력중이라는 백서를 발행했네요"},{"location":"https:\/\/fatbobman.com\/en\/posts\/mainactor-assumeisolated\/?","keywords":["Swift","영어"],"summary":"이 기사에서는 Swift 6에서 레거시 API와의 호환성 문제를 해결하기 위한 효과적인 방법으로 MainActor.assumeIsolated 사용을 소개합니다. Swift는 강력한 동시성 체크 기능을 제공하지만, 아직 일부 애플 공식 API는 이에 완전히 적응하지 않아 호환성 문제가 발생하고 있습니다. 특히, UIKit이나 SwiftUI와 같은 UI 관련 클래스는 MainActor 내에서만 안전하게 사용할 수 있는데, 이를 배경으로 하는 레거시 API와 SwiftUI 뷰를 결합하는 과정에서 충돌이 발생했습니다.\n\n기존 방식인 `@MainActor` 어노테이션이나 `Task` 래핑 방법은 Swift 6 컴파일러의 요구 사항을 만족시키지 못했고, 특히 UIHostingController를 생성하는 부분에서 더 큰 제약이 있었습니다. 이 때문에 개발자들은 `MainActor.assumeIsolated`라는 API를 활용하는 방식을 고안했습니다. 이 API는 동기적 컨텍스트에서만 사용할 수 있으며, 현재 컨텍스트가 MainActor가 아닐 경우 앱이 바로 크래시됩니다. 이를 통해 일시적으로 MainActor 환경을 만들어 안전하게 UI 관련 작업을 수행할 수 있습니다.\n\n구체적으로, `loadView()` 메서드 내부에서 `MainActor.assumeIsolated`를 호출하여 MainActor 맥락을 확보하고, 이를 이용해 `UIHostingController`를 안전하게 생성하며, 결국 `self.view`를 설정하는 방식입니다. 추가로, `getView()`라는 별도 함수에서 현재 스레드가 메인인지 판단하여 메인 스레드가 아닐 경우 `DispatchQueue.main.asyncAndWait`을 이용하는 방법도 설명됩니다. 이 방식은 레거시 API와 최신 Swift 동시성 기능을 조화롭게 사용하는 현실적 방안입니다.\n\n이 기술은 완벽한 우아함은 다소 떨어져 보일 수 있지만, 레거시 코드와의 호환성 문제를 해결하면서 Swift 6의 엄격한 컴파일 요구 사항에 부합하는 실용적 해결책임을 강조하고 있습니다. 저자는 결국 이와 같은 복잡한 방법이 앞으로 많은 공식 및 타사 프레임워크의 Swift 6 이행이 완료됨에 따라 더 간단하고 직관적인 방식을 기대하며, 현재로서는 이러한 혼란스러운 상황 속에서 유용한 방법임을 설명합니다.\n\n요약하자면 주요 핵심 포인트는:\n- Swift 6의 엄격한 동시성 검사와 레거시 API 간 충돌 문제\n- `MainActor.assumeIsolated`를 통한 동기적 컨텍스트 내 안전한 MainActor 환경 조성\n- `loadView()` 내에서 MainActor 맥락 유지 방법\n- 레거시와 최신 API 결합의 실용적 해결책\n- 향후 프레임워크의 Swift 6 마이그레이션 완료 기대\n\n키워드: Swift 6, MainActor.assumeIsolated, 레거시 API, 동기적 컨텍스트, SwiftUI 호환성","title":"Using MainActor.assumeIsolated to Solve Legacy API Compatibility Issues with Swift 6","comments":"`MainActor.assumeIsolated()` 가 호출되면서 MainActor 맥락에서 안전하게 처리하도록 레거시 코드를 마이그레이션하는 방식을 설명설명합니다"},{"location":"https:\/\/www.donnywals.com\/what-is-approachable-concurrency-in-xcode-26\/","keywords":["DeveloperTools"],"summary":"Xcode 26은 Swift 6.2의 새로운 기능인 \"접근하기 쉬운 동시성(Approachable Concurrency)\"을 도입했으며, 이를 활성화하려면 프로젝트의 빌드 설정에서 “approachable concurrency” 옵션을 “Yes”로 변경하면 된다. 기본적으로 이 설정은 비활성화되어 있으며, Swift 버전과 프로젝트 생성 방식에 따라 다르게 표시될 수 있다. 특히 Swift 6.2를 사용하는 경우에는 대부분의 기능이 기본적으로 활성화되지만, Swift 5를 사용하는 경우에는 수동으로 설정해야 한다.\n\n접근하기 쉬운 동시성은 Swift의 동시성 프로그래밍을 보다 예측 가능하고 이해하기 쉽게 만들어주는 다양한 기능을 포함한다. 예를 들어, ‘nonisolated(nonsending)’는 비동기 함수의 실행 방식을 통일시켜서 호출자(actor)의 실행기에서 동일하게 동작하게 하며, ‘Infer Sendable’은 함수와 키 경로에서 Sendable 품질을 자동으로 추론하게 해준다. ‘Infer Isolated Conformances’는 타입의 프로토콜 준수 역시 글로벌 액터에 맞춰 자동으로 격리시켜주고, ‘Global Actor Isolated Types Usability’는 비-Sendable 상태라도 안전하게 전달될 수 있도록 지원한다.\n\n이 밖에도, ‘Disable Outward Actor Isolation Inference’는 SwiftUI에서 property wrapper의 actor 격리와 관련된 혼란스러운 동작을 개선하는 역할을 한다. 이러한 기능들은 Swift 6.2와 Swift 5(옵션으로 활성화) 모두에서 제공되며, 개발자는 프로젝트와 패키지가 사용하는 Swift 버전에 따라 적절히 설정할 필요가 있다.\n\n이 모든 기능은 Swift의 동시성 코드가 에러 없이 더 명확하고 안정적으로 동작하도록 돕고, 개발 생산성을 높여준다. 따라서 새로운 프로젝트에서는 접근하기 쉬운 동시성 기능을 활성화하는 것이 강력히 권장된다.\n\n**핵심 키워드:** 접근하기 쉬운 동시성, Xcode 26, Swift 6.2, 비동기 함수, 글로벌 액터","title":"What is Approachable Concurrency in Xcode 26? – Donny Wals","comments":"접근하기 쉬운 동시성 방식 지원 옵션처럼 개발 환경에서 언어 옵션에 따라 동시성 코드를 다룰 수 있도록 도와주는 내용을 설명합니다. 저도 설정을 바꾸고 테스트를 좀 해봐야겠네요"},{"location":"https:\/\/medium.com\/@danielasgharian\/why-i-left-the-apple-ecosystem-after-14-years-and-what-i-switched-to-6f5bd276052e","keywords":["Culture","영어"],"summary":"이 글은 14년간 애플 생태계를 사용해온 저자가 갑자기 안드로이드로 전환한 경험과 그 이유를 상세히 서술한 이야기입니다. 저자는 원래 아이폰, 애플 워치, 에어팟, 아이패드, 매직 마우스 등 애플 제품에 깊이 몰두한 애플 팬이었다. 그러나 애플이 오랜 기간 비슷한 디자인과 기능으로 정체된 점, 과도한 가격, 사용자 선택권의 부족에 실망하며 변화의 필요성을 느끼게 된다. 특히, 애플이 제공하는 고성능의 기기들이 자신에게는 과잉이었고, 더 다양한 선택권과 혁신적인 기능을 원했다고 말한다.\n\n그는 결국 비용과 지속가능성, 커스터마이징이 가능한 점을 고려해 페어폰(공정성과 수리 용이성을 중시하는 브랜드)을 선택했고, 저가의 무선이어버드로 노팅 Ear (a)를, 그리고 소니의 B&W PX7 S2e 헤드폰을 선택하며 새 기술 환경에 적응하기 시작한다. 기존의 맥과 아이패드는 그대로 유지하되, 맥북 에어(M2)는 앞으로 더 나은 대안을 찾을 계획이다. 구형 애플 생태계에서 벗어난 후 느낀 점은, 오픈된 시스템으로의 전환이 초기에는 쉽지 않았지만, 전반적으로 만족스럽고 앞으로도 계속 조정하며 사용해 나갈 것이라고 전한다.\n\n전환 과정에서 느낀 어려움과 비용, 더 많은 선택권에 대한 기대, 그리고 긴 시간 동안 사용할 수 있는 지속가능한 제품을 찾는 것이 핵심이다. 저자는 앞으로 몇 달 후의 사용 후기를 더 써서 변화 과정과 장기적인 성과를 소개할 예정이다. 이 이야기는 사용자에게 애플과 안드로이드 간 선택의 차이, 그리고 기술 소비에 있어 개별적 선호와 가치관이 중요한 이유를 보여준다.\n\n키포인트 키워드:  \n1. 애플 생태계 탈피  \n2. 안드로이드 전환 경험  \n3. 지속 가능성과 수리 용이성  \n4. 선택권과 혁신 요구  \n5. 기술 새 환경 적응","title":"Why I Left the Apple Ecosystem After 14 Years (And What I Switched To) | by Danielpourasgharian ","comments":"14년간 애플 생태계를 사용해온 저자가 갑자기 안드로이드로 전환한 경험과 그 이유를 설명하는 소소한 글입니다. 무엇을 선택하든 상관없지만 시스템과 환경이 좀 더 발전하려면 이런 사례도 많아져야 한다고 생각합니다"},{"location":"https:\/\/medium.com\/@sharma-deepak\/why-ill-never-use-swift-again-1c7fdc05ff36","keywords":["Culture"],"summary":"이 글은 Deepak Sharma가 자신이 iOS 앱 개발에 Swift와 Flutter를 각각 사용하면서 겪은 경험을 비교하는 내용입니다. 처음에는 Swift로 iOS 앱을 간단히 개발했지만, Android 및 여러 플랫폼으로 확장하려니 유지보수와 디버깅이 매우 복잡하고 힘들었다는 것을 깨달았습니다. Swift의 한계로 인해 긴 빌드 시간, 플랫폼별 코드 중복, UI 제약, 그리고 디버깅의 어려움 등 수많은 문제에 직면했고, 이것이 개발자를 지치게 만드는 원인임을 느꼈습니다.\n\n이에 반해, Flutter로 동일한 앱을 재구축하면서 체감상 엄청난 변화를 경험했습니다. Hot Reload 덕분에 즉각적인 수정과 반복이 가능했고, 하나의 코드로 iOS, Android, Web까지 동시에 지원할 수 있어 개발 속도가 비약적으로 증가했습니다. Flutter는 복잡한 UI, 애니메이션, 커스텀 패턴을 자유롭게 구현할 수 있어 창의적 개발에 적합하며, 디버깅도 쉽고 명확한 오류 메시지를 제공합니다. 이를 통해 생산성과 개발의 즐거움을 회복했다고 강조합니다.\n\n실제 두 환경을 8주간 비교한 결과, Flutter는 생산성이 높고 비용 면에서도 더 경제적이었으며, 전체 프로젝트 기간과 비용을 크게 절감하는 성과를 얻었습니다. Flutter는 결국 iOS, Android, Web 등 여러 플랫폼을 한 번에 지원하는 크로스플랫폼 프레임워크로서, 많은 개발 과제의 헤드아웃을 해결하는 강력한 도구임을 확인했다고 합니다.\n\n한편, 현재 Swift는 iOS 전용 또는 특정 네이티브 기능 연동에만 적합하며, Flutter는 빠른 개발, 높은 유연성, 광범위한 플랫폼 지원에 강한 도구로 자리 잡고 있습니다. 개발자에게 중요한 것은 긴 빌드 시간, 유지관리 복잡성 대신 빠른 피드백과 창의적 자유라고 결론지었습니다.\n\n키 포인트 키워드:  \n1. 크로스플랫폼 개발  \n2. Swift 한계와 문제점  \n3. Flutter의 강점과 효과  \n4. 개발 비용과 시간 절감  \n5. 크로스플랫폼 미래와 추천","title":"Why I’ll Never Use Swift Again: My Personal Experiment with Flutter for Cross-Platform Apps | Medium","comments":"iOS 앱 개발에 Swift와 Flutter를 각각 사용하면서 겪은 경험을 비교하는 글입니다. 플러터 기반이 생산성이 높은 상태로 유지할 수 있다면 좋은 선택일 수도 있겠네요"},{"location":"https:\/\/jeehut.medium.com\/why-im-not-using-xcode-26-s-ai-chat-integration-and-what-could-change-my-mind-02374d5a70e4","keywords":["DeveloperTools"],"summary":"이 글은 개발자 Cihat Gündüz가 Xcode 26의 AI 통합 기능이 아직 미흡하다고 느끼는 이유와, 향후 Apple이 이를 개선하기 위한 로드맵을 제시하는 내용입니다. 그는 AI 도구의 활용에 있어 신중한 태도를 유지하며, 세션 중 Cursor와 Claude Code와 대조하며 더 높은 생산성을 보여주는 경쟁 도구들을 언급합니다. 특히, Xcode의 AI 기능이 실현 가능성을 떨어뜨리는 7가지 핵심 부족 요소를 지적하는데, 이들은 요청 큐잉 미지원, 컨텍스트 엔지니어링 지원 미비, 빌드 검증 기능 부족, Git 연동 부재, 터미널\/CLI 접근 불가, 프로젝트 파일 접근성 문제, 웹 검색 및 문서 접속 미지원입니다. 이 문제점들은 Xcode가 현대 AI 기반 개발 워크플로우에 적합하지 않게 만든다고 평가하며, 결과적으로 그는 현재 Xcode 대신 Claude Code를 활용하는 방식을 택하고 있습니다.\n\n그는 또한 Apple이 2026년까지 이러한 결점을 보완하기 위한 5단계 로드맵을 제시합니다. 다음 버전들은 요청 큐잉과 컨텍스트 파일 지원, Git 및 빌드 도구와의 연계, 웹 검색과 문서 연동, 터미널 접근성 확대 등을 단계별로 도입할 예정입니다. 특히, 2026년 WWDC에서 제안된 ‘Xcode 27’은 시뮬레이터나 SwiftUI 미리보기, AI 기반 앱 빌드 기능 등 차별화된 기능을 선보이면서 경쟁우위를 확보할 수 있을 것으로 기대됩니다.\n\n결론적으로, 그는 아직 Xcode의 AI가 경쟁력 있다고 볼 수 없지만, Apple이 빠르게 개선한다면 다시 Xcode에 집중할 의향이 있으며, 개발자들은 이번 기회에 다른 도구와 함께 AI를 활용하는 비중을 늘리고 있다고 설명합니다. 앞으로 Apple의 적극적인 발전이 기대된다는 메시지입니다.\n\n키워드: Xcode AI, 기능 부족, 개발 효율성, 개선 로드맵, 경쟁 도구","title":"Why I’m Not Using Xcode 26’s AI Chat Integration (And What Could Change My Mind) | by Cihat Gündüz ","comments":"Xcode 26의 AI 통합 기능이 아직 미흡하다고 느끼는 이유와, 향후 Apple이 이를 개선하기 위한 로드맵을 제시합니다. 개발 환경의 더 많은 요소와 연결된다면 막강할 것 같네요"},{"location":"https:\/\/medium.com\/macoclock\/iphone-17-pro-photographers-dream-or-just-shiny-hype-9f97e5f16b82","keywords":["Hardware","영어"],"summary":"","title":"iPhone 17 Pro: Photographer’s Dream or Just Shiny Hype? | by Dori Kasa ","comments":"이제 상위 모델 휴대폰은 사진기와 경쟁해야 하는 운명일까요. 저도 점점 카메라보다 아이폰으로 찍는 사진이 많아지고 있습니다"},{"location":"https:\/\/uxdesign.cc\/data-driven-is-dead-fdd4c5746867","keywords":["Culture","영어"],"summary":"이 글은 경험 많은 인터랙션 디자이너이자 프로덕트 매니저인 카케히 타쿠마가 '데이터 기반 디자인'의 한계와 대안을 모색하는 내용을 담고 있습니다. 저자는 지난 10년간 디지털 제품 산업에서 데이터를 중심으로 한 설계 방식이 주류였음을 인정하면서도, 이 방식이 점차 한계에 다다르고 있다고 지적합니다. 데이터는 빠른 반복과 최적화에 강점이 있지만, 경험의 차별성, 창의성, 직관, 그리고 미묘한 판단이 요구되는 디자인의 본질과는 거리가 멀다고 분석합니다. 데이터는 과거 데이터를 반영하기 때문에 미래 지향적이거나 창의적인 솔루션을 제공하기 어렵고, 결국 표준화되고 기계적이며 경쟁력을 떨어뜨릴 위험이 크다고 봅니다.\n\n저자는 이러한 한계 속에서 \"창의적 모호성\"과 직관을 통한 설계의 중요성을 강조합니다. 과거의 성공 사례들을 들며, 직감과 감각이 중요한 역할을 한 대표적인 제품 사례들을 소개합니다. 예를 들어, 아이팟의 클릭 휠은 데이터가 아니라 디자이너의 감각에서 나온 아이디어였고, 다이슨의 클리어 진공청소기, 스냅챗의 일시성 메시지, 소니의 워크맨, 압솔루트 보드카의 광고 캠페인 등은 모두 명확한 데이터보다는 직관과 창의성을 통해 성공을 거둔 사례들입니다. 이들은 모두 기존의 규칙을 뛰어넘거나, 모호한 아이디어를 적극 활용하여 시장을 창조하거나, 인간의 감성에 호소함으로써 차별성을 만들어냈습니다.\n\n저자는 결론적으로, 디자이너들은 더 이상 데이터에만 의존하지 않고, 감정, 직감, 창의적 모호성을 포용하며, 이러한 노력이 더 혁신적이고 차별화된 결과를 이끌어낼 것이라고 기대합니다. 즉, 데이터는 유용하지만, 그보다 더 중요한 것은 인간적인 감성과 직관을 바탕으로 한 디자인이라는 메시지를 전달하며, ‘데이터 주도적’ 패러다임이 점차 시대에 뒤처지고 있음을 시사합니다.\n\n핵심키워드:\n1. 데이터 기반 디자인 한계\n2. 창의적 모호성\n3. 직관과 감성\n4. 차별화된 경험\n5. 혁신적 설계","title":"“Data-driven” is dead | by Takuma Kakehi ","comments":"경험 많은 인터랙션 디자이너이자 프로덕트 매니저인 카케히 타쿠마가 '데이터 기반 디자인'의 한계와 대안을 모색하는 내용을 담고 있습니다. 흥미로운 관점이네요"}],"releaseAt":777654000,"version":"1.0","sequence":134}