{"sequence":137,"releaseAt":781887600,"version":"1.0","items":[{"keywords":["SwiftUI"],"title":"5 TabBar SwiftUI Styles You Can Use | by Jerry PM ","comments":"저는 클래식한(?) UIKit 스타일 탭바에 더 익숙하지만 커스텀 탭바를 만들어야 하는 경우를 상상하면 필요해보입니다 (제발 🙏)","summary":"","location":"https:\/\/blog.stackademic.com\/5-tabbar-swiftui-styles-you-can-use-3195423bf98c"},{"keywords":["SwiftUI"],"title":"7 Swift 6.2 Performance Tricks That Made My iOS App 3x Faster | Medium Ravi","comments":"사소한 결정과 구현이 앱을 느리게 만들기도 합니다. 데이터 타입, 액터 모델과 오버헤드, 지연 로딩, 컬랙션 선택과 순환 참조 방지 등 몇 가지 점검할 사항을 제시합니다","summary":"2025년 iOS 개발자가 알아야 할 성능 최적화 전략과 Swift 6.2 업데이트의 영향을 중심으로 한 기고문입니다. 저자는 5년 차 iOS 개발 경험을 바탕으로, 최신 Swift 6.2의 강력한 기능과 성능 향상 기법들을 소개하며, 이러한 방법들을 통해 앱의 성능을 3배 이상 향상시킬 수 있다고 강조합니다.\n\nSwift 6.2는 이전과 달리 경쟁 모델, 더 강력해진 컴파일러 최적화, 엄격한 메모리 관리 등을 내세우며 개발자에게 강력한 도구를 제공합니다. 그러나 많은 개발자가 여전히 2019년 버전의 관행을 고수하는데, 이는 오히려 성능 저하를 초래할 수 있다고 지적합니다.\n\n여기서 제시하는 핵심 성능 최적화 기술은 다음과 같습니다. \n\n1. 값 타입 사용: 구조체와 열거형 등 값 타입은 스택에 저장되어 빠른 할당과 메모리 해제가 가능하므로, 가벼운 객체에는 우선 사용하되, 무거운 데이터는 참조 타입을 활용하는 것이 좋습니다. \n2. Swift 6.2의 엄격한 동시성 모델 습득: `@Sendable`, `actor` 활용, 배치 작업 등을 통해 성능을 비약적으로 향상시키고, 오버헤드를 줄이도록 유도합니다.\n3. 지연 로딩(Lazy Loading): 복잡한 연산은 필요할 때 나중에 수행하도록 하여, 메인쓰레드 차단을 피하고 초기 로드 시간을 크게 단축할 수 있습니다.\n4. 컬렉션 선택: Array, Set, Dictionary, ContiguousArray 등 특성에 맞는 컬렉션 사용으로 검색 및 조작 속도를 최적화합니다.\n5. 강한 참조 순환 방지: async\/await 구조에서 `weak self` 사용, 메모리 그래프 디버거 활용 등으로 불필요한 메모리 사용과 누수 방지를 도모합니다.\n6. 컴파일러 최적화 플래그 활용: -O, Whole Module Optimization, Link-Time Optimization 등 다양한 최적화 옵션을 적극 사용할 필요가 있습니다.\n7. 데이터 기반 프로파일링: Xcode Instruments와 통합된 로그를 활용하여 병목 지점을 정확히 파악하고, 직관이 아닌 데이터에 기반한 최적화를 수행하는 것의 중요성을 강조합니다.\n\n저자는 이러한 최적화 패턴들을 미리 고민하고 설계 단계에 반영하는 것이 성능 향상과 출시 속도를 크게 높이는 핵심이라고 합니다. 성능 최적화는 단순 작업이 아니라 개발자의 사고방식이자 문화라고 강조하며, 독자가 행동에 옮기기를 권장합니다.\n\n핵심 키워드: 값 타입, 동시성, 지연 로딩, 컬렉션 최적화, 성능 프로파일링","location":"https:\/\/ravi6997.medium.com\/7-swift-6-2-performance-tricks-that-made-my-ios-app-3x-faster-992c80c36941"},{"keywords":["Hardware"],"title":"8 Apple Products You Might Regret Buying | Bouncin","comments":"애플 제품을 사고나서 후회한 적 있으신가요. 이 글에 있는 8개 중에 하나 정도는 갖고 계실수도 있습니다 🫣","summary":"","location":"https:\/\/medium.com\/bouncin-and-behavin-academy\/8-apple-products-people-regret-buying-and-why-761bc1883ae5"},{"keywords":["Swift","영어"],"title":"Alan Kantz-Durand’s Portfolio—Advanced Codable","comments":"Codable 프로토콜 만으로 데이터 타입을 다루기 어렵거나 귀찮거나 힘든 복잡한 구조를 다루는 방식을 설명합니다","summary":"이 글은 Swift의 Codable을 활용하는 고급 기법인 \"Advanced Codable\" 방식을 소개하며, 이를 통해 기존의 단점들을 극복하는 방법을 설명합니다. Codable은 JSON 등의 데이터 포맷과 Swift 타입 간의 변환을 쉽게 해주는 유용한 도구이지만, 구조가 서로 다른 데이터의 경우 수동 구현이나 복잡한 로직이 필요해 유지보수에 어려움이 발생할 수 있습니다. 특히, 데이터 구조와 모델 정의의 불일치나 optional 데이터 처리, 또는 구조적 변경 시 문제가 대표적입니다.\n\n이에 대한 해결책으로 \"No Drama\" 모델 방식을 채택하면, 구조가 직관적이고 데이터와 일대일 매칭되는 모델을 작성할 수 있지만, 이 방식은 모델이 단순히 데이터 저장 역할만 하고 비즈니스 로직이 없기 때문에, 관리와 확장이 어려워집니다. 또한 데이터 구조 변경 시 모델도 함께 수정해야 하는 밀접한 결합 문제도 존재합니다.\n\n이 문제를 해결하기 위해, 저자는 \"Data Transfer Objects (DTOs)\" 역할의 별도 Codable 객체를 활용하는 방법과, Swift의 강력한 타입 변환 기능을 이용하는 \"Advanced Decodable\"과 \"Advanced Encodable\" 프로토콜을 제안합니다. 이 프로토콜들은 DTO와 모델 간의 변환을 Decodable과 Encodable 내부에서 처리하게 하여, 구조적 복잡성을 낮추고 유지보수성을 높입니다. 즉, DTO는 단순한 JSON-직렬화용 객체로서, 이와 모델 간의 변환은 초기화 메서드 또는 메서드로 처리합니다.\n\n여기서 \"Advanced Decodable\"은 DTO를 Decodable로부터 자동으로 디코딩하고, 그 값을 토대로 비즈니스 로직이 포함된 모델 객체를 생성하는 데 초점을 맞춥니다. 마찬가지로, \"Advanced Encodable\"은 모델을 DTO로 변환한 후 Encodable 방식을 통해 쉽게 직렬화할 수 있게 도와줍니다.\n\n다양한 특수 케이스에 대응하는 헬퍼 타입들(Maybe, Either, Both)을 소개하는데, 이들은 특정 데이터 포맷의 예상치 못한 값 또는 다중 타입, 또는 복합 구조를 처리하는 데 유용하며, 복잡한 구조의 디코딩\/인코딩을 표준 Codable보다 훨씬 간단하게 만들어줍니다.\n\n이 방식을 도입하면, 깨끗하고, 유지보수와 확장 가능한 구조를 갖춘 코드를 작성할 수 있으며, 기존 Codable과 자연스럽게 결합됩니다. 궁극적으로, 이 기법들은 데이터 구조와 모델 간의 교체\/변경으로 인한 문제를 최소화하면서, 개발자가 비즈니스 로직에 집중할 수 있도록 돕는 강력한 도구입니다.\n\n핵심 키워드: Advanced Codable, Decodable, Encodable, DTO, 코드 유지보수","location":"https:\/\/nothingtocommitworkingtreeclean.com\/advanced_codable.html"},{"keywords":["AI\/ML","pick"],"title":"Apple Intelligence: A Developer’s Guide to Foundation Models API for On-Device AI | by Santosh Botre ","comments":"온디바이스 파운데이션 API 활용 방법을 상세하게 설명하는 글이라서 추천합니다. 세션 생성부터 프롬프트 관리, 가용성, 멀티 턴, 구조적 출력까지 내용도 알차네요","summary":"애플의 최신 AI 기술인 'Apple Intelligence'는 개발자에게 중요한 혁신으로, 개인 프라이버시와 성능 최적화에 초점을 맞춘 온-디바이스(장치 내) 언어 모델 API인 'Foundation Models API'를 제공합니다. 이 API는 Swift 애플리케이션에 강력하고 안전한 인공지능 기능을 손쉽게 통합할 수 있게 해줍니다.\n\n온-디바이스 AI의 핵심 강점은 데이터 보안(모든 처리 과정이 디바이스 내에서 이루어지며 데이터가 외부로 유출되지 않음), 낮은 지연 시간(즉시 반응 가능), 에너지 효율(Apple Silicon에 최적화), 오프라인 작동 가능성, 그리고 Swift와의 원활한 통합입니다. 이러한 구조는 사용자의 신뢰를 유지하면서도 지능형 기능을 구현하는데 적합합니다.\n\nAPI 활용은 간단한 텍스트 생성에서부터 복잡한 구조체 기반 데이터 출력, 실시간 스트리밍, 안전성 보장을 위한 가드레일, 다양한 언어 지원, 도구 호출, 맞춤형 조정 등 매우 폭넓게 가능하며, 다양한 특징별 기능들을 제공한다. 예를 들어, '세션 생성', '프롬프트 입력', '모델의 가용성 체크', '멀티 턴 지원', '생성 옵션 조정(온도, 지시사항)', '구조적 출력', '스트리밍 대응', '외부 도구 호출', '맞춤형 어댑터 훈련' 등이 핵심이다.\n\n구조적 생성은 Swift 구조체와 맵핑되어 파싱 오류를 방지하고 안정성을 높이며, 생성 컨트롤(온도, 지시문)과 안전성(가드레일, 제한된 입력·출력, 안전한 콘텐츠 필터링)을 강화하여 생산성을 높인다. 더 나아가 개발자는 도구를 활용해 실시간 데이터 호출, 계산, 외부 API 연동까지 확장 가능하다.\n\n배포와 성능 최적화를 위해 최신 모델은 여러 언어 지원과 커스터마이징, 어댑터 훈련 등을 지원하며, 제한된 컨텍스트 윈도우(약 4,096토큰) 내에서 효율적 운용이 가능하다. 그러나 복잡한 수학, 코드 생성, 논리적 추론은 아직 클라우드 대형 모델에 적합하며, 온-디바이스는 제한적 능력을 갖춘 특수 용도에 최적화되어 있다.\n\n이 기술의 가장 큰 강점은 개인정보 보호, 빠른 반응속도, iOS Swift 개발자 친화적 설계, 강력한 구조적 출력과 도구 연동 기능 등으로, 개발자들이 사용자의 신뢰를 높이고 시장 경쟁력을 확보하는 데 필수적인 도구로 자리 잡고 있다.\n\n키워드: 온-디바이스 AI, 개인정보보호, Swift 연동, 구조적 출력, 도구 호출","location":"https:\/\/santoshbotre01.medium.com\/apple-intelligence-a-developers-guide-to-foundation-models-api-for-on-device-ai-1d9979b62cfe"},{"keywords":["Culture"],"title":"Apple Platforms Runs on macOS DNA | by Uwais Alqadri ","comments":"NeXT 시절부터 맥 OS X를 거쳐서 여러 플랫폼에 어떻게 전파되었는가 설명합니다. iOS와 macOS 가 뿌리는 같지만 구조적으로 다른 부분도 있어서 CoreOS 라는 공통 분모를 찾는데 꽤 오랜 시간이 걸렸었죠","summary":"이 글은 애플 플랫폼의 내부 구조와 역사를 설명하며, Swift 개발자가 자주 접하게 되는 플랫폼의 특이한 패턴과 시스템 구조적 배경에 대해 다룹니다. 핵심 내용은 다음과 같습니다.\n\niOS, tvOS, watchOS가 모두 맥OS 위에 구축된 계층적 아키텍처의 일부임을 설명합니다. 이들 운영체제는 맥OS의 커널과 Unix 기반인 Darwin을 기반으로 하며, 이를 통해 서로 다른 플랫폼이 통합되어 작동하는 구조를 이해해야 합니다. \n\n목표 플랫폼을 구별하는 데 사용되는 사전 정의된 매크로(Target macros)는 Objective-C에서 주로 사용되며, iOS, macOS, tvOS, watchOS, visionOS 등 다양한 플랫폼마다 특정 매크로가 활성화됩니다. 이 매크로들은 예상하지 못한 방식으로 겹칠 수 있으며, Swift에서는 대신 ‘os(name)’ 구문을 사용합니다. 예를 들어, iOS와 iPadOS는 대부분 TARGET_OS_MAC, TARGET_OS_IOS, TARGET_OS_IPHONE이 모두 활성화되어 있으며, watchOS와 tvOS는 device 특성에 따라 특정 매크로가 활성화됩니다. 또한 CarPlay는 독립 OS가 아닌 iOS의 확장 기능임이 강조됩니다.\n\n애플이 NeXT를 인수하면서 도입한 NS 접두사가 어떻게 탄생했는지도 설명됩니다. NeXT의 Objective-C 프레임워크는 기존 애플 시스템과 충돌을 피하기 위해 네임스페이스 역할을 하는 NS 접두사를 채택했고, NSString, NSDate, NSObject 등과 같은 핵심 클래스들이 이 방식으로 명명됐습니다. 초기 Objective-C는 심볼을 전역으로 노출했기 때문에 충돌 방지를 위해 접두사를 사용했으나, 이후 Swift의 모듈 시스템으로 대체됐습니다.\n\n애플이 맥 OS X을 처음 발표할 때 그 기초가 된 Darwin Unix 기반의 핵심 플랫폼을 소개합니다. Darwin은 커널과 하부 시스템을 담당하며, 그래픽과 사용자 인터페이스를 구성하는 Cocoa 프레임워크는 Darwin 위에 구축된 사용자 인터페이스 계층입니다. Mac OS X의 ‘X’는 ‘10’을 의미하며, Unix 계열임을 강조하는 동시에 강력한 성능과 멀티태스킹을 지원하는 핵심 기반입니다. 이후 macOS로 이름이 변경되었지만, NeXT에서 유래한 NS 접두사와 구조는 여전히 유효하게 남아있습니다.\n\n이 글은 애플 플랫폼의 역사적 배경과 내부 구조를 이해하는 데 도움을 주며, 왜 일부 시스템이 특징적인 네이밍이나 매크로 구조를 갖는지에 대한 배경 설명을 제공합니다.\n\n핵심 키워드: 애플 플랫폼, Darwin, NeXTSTEP, NS 접두사, 계층적 구조","location":"https:\/\/medium.com\/@uwaisalqadri\/apple-platforms-runs-on-macos-dna-ee9836a42595"},{"keywords":["APPLE"],"title":"Apple, Apple Silicon의 AI 성능을 획기적으로 향상시킬 M5 칩 공개 - Apple (KR)","comments":"M5 계열 중에서 엔트리급 M5만 공개되었습니다. 신경망 가속 기능을 탑재한 GPU가 큰 특징이네요. 그나저나 Pro 와 Max 공개가 늦어져서 기다려집니다","summary":"","location":"https:\/\/www.apple.com\/kr\/newsroom\/2025\/10\/apple-unleashes-m5-the-next-big-leap-in-ai-performance-for-apple-silicon\/"},{"keywords":["APPLE"],"title":"Apple, M5 칩을 탑재한 혁신적인 iPad Pro 공개 - Apple (KR)","comments":"M5 칩을 탑재한 아이패드 프로 모델도 출시했습니다. 점점 아이패드 프로 칩은 좋아지는 데 소프트웨어가 아직 그 기능을 다 못 쓰는 느낌이네요","summary":"","location":"https:\/\/www.apple.com\/kr\/newsroom\/2025\/10\/apple-introduces-the-powerful-new-ipad-pro-with-the-m5-chip\/"},{"keywords":["APPLE"],"title":"Apple, M5 칩을 탑재한 신규 MacBook Pro 14 공개 - Apple (KR)","comments":"M5를 품은 맥북 프로 14를 공개했습니다. 올해가 맥 교체 주기인데 M5 Max 맥북프로가 안나와서 애매하네요. 내년초로 밀리는 걸까요","summary":"","location":"https:\/\/www.apple.com\/kr\/newsroom\/2025\/10\/apple-unveils-new-14-inch-macbook-pro-powered-by-the-m5-chip\/"},{"keywords":["Swift","pick"],"title":"Automate all the things with Swift Subprocess | by Jacob Bartlett ","comments":"개인적으로 이 분 블로그를 좋아합니다. swiftlang 기관에 상대적으로 뉴비인 swift-subprocess 저장소를 활용해서 스위프트로 쉘 스크립트를 활용하는 방식을 소개합니다. 저도 쉘 작업할 때 스위프트를 적극 써봐야겠네요","summary":"","location":"https:\/\/levelup.gitconnected.com\/automate-all-the-things-with-swift-subprocess-17c8c971818a"},{"keywords":["AI\/ML","영어"],"title":"Building AI features using Foundation Models. Streaming. | Swift with Majid","comments":"파운데이션 모델을 사용할 때 스트림 방식으로 연동하는 방식을 설명합니다","summary":"","location":"https:\/\/swiftwithmajid.com\/2025\/10\/08\/building-ai-features-using-foundation-models-streaming\/?"},{"keywords":["Architecture"],"title":"Composition composition composition in SwiftUI | by Mohammad Azam ","comments":"SwiftUI 에서도 뷰 재사용성과 역할과 책임을 분리하는 방법은 필수적이죠. 컨테이너+프리젠터 조합으로 책임을 나누는 방식을 설명합니다","summary":"이 글은 SwiftUI에서의 뷰 컴포지션과 재사용성 향상 방법에 대해 설명합니다. 특히, \"Container\/Presentation\" 패턴을 활용해 뷰를 두 책임으로 나누는 것이 핵심입니다. 하나는 상태와 로직을 관리하는 컨테이너(데이터와 사이드 이펙트 담당)이고, 다른 하나는 사용자 인터페이스를 그리는 프레젠터(순수 선언적 뷰)입니다. 이러한 분리 덕분에 복잡한 기능도 작은 단위의 뷰를 조합해 쉽게 구현할 수 있으며, 코드는 깔끔하고 테스트하기 쉬워집니다.\n\n고객 목록을 보여주는 경우, 각각의 고객 정보를 표현하는 CustomerCellView를 만들어 재사용성과 유지보수성을 높입니다. 그러나 이 방식은 다양한 모델에 대응하기 어려우므로, 더 유연한 재사용 가능한 셀을 설계하는 방법이 소개됩니다. 바로, 하나의 ListCellView를 만들어 제목, 부제, 이미지 위치, 액세서리 뷰 등을 속성이나 컨포지션으로 조절하는 방안입니다.\n\n이 리스트 셀은 `imagePlacement` 열거형으로 이미지 위치 조절, `leadingAccessoryView`, `trailingAccessoryView` 같은 프로퍼티로 커스텀 액세서리 뷰를 삽입할 수 있어 매우 유연합니다. 이러한 설계는 다양한 UI 요구사항에 쉽게 적응 가능하며, 복잡한 구성도 간단히 조정할 수 있게 합니다.\n\n미리보기를 활용해 여러 레이아웃 변화도 빠르게 시각 확인 가능하며, 이로 인해 디자인 검증이 용이해집니다. 글은 이러한 기법들이 SwiftUI를 활용하면서 코드의 유지보수성과 확장성을 높이는 핵심 내용임을 강조합니다.\n\n요약 키포인트:  \n1. 컨테이너\/프레젠터 패턴으로 뷰 책임 분리  \n2. 뷰 재사용성과 모듈화 강조  \n3. 유연한 ListCellView 설계 (액세서리, 위치 조절)  \n4. 커스텀 콘텐츠 삽입 가능 능력 제공  \n5. 미리보기를 통한 빠른 UI 검증\n\n#키워드: 뷰 컴포지션, 재사용성, ListCellView, 액세서리 뷰, 유연한 UI","location":"https:\/\/azamsharp.medium.com\/composition-composition-composition-in-swiftui-97a0bff3cb3e"},{"keywords":["Swift","영어"],"title":"Cultivated Task Cancellation","comments":"Task를 도중에 취소하려면 어떻게 해야할까요. 작업 단위를 크게 하면 완벽하게 뾰족한 방법은 없고 이런저런 시도를 해본 글입니다. ","summary":"","location":"https:\/\/macguru.dev\/cultivated-task-cancellation\/?"},{"keywords":["Design","영어"],"title":"Designing the Jarvis moment | by Hao Liu ","comments":"개인 디바이스에서 LLM과 대화하는 것 이상으로 앱과 정보를 통합하고 적절하게 개입하는 미래의 UX는 어떤 형태가 될까요. 요즘 UX 디자이너도 스크린과 버튼에서 벗어나서 대화와 대화 맥락을 이어가는 상호작용 설계를 고민한다고 하네요","summary":"이 글은 OpenAI의 ChatGPT와 관련된 사용자 경험(UX) 설계의 미래 방향성을 탐구하며, 특히 \"Jarvis\"와 같은 자연어 인터페이스의 발전에 대해 논의한다. 과거의 버전들과 달리, 현재와 미래의 대화형 AI는 외부 앱과 통합되고 컨텍스트 기반의 작업 수행이 가능해지면서 사용자 경험이 새롭게 진화하고 있다. 초기에는 플러그인 시스템이 앱을 별도 공간에 배치했으나, MCP(모델 컨텍스트 프로토콜) 도입 이후 ChatGPT와 외부 도구 간의 소통이 표준화되었고, SDK(앱 소프트웨어 개발 키트)는 이 과정을 시각적, 사용자 친화적으로 변화시키며, 대화 내에서 직접 상호작용하는 인터페이스를 가능하게 한다.\n\n이 SDK는 결정 피로를 줄이고, 즉각적인 정보 제공과 선택의 간소화를 통해 사용자가 더 적은 노력으로 목표를 달성할 수 있도록 돕는다. 예를 들어, Coursera와 Figma와의 연동 사례에서는 자연어 요청을 통해 복잡한 검색이나 그래픽 생성 과정을 간소화하여 사용 편의성을 높였다. 설계 시에는 Task의 명확한 범위와 간단한 인터페이스, 최소화된 선택지, 즉각적 가시성에 초점을 맞추어야 하며, 긴 내용이나 복잡한 단계는 피하는 것이 좋다. 또한, UI 가이드라인은 정보를 간략하게 전달하고, 주요 행동 버튼을 명확히 배치할 것을 강조한다.\n\n이와 같은 기술적 진전은 향후 ChatGPT가 개인 디바이스의 운영체제 또는 “Jarvis”와 같은 전지전능한 에이전트 역할을 수행하게 하는 방향으로 나아가고 있다. 이는 사용자들이 여러 앱과 정보를 자연스럽게 통합하고, AI가 필요 시 미리 예측하며, 적절히 개입하는 미래를 의미한다. UX 디자이너는 이제 스크린과 버튼 디자인을 넘어서, 대화와 컨텍스트를 중심으로 하는 플로우와 시스템을 설계하는 역할로 확장되고 있으며, AI와의 상호작용이 사용자 목표와 직관적으로 연결되도록 고민해야 한다.\n\n이러한 변화는 단순한 인터페이스를 넘어 사용자의 사고 흐름을 지원하는 시스템 설계로의 전환을 요구하며, 사용자 중심의 간단하고 직관적인 경험 창출이 핵심임을 강조한다. \n\n주요 키워드:  \n1. 컨텍스트 UX  \n2. SDK 및 통합  \n3. 대화형 인터페이스  \n4. 사용자 중심 설계  \n5. 인공지능 에이전트","location":"https:\/\/uxdesign.cc\/designing-the-jarvis-moment-8f1a2f201d4a"},{"keywords":["Swift"],"title":"Don't make this mistake with a TaskGroup — Swift with Vincent","comments":"TaskGroup을 사용할 때 당연하게도(?) Task 순서대로 실행되고 결과가 만들어지지 않는다는 점을 명심해야 할 이유를 설명합니다","summary":"","location":"https:\/\/www.swiftwithvincent.com\/blog\/dont-make-this-mistake-with-a-taskgroup?ck_subscriber_id=2978341692"},{"keywords":["Swift"],"title":"Edition #2- Swift Concurrency: What I Wish Someone Had Told Me","comments":"저도 최근에 4년정도 전에 개발했던 앱을 스위프트 6로 마이그레이션 해보고 있는데 특정 오픈소스를 바꾸는 데 시간이 오래 걸리고 해결 방법이 훨씬 복잡해지더군요. 마이그레이션이 끝나면 저도 비슷한 결론을 내릴지 비교해봐야겠습니다","summary":"이 글은 Bruno Valente Pimentel이 Swift 6의 엄격한 Concurrency 도입 이후 겪은 경험과 교훈을 솔직하게 풀어낸 글입니다. 그는 3개 앱을 6개월 만에 Swift 6로 마이그레이션하며 수많은 어려움과 예상치 못한 버그, 크래시를 겪었고, 이를 해결하는 과정에서 여러 핵심 개념과 실전 팁을 정리했습니다.\n\n주요 내용은 다음과 같습니다:\n\n1. @MainActor의 오해와 한계: @MainActor는 UI 등 동기적 안전성을 보장하지만, await 사용 시 상태가 예상치 못하게 변경될 수 있음을 파악해야 한다. suspend(중단) 상태에서 무조건 안전하다고 생각하는 것은 위험하다.\n\n2. Sendable 준수와 리팩토링 전략: 타입이 Sendable이어야 안전하게 태스크 간 데이터 전달이 가능하지만, 기존 구조를 무리하게 변경하면 오히려 더 많은 문제에 봉착할 수 있다. 일단 간단히 @unchecked Sendable을 사용하며 일단 작동하는 방향으로 하고, 추후 차근차근 리팩토링하는 방법이 현실적임을 강조한다.\n\n3. Actor의 재진입 문제: Actor는 직관적인 동시성 제어를 제공하지만, 내부 상태 변경이 예상과 달리 여러 요청이 동시에 발생하는 경우 분석이 필요하다. 예를 들어, 캐시와 IN_FLIGHT 요청 추적 기법으로 중복 요청을 방지하는 것이 효율적이다.\n\n4. 테스트의 난관과 해결책: 동시성 코드 테스트는 매우 까다로우며, 기존 XCTestExpectations 대신 await를 직접 쓰고, Task.yield()를 적절히 넣는 방법과 대량 병렬 스트레스 테스트를 통해 문제를 발견하는 것이 중요하다.\n\n5. 마이그레이션의 끝이 없다: 일부 외부 라이브러리, 글로벌 상태 등은 정리하기 어렵거나 시간이 오래 걸릴 수 있다. 우선 중요한 모듈부터 차근차근 해결하며, 전체를 한번에 수정하려 들지 않는 전략이 필요하다. 결국, 어느 정도의 '기술 부채'를 인정하고 점진적 개선을 하는 것이 현실적이다.\n\n결론적으로, Swift Concurrency는 개발 생산성과 안전성을 크게 향상시키지만, 이를 위해서는 기존 구조의 근본적 변화와 실험, 실패를 감수해야 한다. 저자는 이 과정을 통해 더 안전하고 견고한 코드를 만들 수 있다고 강조하면서, 배우는 과정 속에서 자주 흔들리고 낮은 자존감에 빠지기도 하지만, 이 역시 성장의 일부임을 위로한다.\n\n핵심 키워드: Swift Concurrency, @MainActor, Sendable, Actor, 동시성 테스트","location":"https:\/\/www.linkedin.com\/pulse\/swift-concurrency-what-i-wish-someone-had-told-me-valente-pimentel--xqb5f"},{"keywords":["Culture"],"title":"Flutter is not a cross platform framework | by R. F. Dace ","comments":"플러터가 플랫폼을 넘어서 다중 플랫폼을 지원하기 때문에 유연한 개발 도구라고 알려져있지만 가지고 있는 제약과 문제점을 짚어보는 글입니다. 저는 자체 위젯을 그린다는 점이 네이티브와 묘하게 이질감을 줘서 거부감이 있습니다","summary":"이 글은 구글이 개발한 Flutter의 한계와 문제점을 분석하여, \"Flutter가 진정한 크로스 플랫폼 프레임워크인가?\"라는 의문을 던집니다. 표면적으로는 다중 플랫폼(아이폰, 안드로이드, 웹, 데스크탑)에서 아름다운 UI를 빠르게 개발할 수 있다는 장점이 있지만, 실제로는 많은 제약과 문제점이 존재합니다.\n\nFlutter는 UI를 그리는 렌더링 엔진으로서, 네이티브 UI 컴포넌트를 사용하는 대신 자체 위젯을 그리기 때문에, 네이티브와는 다른 UI 느낌과 접근성을 갖게 됩니다. 이는 앱이 플랫폼별 자연스러움과 호환성을 떨어트리고, pixel-perfect을 맞추기 위해 많은 커스터마이징이 필요하다는 문제를 야기합니다.\n\n또한 핵심 SDK가 최소한이어서 기능 확장을 위해서는 다수의 서드파티 플러그인에 의존하게 되는데, 이들 플러그인 대부분은 유지보수 부족, 버그, 호환성 문제를 겪고 있으며, 이는 앱의 안정성과 지속적 유지보수를 어렵게 만듭니다. \n\n상태 관리 역시 표준이 없고 다양하고 복잡한 라이브러리들(Riverpod, BLoC, Provider 등)이 난무하여 개발자와 팀의 학습 곡선과 유지보수 비용을 증가시킵니다. 영속적 저장소도 Flutter 자체 솔루션이 없기 때문에 다양한 타사 패키지를 사용하며, 데이터 손실 등 문제를 겪는 사례도 보고되고 있습니다.\n\n내비게이션 시스템은 깊은 링크, 중첩 내비게이션 등 복잡성을 갖고 있으며, 플랫폼 고유의 트랜지션와 호환성 문제도 존재합니다. 또한, 하드웨어 접근(카메라, 센서 등) 역시 외부 플러그인에 의존하는데, OS 업데이트와 호환 문제, 미세한 설정 문제들이 복잡도를 높입니다.\n\n네이티브 기능에 접근하려면 플랫폼별 코드(Swift, Kotlin 등)를 작성하는 ‘Platform Channels’를 활용해야 하는데, 이는 개발의 번거로움과 비용 증가를 초래합니다. 더군다나, 빠른 개발 환경 변화로 인해 잦은 Breaking Change와 업그레이드 문제, 안정성 저하도 존재합니다.\n\n테스트와 디버깅도 어려워, Flutter의 커스텀 렌더링 방식 때문에 UI 테스트, 통합테스트가 까다롭고, 디버깅 도구 역시 성숙하지 못했습니다. 결국, “모든 플랫폼에 한번의 코드를”이라는 슬로건에도 불구하고, 실제로는 플랫폼별 최적화와 수정이 필요하며, 이는 “진정한 크로스 플랫폼”이 아니란 점을 강조합니다.\n\n요약하자면, Flutter는 뛰어난 UI를 신속히 개발하는 데 강점이 있으나, Native와 동일한 경험, 성능, 유지보수성, 일관된 플랫폼 통합을 기대하기 힘든 한계가 있으며, 따라서 “완전한 크로스 플랫폼 솔루션이 아니며, 신중한 선택이 필요하다”는 결론입니다.\n\n키워드: 크로스 플랫폼, 네이티브 호환성, 플러그인 의존, 상태관리, 유지보수\n","location":"https:\/\/medium.com\/@topbrains\/flutter-is-not-a-cross-platform-framework-9f421d38d316"},{"keywords":["DeveloperTools","영어","pick"],"title":"Foundation Models profiling with Xcode Instruments","comments":"와 딱 기다리던 스타일의 글입니다. Xcode 26에서 파운데이션 모델 프레임워크를 인스트루먼츠 기반으로 프로파일링하고 최적화하는 과정을 설명합니다","summary":"이 글은 iOS 26과 Xcode 26에서 도입된 Foundation Models 프레임워크를 활용하여 생성형 AI 모델의 성능을 프로파일링하고 최적화하는 방법을 설명합니다. Apple이 제공하는 이 프레임워크는 앱 내에서 자연어 생성, 답변 및 도구 호출 등 다양한 AI 기능을 쉽게 실험하고 사용할 수 있게 해줍니다.\n\n먼저, 간단한 SwiftUI 기반의 세션을 만들어 \"Swift에 관한 하이쿠\"를 생성하는 예제를 통해 시작합니다. 그런 다음, Xcode의 Instruments 툴을 이용해 모델의 로딩 시간과 응답 시간, 토큰 수 등을 측정하는 방법을 안내합니다. 이를 위해 Foundation Models 템플릿을 활용하며, 프로파일링 과정에서 앱의 성능 데이터를 수집할 수 있습니다.\n\n또한, 도구 호출 기능을 추가하여 무작위 감정을 생성하는 MoodTool을 구현하고, 이를 세션에 연결하는 방법도 설명합니다. 성능 향상을 위해 캐시 활용, 세션 프리워밍(prewarming), 프리워밍 시점에 프롬프트를 전달하는 최적화 기법도 제안됩니다. 특히, 프리워밍은 응답 지연을 줄이는데 효과적이나, 배경 실행 중이거나 시스템 부하가 높을 때는 기대한 만큼 효과를 보지 못할 수 있어 주의가 필요합니다.\n\n단, 시뮬레이터에서는 토큰 수량이 잘못 표시되는 문제가 있어, 실제 기기에서만 정확한 분석이 가능하다는 점도 언급됩니다.\n\n이 글의 핵심 포인트는 Xcode Instruments를 통한 Foundation Models의 성능 프로파일링 방법, 도구 호출 최적화, 세션 prewarming 전략, 그리고 iOS 기기에서의 사용 제한 사항입니다. 이를 통해 개발자는 모델 성능을 측정하고 개선할 수 있습니다.\n\n키워드: Foundation Models, Xcode Instruments, 성능 프로파일링, 도구 호출 최적화, 세션 prewarming","location":"https:\/\/artemnovichkov.com\/blog\/foundation-models-profiling-with-xcode-instruments"},{"keywords":["Culture"],"title":"Here’s Why App Developers Are Abandoning iOS 26’s Liquid Glass UI | by The Evil Geek ","comments":"iOS 26부터 도입한 리퀴드 글래스 방식을 적용하기 꺼려하는 문제에 대해 짚어봅니다. 다른 플랫폼 UI 와 비슷해지는 추세였는데 이질감이 거부감으로 이어지는 것은 아닐까요","summary":"이 글은 iOS 26에 도입된 'Liquid Glass' UI 디자인이 애플과 개발자들 모두에게 큰 기대를 모았으나, 실제 적용 사례는 기대에 미치지 못하고 있으며 많은 개발자가 채택을 꺼리고 있는 이유를 설명합니다. 2013년 iOS 7의 플랫 디자인 이후, 애플은 미니멀리즘과 단순성을 강조하며 사용성을 높여왔습니다. 그러나 Liquid Glass는 유리질(Glassmorphism)을 과장된 형태로 표현한 것으로, 빛 반사, 모션 왜곡, 액체 같은 깊이 표현 등 매우 데코레이티브하고 시각적으로 화려하지만 실용성은 떨어집니다. \n\n이러한 디자인은 필수적이거나 일상적인 앱에선 오히려 방해가 되고, 특히 '구글의 Material You'나 웹 디자인에서 쓰이는 필터들과는 호환성이 떨어지기 때문에 대형 개발사들은 쉽게 도입하지 않습니다. 게다가, Liquid Glass는 구현이 매우 복잡하고 비용이 많이 들며, 애플도 내부적으로 진지하게 다루지 않아 최신 iOS 버전에서는 기대했던 액체 느낌이 점차 사라지고 '서리 유리(frosted glass)'에 가까워지고 있습니다. 이는 성능 저하, 안정성, 접근성 문제 등을 우려한 결과입니다.\n\n결론적으로, Liquid Glass는 초기의 혁신적 기대와 달리 현실적으로 구현하기 어렵고, 애플도 이를 제대로 밀어붙이지 않으면서 기존의 깔끔하고 간결한 플랫 디자인으로 되돌아가는 듯한 양상입니다. 개발자들은 애플의 내부 정책과 기술적 한계, 그리고 사용자 경험의 일관성을 이유로 이 새로운 UI 채택을 미루거나 포기하는 상황입니다. 앞으로 이 UI는 기대보다 더 느리게, 감쇠된 모습으로 이어질 가능성이 높으며, 애플도 이 디자인의 진화 방향에 대해 고민하는 모습입니다.\n\n주요 키워드: Liquid Glass, 플랫 디자인, 개발자 호환성, 구현 난이도, 애플의 정책 변화","location":"https:\/\/evilgeek.medium.com\/heres-why-app-developers-are-abandoning-ios-26-s-liquid-glass-ui-3f03d015efe8"},{"keywords":["AI\/ML"],"title":"How I Built a Text-to-SQL System Without Vector Databases Using SQL Probes | by MKWriteshere ","comments":"전통적인 벡터 데이터베이스 기반의 자연어-SQL 시스템의 복잡성 때문에 새로운 탐색 방식을 제안하는 글입니다. 저도 전문 분야는 아니라서 어렵지만 프롬프트를 활용해서 일하는 방식이 바뀌는 것 같네요","summary":"이 글은 전통적인 벡터 데이터베이스 기반의 텍스트- SQL 시스템의 복잡성을 지적하며, 이를 해결하기 위한 새로운 탐색 방식인 \"SQL Probes\"를 소개합니다. 기존 접근법은 데이터베이스 정보를 정적 정리로 간주하고 벡터 임베딩, 유사성 검색, 재색인 등의 과정이 필요하지만, 이는 데이터 실무자들이 데이터를 탐색하는 방식과 달리 매우 복잡하고 비효율적입니다.\n\n저자는 이 문제를 해결하기 위해 데이터베이스를 적극적으로 탐색하는 방식을 도입하였는데, 바로 LLM이 SQL 쿼리를 활용하여 데이터베이스를 탐사하는 \"Self-Driven Exploration SQL (SDE-SQL)\"입니다. 이 방식은 데이터베이스에 대한 사전 지식을 쌓기 위해 벡터 임베딩 대신 SQL 자체를 도구로 활용하는 것이 특징입니다. 시스템은 초기 쿼리(기본 탐색), 조건 검증(조건별 탐색), 복합 조건 검증(조건 조합), 그리고 필요시 정제 단계를 거쳐 점차 정확한 SQL을 생성합니다.\n\n이 방법의 핵심은 수작업으로 설계된 프롬프트와 SQL 탐사를 통해 데이터 구조와 데이터 분포를 파악하고, 이를 바탕으로 최종 SQL을 생성하는 것에 있습니다. 이를 구현하기 위해 FastAPI, PostgreSQL, GPT-4, React 등 다양한 기술 스택을 사용했고, LSH(Locality Sensitive Hashing)를 사용하여 벡터 기반 임베딩 대신 빠르고 비용 효율적인 탐색을 실현했습니다.\n\n실제 DVD Rental 데이터베이스를 활용한 실험에서, 이 시스템은 85%의 성공률을 기록했으며, 복잡한 쿼리도 효과적으로 처리하는 모습을 보여줍니다. 비용은 전통적 RAG 방식을 웃돌지만, 더 높은 정확도를 제공합니다. 이 시스템은 빠른 속도는 아니지만(약 7-20초), 데이터 탐색과 데이터베이스 구조를 적극적으로 이해하여 정확성을 높이는 강점이 있습니다.\n\n이 방식은 특히 다중 테이블 및 복잡한 쿼리, 데이터 구조가 불분명하거나 역동적인 환경에서 유용하며, 전체적으로 단순한 설계와 높은 실용성을 보여줍니다. 향후 연구 방향으로는 강화학습을 통한 탐색 전략의 적응성 확보가 제시되었습니다.\n\n이 접근법은 벡터 임베딩 기반보다 더 직관적이고 실용적이며, 복잡한 실제 데이터셋에서 특히 강력함을 입증하였으며, 오픈소스 프로젝트로 제공되어 직접 실습도 가능합니다.\n\n**핵심 키워드:**  \n1. SQL Probes  \n2. 데이터 탐색  \n3. 벡터 데이터베이스 대체  \n4. 활성 탐색 방식  \n5. 실용적 텍스트-SQL 시스템","location":"https:\/\/medium.com\/data-science-collective\/how-i-built-a-text-to-sql-system-without-vector-databases-using-sql-probes-522ee96ab9fe"},{"keywords":["Architecture"],"title":"How Senior iOS Teams Build Apps That Scale — Swift Architecture Secrets | Medium","comments":"모든 서비스와 앱은 초기에 작고 깔끔하게 시작했더라도 점점 커지고 복잡해지고 문제점을 가질 때 해결하기 위한 방법과 원칙을 소개합니다. 계층 구조와 모듈화 작업에 시작하는 건 좋은 지점 같네요","summary":"이 글은 성장하는 iOS 프로젝트의 확장성과 유지보수성을 높이기 위한 Swift 아키텍처 전략에 대해 설명합니다. 초반에는 작고 깔끔하게 시작했더라도, 사용자 수가 늘어나면서 코드가 비대해지고 복잡해져 개발이 어려워지는 문제점을 지적하며, 이를 해결하기 위한 모듈화 전략을 제시합니다.\n\n기본 원칙은 '모듈화와 계층화'로, 기능별 모듈, 핵심 인프라(core modules), 그리고 유틸리티 확장(extension) 세 층 구조를 권장합니다. 기능 모듈은 각각 독립적인 Swift 패키지로 설계되어, 특정 기능(인증, 결제, 메시징, 프로필 등)을 담당하며 상호 간 의존성은 프로토콜을 통해서만 허용됩니다. 핵심 모듈은 네트워킹, 저장소, 분석 등 변경이 적은 인프라 요소들을 포함하며, 유틸리티 확장은 문자열, 날짜 등 공통 기능을 제공하는 간단한 Swift 확장으로 구성됩니다.\n\n이러한 구조의 핵심 원칙은 '상향 의존 금지', '프로토콜 기반 계약', '의존성 명시적 전달'로 요약되며, 싱글톤과 순환 참조를 피하는 것이 중요합니다. 이를 통해 테스트와 유지보수가 용이하며, 특히 의존성 주입 대신 의존성 방향(Dependency Direction)을 중시합니다.\n\n효과적인 테스트 전략도 함께 제시하는데, 이는 단위 테스트(70%), 통합 테스트(20%), UI 테스트(10%)로 나누어, 작동 속도와 신뢰성을 높입니다. 모듈별 테스트는 변경된 부분만 빠르게 검증할 수 있게 설계되며, 전체 테스트 시간도 크게 단축됩니다.\n\n또한, 실제 적용 사례와 모듈 조직 패턴(수평\/수직\/하이브리드)을 소개하며, 빌드 시간 단축을 위해 명확한 모듈 임포트, 프리컴파일된 바이너리 프레임워크, 빌드 타임 분석 도구 활용 방법도 설명합니다. 점진적 모듈화 절차와 일정도 제시하여, 초기 단계부터 꾸준히 리팩토링하는 전략이 중요함을 강조합니다.\n\n요약하자면, 이 글은 대규모 Swift iOS 프로젝트를 체계적으로 확장하고 유지하는 핵심 원칙인 모듈화, 계층화, 의존성 관리, 테스트 전략을 구체적 사례와 함께 제시하며, 빠른 개발과 안정성을 동시에 달성하는 방법을 안내합니다.\n\n---\n\n핵심 키워드:  \n1. 모듈화  \n2. 계층 구조  \n3. 의존성 방향  \n4. 테스트 전략  \n5. 빌드 최적화","location":"https:\/\/medium.com\/@bhumibhuva18\/how-senior-ios-teams-build-apps-that-scale-swift-architecture-secrets-ddf020f67709"},{"keywords":["Culture","영어"],"title":"How to Turn Liquid Glass into a Solid Interface - TidBITS","comments":"리퀴드 글래스가 싫거나 불편해서 효과를 줄이거나 끄고 싶을 때 어떻게 하면 되는지 설명합니다","summary":"","location":"https:\/\/tidbits.com\/2025\/10\/09\/how-to-turn-liquid-glass-into-a-solid-interface\/"},{"keywords":["Architecture"],"title":"I Failed a Senior iOS Interview Because I Over-Explained Dependency Injection | by Mobile App Developer ","comments":"개발자 인터뷰 글은 잘 가져오지 않는데 설명 과정에서도 과도하게 설명하다가 질문의도에 맞지 않는 딱딱한 답변을 하지 않아야 한다는 이야기라서 가져왔습니다. 이게 꼭 DI 주제가 아니라 다른 주제여도 마찬가지 같습니다","summary":"이 글은 iOS 개발자 면접에서 의존성 주입(Dependency Injection, DI)에 대해 과도하게 설명한 경험을 토대로 배운 점을 공유하고 있습니다. 강한 자신감과 깊은 지식을 갖고 있던 저자는 DI에 대해 풍부하게 설명하려다가 오히려 면접관의 기대와 요구를 벗어나 복잡하고 이해하기 어려운 설명으로 변질시키면서 실패를 경험했습니다. \n\n글쓴이는 DI의 핵심 개념을 간단히 설명하는 것의 중요성을 강조합니다. 면접관은 단순한 딱딱한 정의보다는, 이 개념이 어떻게 실무에 적용되고, 코드의 설계와 테스트 용이성, 유지보수성 향상에 어떤 의미가 있는지 이해하고 전달하는 능력을 원한다는 점을 배웠습니다. 예를 들어, 복잡한 구조를 설명하는 대신, “의존하는 객체를 주입하는 것”이 테스트와 유지보수에 어떤 도움을 주는지를 짧고 명확하게 설명하는 것이 더 효과적입니다.\n\n글쓴이는 과도한 기술적 깊이와 여러 프레임워크 사용을 강조하기보다, 핵심 개념을 원래의 목적과 의도에 맞게 간단하고 이해하기 쉽게 전달하는 능력이 중요하다고 말합니다. 또한, DI가 모든 상황에 필수적인 것은 아니며, 간단한 경우에는 굳이 과도하게 설계하지 않아도 된다는 유연한 태도도 갖추어야 함을 깨달았습니다.\n\n이 경험을 통해, 고수준 개발자일수록 복잡함보다 명료함, 판단력, 전달력으로 차별화된다는 교훈을 얻었고, 자신이 멘토링하는 개발자들에게도 ‘패턴이나 기법의 설명’보다 ‘왜, 어떻게 사용하는지’에 집중하라고 조언합니다. 최종적으로, 자신감 있고 명확한 한두 문장으로 핵심을 전달하는 능력이 인상적이고 효과적이라는 결론에 도달했습니다.\n\n요약하면, 복잡한 기술 지식을 늘어놓기보다, 핵심 개념을 간단 명료하게 설명하는 것이 더 중요하며, 이것이 진정한 선임 개발자의 모습임을 강조하는 글입니다.\n\n핵심 키워드:\n1. 의존성 주입(Dependency Injection)\n2. 명료한 커뮤니케이션\n3. 실무 적용과 테스트\n4. 깊이보다 간단함\n5. 개발자 성숙도","location":"https:\/\/medium.com\/@avula.koti.realpage\/i-failed-a-senior-ios-interview-because-i-over-explained-dependency-injection-af690111278e"},{"keywords":["AI\/ML","영어"],"title":"Just Talk To It - the no-bs Way of Agentic Engineering | Peter Steinberger","comments":"바이브 코딩을 넘어 에이전트 엔지니어링을 잘 한다는 것은 어떤 기준과 의미가 있을까요. 변경의 규모, 작업 진행 방식과 파일 버전 관리, 테스트 자동화까지 다양한 기준을 이야기해서 흥미롭네요. 번역해서 봐도 좋을 것 같습니다","summary":"이 글에서는 개발자가 최신 인공지능(AI) 툴과 엔지니어링 전략을 통해 효율적이고 간단하게 소프트웨어 개발 및 유지관리를 하는 방법을 제시하고 있다. 저자는 특히 자신의 프로젝트(약 30만 줄의 타입스크립트\/리액트 앱, 크롬 확장, CLI, Tauri 앱, Expo 모바일 앱 등)를 AI 기반 엔지니어링으로 최적화하는 과정을 상세히 설명한다.\n\n주요 내용은 다음과 같다. AI 워크플로우 최적화를 위해 컨텍스트 관리와 기술 스택 활용법, 도구 선택(특히 codex cli와 GPT-5-Codex)과 모델 선택(Claude와 비교), 그리고 작업의 \"폭발 반경\"(변경 영향력 예측과 관리)을 통해 효율성을 높이는 전략을 강조한다. 저자는 모델이 코드를 이해하고 변화를 적용하는 능력을 높이기 위해 적은 양의 prompt와 이미지, 명령어를 활용하며, 모델이 약속된 역할을 잘 수행하도록 prompt를 정제하는 방법도 설명한다.\n\n코드 변경의 소규모 또는 대규모(큰 폭탄) 배치를 통한 작업 진행, 다수의 파일과 PR 관리, 자동 커밋 및 리펙터링, 테스트 자동화, 중간 저장(continue 메시지 등)을 활용하는 실용적인 노하우를 공유한다. 복잡한 명령어 대신 직관적이고 자연스러운 언어로 모델과 대화하는 방식을 추천하며, subagents, MCPs, web 에이전트 등 도구에 대한 비판적 시각도 포함된다.\n\n저자는 염두에 두는 핵심 가치는 \"단순하고 빠르게\", \"경계를 넘지 않는\" 작업을 추구하는 것이다. 결국, “그냥 대화하듯 문제를 푸는 것”이 가장 강력하며, 이를 위해선 개발자가 AI와의 협업에 대한 직관과 경험을 쌓는 것이 중요하다고 조언한다. 마지막으로, 인공지능을 통한 엔지니어링이 기대치를 높이고 있으며, 인간과 AI가 함께 만들어가는 미래에 대한 낙관적 전망을 제시한다.\n\n요약 키워드: AI 워크플로우, Codex, 모델 선택, 효율적 개발, 대화형 엔지니어링","location":"https:\/\/steipete.me\/posts\/just-talk-to-it?ck_subscriber_id=2978341692"},{"keywords":["VisionOS"],"title":"New Chip, New Headband. But Can Anything Save Apple Vision Pro? | by Mark Ellis ","comments":"M5 비전 프로가 나오면서 오랜만에 VisionOS 카테고리 글입니다. 엄청 새로운 큰 변화라기 보다 M5 와 듀얼 밴드 스트랩이 변화의 핵심인가 봅니다. 1세대를 계속 써야겠군요","summary":"","location":"https:\/\/medium.com\/macoclock\/new-chip-new-headband-but-can-anything-save-apple-vision-pro-e5da99bdb52b"},{"keywords":["SwiftUI","Framework","영어"],"title":"Performing search with SwiftData in a SwiftUI app","comments":"","summary":"","location":"https:\/\/www.createwithswift.com\/performing-search-with-swiftdata-in-a-swiftui-app\/?"},{"keywords":["Swift","영어"],"title":"Replacing Combine's subjects with AsyncStream in Swift","comments":"콤바인 Subject 로 앱 전범위에서 관찰하는 용도로 구현한 경우에서는 AsyncStream 으로 발행 후 수신하는 구조로 대체할 수 있다고 제안합니다. ","summary":"이 글은 Swift의 비동기(concurrency) 프로그래밍과 Combine 프레임워크의 Subject를 대체하는 방법에 대해 설명한다. 전통적으로 Combine의 PassthroughSubject와 CurrentValueSubject는 앱 전체에 걸쳐 관찰자 패턴을 구현하는 데 활용되었으며, 값이 시간에 따라 실시간으로 전달되어 UI 업데이트 등에 사용됐다. 이를 통해 Thread 안전성과 구독 관리가 자동으로 처리되고, 다양한 연산자와 UIKit·SwiftUI와의 자연스러운 통합을 제공한다.\n\n하지만 Swift 5.5 이후 도입된 AsyncStream은 가벼운 구조적 비동기 방식으로, 간단한 \"발행-수신\" 패턴을 지원하며, 특정 조건하에서는 Combine 대신 사용할 수 있다. AsyncStream은 창구(continuation)를 통해 값을 전달하며, 여러 소비자가 각각의 스트림을 구독할 수 있다. 이를 위해 actor를 활용해 공유 상태를 직렬화하며, 여러 소비자에게 동시에 데이터를 브로드캐스트할 수 있다. AsyncStream은 생성, 값 전달, 종료 처리 등에서 직접 제어가 필요하며, tail 작업 취소 시 별도 관리가 요구된다.\n\nAsyncStream을 반복적으로 사용할 경우, AsyncPassthrough와 같은 래퍼를 만들어 재사용성을 높일 수 있다. 또한, 예를 들어 CurrentValueSubject 형태를 원한다면, 최신 값 저장과 업데이트 스트림을 동시에 제공하는 패턴을 구현할 수 있다. AsyncStream은 map, filter, prefix 등 기본 AsyncSequence 연산자를 통해 간단한 데이터 변환이 가능하지만, debounce, merge, combineLatest 등의 고급 연산은 여전히 Combine이 우위에 있다.\n\n취소와 관련해서는, AsyncStream은 Swift의 구조적 컨커런시 덕분에 취소 시 자동으로 종료 핸들러가 호출되지만, 구조 외부에서 장기 실행 작업을 수동으로 취소하는 경우도 고려해야 한다. 결론적으로, AsyncStream은 단순한 \"발행-수신\" 패턴에 적합하며, 복잡한 반응형 데이터 흐름에는 여전히 Combine이 더 강력하다는 점을 강조한다.\n\n요약하자면, Swift의 AsyncStream은 Combine의 Subject를 가볍게 대체하지만, 복잡한 사용자 이벤트 또는 여러 데이터 스트림을 다루는 경우엔 여전히 Combine이 필요하다.\n\n키포인트 키워드: Swift, AsyncStream, Combine, 비동기, 관찰자 패턴","location":"https:\/\/tanaschita.com\/swift-combine-subjects-vs-asyncstream\/?ck_subscriber_id=2978341692"},{"keywords":["DeveloperTools"],"title":"Saving $4000+\/month with self-hosted runners — featherless software design","comments":"CI 도구와 장비 비용 예산을 얼마나 쓰고 계신가요. 만약 M4 맥 미니로 셀프 호스팅한다면 얼마나 절약할 수 있을까 계산해봅니다","summary":"","location":"https:\/\/jeffverkoeyen.com\/blog\/2025\/10\/17\/SelfHostingMacMinis\/"},{"keywords":["Swift","영어"],"title":"Singletons with Swift Concurrency | massicotte.org","comments":"여전히 인스턴스가 하나뿐인 싱글톤 객체가 필요하지만, 현대적인 동시성 모델에서 데이터 레이스 문제나 액터 분리처럼 여전히 동기화 문제가 있어서 조심해야 한다고 말합니다","summary":"이 글은 Swift 프로젝트에서 자주 사용되는 싱글톤(singleton)의 개념과 Swift Concurrency 환경에서 이를 안전하게 관리하는 방법에 대해 설명하고 있습니다. 싱글톤은 전역 상태(global state)로서 어디서든 접근 가능하며, 이는 곧 동시성(concurrency) 문제의 원인이 될 수 있습니다. 기본적으로 싱글톤은 class 타입으로, 디폴트로 Sendable이 아니기 때문에, 여러 스레드 또는 액터에서 동시 접근 시 안전하지 않은 상태를 유발합니다.\n\n싱글톤을 제거하는 방법으로는 의존성 주입(dependency injection) 또는 컴포지션 패턴을 활용하는 것이 좋지만, 현실적으로 바로 적용하기 어렵거나 원하는 경우, Swift 6의 기능을 활용해 안전성을 확보할 수 있습니다. \n\n가장 간단한 방법은 싱글톤 타입에 `@unchecked Sendable`을 선언하는 것으로, 이 경우 컴파일러의 체크를 우회하여 수동으로 안전성을 보장할 수 있습니다. 하지만 이는 위험한 선택일 수 있어 주의가 필요합니다. 더 안전한 방법으로는 `@MainActor`를 활용하는 것이 추천되는데, 이 방법은 싱글톤을 글로벌 액터로 지정함으로써 스레드 안전성을 보장하며, 기존 접근 방식을 유지하면서도 동시성 검사 및 디버깅이 용이해집니다. 특히, `@MainActor`를 붙이면, 컴파일러가 글로벌 액터로 격리된 데이터에 대한 접근을 쉽게 추적할 수 있습니다.\n\n필요에 따라 커스텀 글로벌 액터를 만들거나, 액터를 활용하는 것도 하나의 방법이나, 이는 민감한 접근 방식을 야기할 수 있어서 신중히 고려해야 합니다. Locks(잠금)를 사용하는 경우는, 이미 메인스레드에서 대부분 접근하는 시스템에 적합하지 않으며, 교착 상태나 성능 저하 문제를 고려해야 합니다.\n\n싱글톤 초기화 과정에 대해 언급하며, 시스템 초기에는 가변(mutable) 상태를 가지다가 나중에 불변(immutable)으로 전환하는 패턴을 구현하기 어렵다고 설명합니다. 따라서, 현재로서는 `@unchecked Sendable`이나 `@MainActor`가 가장 현실적인 선택이라고 결론 내립니다.\n\n요약하자면, Swift Concurrency 환경에서 싱글톤 관리의 핵심은 안전성 확보를 위해 `@MainActor` 활용이나 `@unchecked Sendable` 선언이 가장 적합하며, actor 또는 lock 도구를 조합하는 것도 고려할 수 있습니다.\n\n---\n\n**핵심 키워드:**  \n1. 싱글톤(Singleton)  \n2. Swift Concurrency  \n3. @MainActor  \n4. @unchecked Sendable  \n5. 동시성 안전성","location":"https:\/\/www.massicotte.org\/singletons?ck_subscriber_id=2978341692"},{"keywords":["SwiftUI"],"title":"Stop Using .onAppear() for Async Work in SwiftUI — Here’s Why It’s Causing Bugs in Your App | by Mobile App Developer ","comments":"`.onAppear()`를 사용할 때 발생하는 문제점처럼 비동기 작업을 안전하게 처리하는 것은 SwiftUI 에서도 여전히 조심해야 합니다","summary":"이 글은 SwiftUI에서 비동기 작업을 안전하게 처리하는 방법과 관련된 중요한 주제입니다. 주로 `.onAppear()`를 사용할 때 발생하는 문제점들과 이로 인한 버그들을 상세히 설명하면서, 보다 적절한 대안인 `.task { }`의 사용을 강조합니다.\n\nSwiftUI의 `.onAppear()`는 UIKit의 `viewDidLoad` 같은 의미로 오해하기 쉽지만, 실제로는 그렇지 않습니다. SwiftUI는 뷰가 구조체이고 재생성될 수 있기 때문에 `.onAppear()`는 뷰가 처음 나타날 때뿐만 아니라 재생성될 때도 다시 호출됩니다. 이에 따라 API 호출이 두 번 이상 발생하거나, 뷰가 사라졌을 때도 비동기 작업이 계속 진행되는 문제, 즉 \"Ghost Task\" 문제가 발생할 수 있습니다. 특히, 비동기 작업이 뷰의 라이프사이클과 무관하게 실행될 경우 상태 업데이트 시 충돌이나 크래시가 발생하는 원인입니다.\n\n이 문제를 해결하기 위해 Apple이 나온 것이 iOS 15부터 도입된 `.task {}`입니다. `.task {}`는 뷰의 라이프사이클에 따라 비동기 작업을 자동으로 취소하며, 특정 태스크가 완료되거나 뷰가 사라질 때 안전하게 정리됩니다. 또한, `.task(id:)`를 사용하면 특정 데이터 변화에 따라 작업을 재시작하거나 멈출 수 있어 더욱 정밀한 제어가 가능합니다.\n\n일반적으로 `.onAppear()`는 간단한 UI 상태 변경, 애니메이션, 로깅 등에 사용하며, 비동기 연산이나 네트워크 요청에는 적합하지 않음을 강조합니다. 특히 리스트 내에서 무한 스크롤, 이미지 로드 등에서 `.onAppear()`를 잘못 사용할 경우, 스크롤 시 반복 호출로 네트워크 부하 및 성능 저하를 초래할 수 있습니다.\n\n또한, 구버전 iOS(14 이하)에서는 `.task {}`를 사용할 수 없어, 이때는 수동으로 작업 취소 기능을 구현하는 방법도 소개합니다. 최종적으로는 `.onAppear()` 대신 `.task {}` 또는 이에 준하는 안전한 비동기 호출 방식을 사용하여, 앱의 안정성과 성능을 확보하는 것이 중요하다고 결론내고 있습니다.\n\n요약하자면, SwiftUI에서는 비동기 작업을 처리할 때 `.onAppear()`보다는 `.task {}`를 사용하는 게 안전하며, 이를 통해 네트워크 요청 중복, 크래시, 버그를 예방할 수 있습니다.\n\n**핵심 키워드:**  \n1. `.onAppear()` 오용  \n2. `.task { }` 활용  \n3. 뷰 라이프사이클 관리  \n4. 비동기 프로그래밍 안전성  \n5. SwiftUI 최적화","location":"https:\/\/medium.com\/@avula.koti.realpage\/stop-using-onappear-for-async-work-in-swiftui-heres-why-it-s-causing-bugs-in-your-app-e0d48108ad74"},{"keywords":["AI\/ML"],"title":"Swift: Apps SDK for Foundation Models just like Apps for ChatGPT | by Itsuki ","comments":"파운데이션 모델을 ChatGPT 앱처럼 사용하도록 돕는 SDK 구현을 설명합니다. 웹뷰와 MCP 연동해서 파운데이터 모델을 기존 서비스나 에이전트처럼 활용하는 방법입니다","summary":"이 글은 Swift를 이용하여 Foundation Models을 지원하는 맞춤형 Apps SDK 개발 방법에 관한 설명입니다. 기존 OpenAI의 ChatGPT용 Apps SDK는 단순히 MCP 서버에 저장된 HTML 리소스를 iframe 또는 WebView를 통해 띄우고, 커스텀 글로벌 객체를 주입하여 양방향 통신하는 구조입니다. 이를 참고하여 자신만의 앱 SDK를 구축하는 절차를 설명합니다.\n\n핵심 단계는 세 가지입니다:\n1. MCP 서버에서 HTML 리소스를 가져옴 (`resourceURI`).\n2. 모바일은 WebView, 웹은 iframe로 HTML을 표시.\n3. JavaScript로 커스텀 글로벌 객체(`window.openai`)를 주입하여 Two-Way 통신을 가능하게 함. 이 객체는 도구 호출(`callTool`)과 후속 메시지(`sendFollowUpMessage`)를 지원하며, Swift에서는 WKScriptMessageHandler로 처리합니다.\n\n이 구조는 OpenAI가 아닌 다른 Agent나 플랫폼에서도 쉽게 적용 가능하며, Swift, Typescript, Python 등 다양한 환경에서 확장 가능하도록 설계되어 있습니다. 특히, MCP 서버의 도구(tool)는 리소스와 메타데이터(`_meta`)를 통해 앱 호출 가능 여부, resourceURI 등을 제공하며, 이를 이용해 앱을 빠르게 띄우고 사용자와 상호작용할 수 있습니다.\n\nMCPManager와 ChatManager를 수정하여 도구를 호출할 때 App이 뜨기 전에 프리뷰 화면을 보여줄 수 있고, 사용자 메시지와 통합되어 자연스럽게 흐름이 유지됩니다. 이를 위해 WebView와 스크립트 매니저는 WebKit의 WKUserContentController와 WKScriptMessageHandler를 활용하여 웹과 앱 간 메시지 교환을 처리합니다.\n\nContentView에서는 새로 추가된 `MessageType.mcpApp` 케이스를 처리하여 앱을 띄우도록 구현했고, 서버와 클라이언트가 모두 준비되면 직접 테스트 가능하게 하였습니다.\n\n이 방법은 기존 ChatGPT에 국한되지 않으며, 다양한 채팅 서비스와 Agent에 적용 가능하여 새롭고 유연한 앱 생성을 지원하는 SDK 개발 방향성을 제시합니다. 개발자가 서버 재사용성과 확장성을 고려하여 자유롭게 활용할 수 있는 구조입니다.\n\n---\n\n**핵심 키워드:**\n1. MCP 서버 HTML 리소스\n2. WebView\/iframe 통신\n3. 커스텀 글로벌 객체(window.openai))\n4. 양방향 메시지 교환\n5. 플랫폼 독립적 SDK구조","location":"https:\/\/levelup.gitconnected.com\/swift-apps-sdk-for-foundation-models-just-like-apps-for-chatgpt-9188c03221dd"},{"keywords":["SwiftUI"],"title":"SwiftUI Architecture: Structure Views for Reusability and Clarity","comments":"SwiftUI 아키텍처는 여전히 압도적으로 이거다 하는 게 없네요. 그럼에도 뷰 몸체는 금방 거대해지고 구조적으로 재사용과 명확하게 구분이 필요합니다. ","summary":"","location":"https:\/\/www.avanderlee.com\/swiftui\/swiftui-architecture-structure-views-for-reusability-and-clarity\/?ck_subscriber_id=2978341692"},{"keywords":["SwiftUI"],"title":"SwiftUI Secrets Nobody Talks About! | by Jayant Kumar ","comments":"잘 알려지지 않았지만 유용한 State 나 Modifier 에 대한 팁입니다","summary":"이 글은 SwiftUI 개발에 숨겨진 10가지 유용한 비밀과 팁을 소개하여 성능 향상, 디자인 개선, 개발의 편리성을 도모하고 있습니다. SwiftUI는 선언적 문법과 실시간 미리보기, 간편한 UI 구성 덕분에 많은 개발자에게 인기를 끌었지만, 여전히 잘 알려지지 않은 유용한 기능들이 숨어 있습니다.\n\n1. PreferenceKey: 자식 View에서 부모 View로 정보를 전달하는 핵심 기능. 예를 들어, 텍스트의 너비를 측정해서 부모 뷰에 전달하는 데 활용 가능.\n2. withTransaction: 애니메이션 효과를 정교하게 제어할 수 있는 방법. 예를 들어, 사전 정의된 트랜잭션으로 뷰의 보여주기\/숨기기 전환에 자연스러운 애니메이션 적용.\n3. ViewThatFits: iOS 16에서 도입된, 공간이 부족할 때 자동으로 적합한 레이아웃을 선택하는 유연한 뷰.\n4. EquatableView: 무거운 뷰의 불필요한 재구성을 방지하는 최적화 도구. 데이터가 변경되지 않으면 재렌더링을 피함.\n5. @SceneStorage: 화면 전환, 구성 변경 시에도 UI 상태(스크롤 위치, 텍스트 등)를 유지하는 저장소. 다른 상태 저장 방식을 보완.\n6. @ViewBuilder: 커스텀 뷰에 여러 자식을 넣을 수 있게 해주는 기능. 유연한 UI 구성에 유용.\n7. drawingGroup(): 복잡한 그래픽 작업 시 GPU를 활용하게 하여 성능을 높이는 방법. 오버레이 및 그림자 작업에 추천.\n8. id(): 뷰의 강제 새로 고침이 필요할 때 사용. 특정 값으로 식별자를 새롭게 부여하여 강제 업데이트 가능.\n9. allowsHitTesting: 특정 뷰를 눈에 보이게 하면서 클릭은 차단하는 용도. UI 잠금 또는 비활성화에 유용.\n10. @FocusState: 텍스트 필드 등에 포커스 제어를 쉽게 하는 방법. 키보드 제어와 사용자 경험 향상.\n\n이러한 비밀 기능들은 SwiftUI의 성능과 효율성을 높이고 사용자 경험을 개선하는 데 큰 도움이 됩니다. 개발자가 주로 사용하는 기본적인 구문 외에도 이 숨겨진 기능들을 숙지하면 더욱 다채롭고 최적화된 iOS 앱 개발이 가능해집니다.\n\n핵심 키워드: PreferenceKey, withTransaction, ViewThatFits, EquatableView, @SceneStorage, 성능 최적화, 상태 저장, 커스텀뷰, 애니메이션 제어, UI 잠금","location":"https:\/\/nameisjayant2.medium.com\/swiftui-secrets-nobody-talks-about-but-you-need-to-know-6b499bd4d868"},{"keywords":["SwiftUI"],"title":"The Power of Tiny SwiftUI Views | by Jayant Kumar ","comments":"결국 우리가 만드는 화면은 각자 역할이 있는 작은 뷰를 여러 개 조합해서 만들어야 합니다. 공백도 가로줄도 그룹 역할도 작은 뷰에서 시작이니까요","summary":"","location":"https:\/\/nameisjayant2.medium.com\/the-power-of-tiny-swiftui-views-67cf29ce0776"},{"keywords":["Architecture"],"title":"The SwiftUI Architecture: No Country For Old Men | by Yeskendir Salgara ","comments":"이 글의 설명에 꽤 동의하는 편입니다. MVVM 이나 TCA 구조이전에 제공하는 Property Wrapper를 충분히 깊게 사용해보는 게 우선인 것 같습니다","summary":"이 글은 SwiftUI의 아키텍처에 대한 새로운 관점을 제시하며, 많은 개발자들이 오해하거나 간과하는 핵심 구조를 조명합니다. 저자는 Apple이 SwiftUI에 내장시킨 주요 설계 원리인 @propertyWrapper와 DynamicProperty가 단순한 헬퍼가 아닌, SwiftUI의 근본적인 아키텍처 구성요소라고 주장합니다.\n\n현재 대부분의 SwiftUI 프로젝트에서는 MVVM이나 TCA 패턴을 따르지만, 이들은 사실 SwiftUI 자체의 자연스러운 방식이 아니며, SwiftUI가 제공하는 도구와 개념을 충분히 활용하지 않는다고 말합니다. SwiftUI는 @State, @EnvironmentObject, @ObservedObject 등 다양한 속성 래퍼(Property Wrappers)를 사용하며, 모두가 DynamicProperty 프로토콜을 준수합니다. 이들 속성 래퍼는 하나의 일관된 시스템으로서, 상태 관리, 의존성 주입, 데이터 흐름 등을 자연스럽게 처리합니다.\n\n@propertyWrapper는 세 가지 상호작용 방식(랩핑된 값, 프로젝션, 그리고 래퍼 자체)을 제공하며, 이를 통해 강력한 상태 제어와 유연성을 확보합니다. DynamicProperty는 외부 데이터 업데이트, 비동기 호출, 의존성 주입, 및 여러 복합 개념들을 쉽게 구현할 수 있게 해줍니다. Async API 호출, 의존성 주입, 프로퍼티 래퍼의 중첩, 그리고 테스트 가능성까지 모두 이 시스템 안에서 자연스럽게 작동됩니다.\n\n저자는 이러한 방식이 기존의 패턴보다 더 직관적이고 SwiftUI의 설계 원리와 일치한다고 강조하며, 프로퍼티 래퍼와 DynamicProperty를 통해 building 하는 구조는 비단 깔끔한 UI 상태 관리를 넘어서, 더 높은 수준의 추상화와 재사용성, 그리고 테스트 용이성을 제공한다고 결론짓습니다. 즉, MVVM, TCA와 같은 패턴을 강요하기보다는, SwiftUI가 제공하는 도구 내부에서 자연스럽게 상태와 데이터의 흐름을 구성하는 방법이 가장 이상적임을 제안합니다.\n\n키워드: \n1. SwiftUI 아키텍처  \n2. @propertyWrapper, DynamicProperty  \n3. 상태 관리, 의존성 주입  \n4. 자연스러운 데이터 흐름  \n5. 테스트 가능성","location":"https:\/\/medium.com\/@salgarayes\/the-swiftui-architecture-no-country-for-old-men-53fd9d998e82"},{"keywords":["Design"],"title":"The writing is the design | by Oluwatosin Obalana ","comments":"UX 디자인에서 보여주는 텍스트가 단순한 정보 전달을 넘어 사용자 경험의 핵심 설계 요소라서 글쓰기가 중요하다고 강조합니다","summary":"이 글은 UX 디자인에서 글쓰기의 중요성을 강조하며, 텍스트가 단순한 정보 전달을 넘어 사용자 경험의 핵심 설계 요소임을 제시한다. 과거에는 콘텐츠를 마지막 단계의 작업으로 간주하거나 AI에 의존하여 빠르게 처리하는 경향이 있었지만, 이제는 언어 자체가 제품의 전략, 공감, 안전성의 중요한 부분임을 인식해야 한다. 글쓰기를 설계의 관점으로 보며, 문제 해결을 위한 전략적 사고와 사용자 중심의 사고가 필요하다고 주장한다.\n\n저자는 \"쓰는 것\"과 \"설계하는 것\"의 차이를 명확히 하며, 단순히 문장을 짓는 것이 아닌 문제 해결을 위한 설계임을 강조한다. 이를 위해 세 가지 핵심 프레임워크인 '사용 가능(Usable)', '유용(Useful)', '책임감 있는(Responsible)'의 원칙을 제시한다. \n\n1. **사용 가능**: 명확한 언어로 누구나 쉽게 이해하고 사용할 수 있도록 만듦. 예를 들어, 로그인 오류 메시지에서 구체적이고 실천 가능한 안내를 제공하는 것.\n2. **유용**: 사용자 의도를 파악하고 존중하면서, 그들이 원하는 목표를 달성하도록 돕는 것. 예를 들어, 계정 삭제 시 직설적이고 명확하게 안내.\n3. **책임감 있는**: 언어의 악용 가능성을 고려하고 배려하는 것. 혐오적이거나 불쾌감을 줄 수 있는 언어를 피하고, 공정하고 포용적인 메시지를 유지하는 것.\n\n또한, 글은 AI 활용 시 전략적 프로프트 설정, 공감 필터링, 명료성 및 자연스러운 톤의 편집이라는 세 가지 단계의 프레임워크를 제시하며, AI와 협력하면서도 결국 디자인의 책임과 전략적 방향성은 디자이너의 역할임을 강조한다. 나아가, 오류 메시지 설계에 있어서도 사용자 중심이며 정직하고 명확하게 안내하여 신뢰를 구축하는 것이 중요하다고 설명한다.\n\n결론적으로, 텍스트가 설계의 핵심 도구임을 인지하고, 전략적 사고와 공감, 책임감을 갖춘 언어 사용을 통해 더 유용하고 신뢰받는 제품을 만들어야 하며, AI는 그 도구를 보조하는 역할임을 명시한다.\n\n**핵심 키워드**:  \n1. 글쓰기와 설계의 통합  \n2. UUR 프레임워크 (Usable, Useful, Responsible)  \n3. 사용자 중심, 명확성, 공감  \n4. 책임감 있는 언어 사용  \n5. AI 활용과 전략적 프로프트","location":"https:\/\/uxdesign.cc\/the-writing-is-the-design-a8ccde162d35"},{"keywords":["SwiftUI","영어"],"title":"Transforming Glass Views with the glassEffectID in SwiftUI – SerialCoder.dev","comments":"glassEffectID modifier로 투명한 유리 뷰를 만드는 방식을 설명합니다","summary":"","location":"https:\/\/serialcoder.dev\/text-tutorials\/swiftui\/transforming-glass-views-with-the-glasseffectid-modifier-in-swiftui\/?"},{"keywords":["UIKit"],"title":"UIKit Auto Layout iOS 18: New Features & Performance Tips | Medium","comments":"iOS 18부터 오토 레이아웃 성능도 좋아지고, 에러 메시지가 직관적이고 뷰ID 와 속성을 포함해서 디버깅이 쉬워졌습니다. 그 밖에도 좋아진 부분들을 지적하는 글입니다","summary":"iOS 18에서 발표된 UIKit의 Auto Layout 기능 향상은 많은 개발자들이 놓치고 있던 중요한 개선 사항입니다. 이 업데이트는 성능, 디버깅, 안정성, 그리고 미래 지향적인 측면에서 기존과는 차별화된 변화를 가져왔습니다. 먼저, constraint 활성화 속도가 약 40% 빨라졌으며, 복잡한 계층 구조에서도 성능 향상이 확연히 느껴집니다. 이는 Auto Layout의 제약 조건 해결 방식을 배치(batch) 처리하는 방식이 개선되었기 때문입니다. 여러 제약 조건을 한번에 활성화하는 패턴이 성능 향상과 유지보수 용이성을 동시에 제공하여 개발 효율성을 높입니다.\n\n디버깅 경험이 크게 개선되어, Constraint 메시지가 더 직관적이고 읽기 쉽게 변경되었고, 뷰 ID와 속성 이름이 포함되어 오류 원인 파악이 빨라졌습니다. 이는 생산 중 제약 조건 충돌 해결 시간을 절반 이상 줄여줍니다. 더불어, baseline 정렬이 정밀해져, 커스텀 폰트, Dynamic Type, SF Symbols 등 다양한 텍스트 조합에서도 수작업 보정 없이 픽셀 단위의 정렬이 가능해졌습니다. \n\nStack View의 배포(distribution) 역시 예전보다 일관성 있게 작동하며, 내부 콘텐츠 크기와 중첩 스택 구조에서도 예측 가능성이 높아졌고, Safe Area 인셋의 애니메이션 역시 자연스럽고 부드럽게 처리됩니다. 이러한 변화는 UIKit 언어의 강점을 유지하면서, 성능 및 디버깅 편의성을 대폭 향상시키고 있습니다. 개발자는 활성화 방식, baseline 정렬, fillProportionally의 신뢰성 향상, 그리고 디버깅 메시지 개선 등 기존 패턴을 수정 또는 채택하여 생산성을 높일 수 있습니다.\n\n결론적으로, iOS 18은 UIKit을 지원하는 기존 앱의 효율성과 신뢰성을 크게 향상시키는 업데이트로, 하루 하루 개발 부담을 줄이며 더 빠르고 안정적인 앱 개발을 가능하게 합니다. 이로써 SwiftUI에 치우친 흐름 속에서도 UIKit의 가치를 다시 한번 강조하는 의미 있는 변화라고 볼 수 있습니다.\n\n**키워드:** 성능 향상, 디버깅 개선, 안정성 강화, 제약 조건 활성화, UIKit 발전","location":"https:\/\/ravi6997.medium.com\/uikit-auto-layout-in-ios-18-hidden-features-that-change-everything-1afbde654121"},{"keywords":["Swift","pick"],"title":"We Migrated 40,000 Lines of Objective-C to Swift. Here’s What Nearly Killed Us. | by Mobile App Developer ","comments":"애플이 과거의 세심한 디테일과 품질에 대한 집착에서 멀어지고 최근 제품과 사용자 경험 디자인에 대한 실망과 문제점을 지적하는 내용입니다. 애플이 강조하던 디테일을 찾는 재미가 컸었는데 말이죠","summary":"이 글은 iOS 앱의 Objective-C에서 Swift로 마이그레이션하는 과정에서 겪은 어려움과 교훈에 관한 경험담입니다. 40,000줄의 기존 Objective-C 코드를 Swift로 전환하는 프로젝트는 처음 계획보다 훨씬 오래 걸리고 복잡했으며, 여러 가지 기술적 문제와 팀 내 피로감이 수반되었습니다.\n\n주요 문제점은 먼저 \"브리지 헤더\" 문제로, Objective-C와 Swift 간의 호환이 매우 까다로워 모듈 재구성 및 복잡한 의존성 문제를 야기했습니다. 다음으로, Objective-C의 nil 처리가 Swift의 옵셔널 시스템과 충돌하면서 nullability 문제를 해결하는 데 많은 시간과 노력이 들어갔습니다. 또한, Objective-C의 동적 타이핑이 Swift의 엄격한 타입 시스템과 충돌하며 많은 타입 오류를 발생시켰습니다.\n\n메모리 관리에서도 예상치 못한 누수가 발생했고, Swift와 Objective-C를 혼합 사용하면서 발생하는 retain cycle, async 콜백 문제를 해결하는 데 오랜 시간이 걸렸습니다. 빌드 스크립트와 CI\/CD 프로세스 역시 Swift의 모듈 성격에 맞게 재설계해야 했으며, SwiftUI 도입 시 많은 혼란과 실패를 경험했습니다.\n\n가장 어려운 점은 팀 내 사기 저하와 반복되는 디버깅이었고, 결국 성공적으로 완료했을 때는 성능 향상과 안정성 증가, 유지보수 용이성 개선이라는 성과를 얻었지만, 그 과정은 큰 비용과 노력, 그리고 많은 좌절을 견뎌야 했습니다.\n\n이 경험을 통해 저자는, 언어의 교체는 단순한 기술적 전환이 아니라 팀의 사고방식과 개발 문화의 변화라는 점을 깨달았으며, 앞으로는 더 체계적이고 단계적인 전략으로 접근할 것을 권장합니다. 또한, 마이그레이션이 가져오는 기술적·정신적 비용을 감안해야 하며, 잘못된 계획은 프로젝트를 위험에 빠뜨릴 수 있음을 강조했습니다.\n\n요약하자면, Objective-C에서 Swift로의 재작성은 기술적, 인적 측면 모두 큰 도전이었으며, 성공보다는 실패와 학습의 연속이었지만, 결국 개발자들의 역량과 코드 품질을 향상시키는 계기가 되었다는 내용입니다.\n\n---\n\n**핵심 키워드:**  \n1. Objective-C→Swift 마이그레이션  \n2. 브리지 헤더 문제  \n3. 타입 안전성과 옵셔널 문제  \n4. 메모리 누수와 retain cycle  \n5. 팀 피로감과 프로젝트 성공사례","location":"https:\/\/medium.com\/@avula.koti.realpage\/we-migrated-40-000-lines-of-objective-c-to-swift-heres-what-nearly-killed-us-de5557c64cf0"},{"keywords":["Culture"],"title":"What Happened to Apple's Legendary Attention to Detail? - Fragments & Reflections","comments":"애플이 과거의 세심한 디테일과 품질에 대한 집착에서 멀어지고 최근 제품과 사용자 경험 디자인에 대한 실망과 문제점을 지적하는 내용입니다. 애플이 강조하던 디테일을 찾는 재미가 컸었는데 말이죠","summary":"이 블로그 글은 애플의 최근 제품과 사용자 경험(UX) 디자인에 대한 실망과 문제점을 지적하는 내용을 담고 있습니다. 저자 존 오즈베이는 애플이 과거의 세심한 디테일과 품질에 대한 집착에서 멀어졌다고 비판하며, 특히 iOS 26과 맥OS의 업데이트 이후 나타난 각종 UI 문제와 버그를 상세히 설명합니다. 예를 들어, 맥북의 '리마인더' 앱에서 위치 권한 요청 팝업이 반복 나타나고, 검색 바 위치와 디자인이 일관성 없으며, 탭 디자인도 통일되지 않아 사용자 혼란을 야기한다고 지적합니다. \n\n또한 iOS 26의 파일 앱, 공유 시트, 그리고 웹 브라우저(특히 사파리)에서 심각한 그래픽 및 인터페이스 버그가 발생하는 문제를 언급하며, 특히 WebKit의 문제로 인해 서드파티 브라우저들이 제대로 작동하지 않는 문제를 비판합니다. 아이메시지와 앱 라이브러리 등도 디자인과 기능상 문제들이 적지 않으며, 이는 애플의 디자인 일관성 결여와 내부 소통 부족의 결과라는 진단입니다. \n\n글의 말미에서는 애플의 이번 디자인 변화가 경쟁사보다 더 독창적이기보단, 오히려 품질 저하와 사용자 불편을 야기하는 잘못된 방향임을 지적하며, 애플의 근본적인 디자인 철학과 품질관념이 흔들리고 있다는 우려를 표명합니다. 저자는 애플이 더 이상 과거의 세심함과 사용자 중심 디자인을 실천하지 않으며, 일부 프로젝트 인력의 서두름과 목표 실적 우선주의가 문제임을 감탄과 실망을 섞어 비판합니다. \n\n이 글은 애플의 황폐해진 사용자 경험과 내부 문제들을 적나라하게 꼬집으며, 품질과 일관성을 회복하기 위한 개선이 필요하다는 메시지를 전달합니다.\n\n키워드: 애플, UX 문제, iOS 26, 디자인 일관성, 사용자 불편","location":"https:\/\/blog.johnozbay.com\/what-happened-to-apples-attention-to-detail.html"},{"keywords":["Design","영어"],"title":"What Perplexity’s AI browser reveals about UX’s future | by Adrian Levy ","comments":"AI 기반 브라우저인 Perplexity의 Comet 브라우저를 통해 미래 UX의 방향성을 분석한 글입니다. 이런 자연어 인터페이스 방식을 목적 기반 디자인이라고 부르는군요","summary":"이 기사에서는 AI 기반 브라우저인 Perplexity의 Comet 브라우저를 통해 미래 UX의 방향성을 분석하고 있다. Comet은 기존 탐색 방식을 탈피하여, 사용자가 정보를 요청하면 AI가 직접 목적을 이해하고 수행하는 ‘목적 기반 디자인’을 제시한다. 이는 URL 입력 대신 자연어 인터페이스를 제공하며, 세션 전체에 걸쳐 맥락과 목표를 유지해 사용자 의도를 파악한다는 점이 핵심이다.\n\nCoemet의 세 가지 핵심 기능은 1) 적극적이고 맥락을 파악하는 AI 도움자, 2) 목표 기억 및 지속성, 3) 여러 사이트를 동시에 분석하는 통합적 정보 처리 능력을 갖추었다. 이를 통해 사용자는 수십 개의 탭과 수작업 비교 대신 단순한 자연어로 요청하면 AI가 연구, 검색, 종합을 자동 수행하며, 사용자 통제권도 유지할 수 있다.\n\n테스트 결과, Comet은 특수한 복합 작업에서는 90% 이상 성공률을 보였고, 복잡한 의도 분석, 여러 자료의 종합 등에서는 기존 시스템보다 훨씬 뛰어난 성능을 기록했다. 그러나 속도 문제와 보안 취약점 등 여전히 기술적 도전과제도 존재한다.\n\n이 시스템은 AI가 개별 작업을 수행하는 것뿐 아니라, 서로 협력하는 분산된 AI들이 별도 통합 없이도 사용자 목표를 공유하며 협력하는 ‘분산 협력’형태를 보여준다. 이는 기존의 단일 시스템보다 자연스럽고 신뢰할 만한 사용자 경험이 가능하다는 주장이다.\n\n실제 사례로, 사용자가 특정 제약 조건 하에 여행 계획, 쇼핑, 예약 등을 AI가 단계별로 수행하며, 사용자는 검증과 승인만 하면 된다. 이를 통해 AI의 성과와 한계를 명확히 파악하고, 실패 시 투명한 원인 설명과 재시도를 가능하게 하여 신뢰를 유지한다.\n\n이러한 변화는 단순한 기술 성능 향상을 넘어서, 사용자의 인지적 부담을 줄이고, 목표 중심의 인터페이스로 전환하는 새로운 디자인 패러다임을 제시한다. 앞으로 UX 및 제품 개발은 AI와 협력하는 의도 연속성과 재사용 가능성에 초점을 맞춰야 하며, 이 과정에서 실패 및 한계에 대한 명확한 커뮤니케이션이 매우 중요하다.\n\n결론적으로, Comet은 AI UX의 핵심 원리를 경험적으로 검증하며, 미래는 단일 AI 시스템보다는 여러 특화된 AI들이 협력하는 생태계에 달려 있음을 보여준다. 이제 중요한 것은 이 패러다임 전환을 어떻게 주도하느냐에 달려 있으며, 경쟁 우위 확보를 위해 생태계 구축과 협력 방안이 시급하다고 강조한다.\n\n키포인트: \n1. 목적 기반 UX 패러다임 전환  \n2. 분산 협력 AI 시스템  \n3. 사용자 통제권 유지와 신뢰 구축  \n4. 성능·보안 문제의 성숙 과정  \n5. 목표 지속성 및 의도 연속성 강조","location":"https:\/\/uxdesign.cc\/what-perplexitys-ai-browser-reveals-about-ux-s-future-d7a702529a4a"},{"keywords":["Culture"],"title":"Why Big Tech Doesn’t Want Just Android or iOS Developers Anymore | by Mobile App Developer ","comments":"해외에서도 2025년부터 \"그냥 Android 또는 iOS 개발자\"라는 정체성이 한계에 부딪히고, 백엔드 연계와 AI 활용까지 학습하고 성장하는 시스템 설계 능력을 가진 엔지니어를 찾는다고 강조합니다. 어려운 시대로군요","summary":"2025년 현재 모바일 개발자의 역할은 과거와 크게 달라지고 있습니다. 한때 Android나 iOS 개발자가 플랫폼별로 특화된 기술만 잘 익히면 성공하는 시대였지만, 지금은 그렇지 않습니다. 기업들은 단순히 앱 개발 능력보다 시스템 전체의 생태계와 경험 설계, 그리고 백엔드와의 연계 능력을 더 중요하게 평가하고 있습니다.\n\n과거에는 Android와 iOS 개발이 독립적인 전문 분야였으며, 네이티브 기술과 UI\/UX의 섬세한 구현이 주된 요구사항이었습니다. 하지만 오늘날 기업들은 앱이 다양한 디바이스와 서비스에 걸쳐 어떻게 작동하는지 설계하는 능력을 원하며, 플랫폼 간 경계를 넘어선 통합적 사고를 기대하고 있습니다.\n\n이제는 크로스플랫폼 프레임워크(예: Flutter, React Native, Kotlin Multiplatform)가 성숙하면서, 여러 팀이 공유 코드를 활용하는 방식이 일반화되고 있습니다. 개발자들은 Kotlin과 Swift를 동시에 이해하며, 백엔드 API 설계, AI 연계, 시스템 규모와 복잡도를 고려한 시스템 설계능력을 갖춰야 합니다. 단순 앱 UI를 넘어서, 데이터 동기화, 캐시, 페일오버 등 분산 시스템의 복잡성을 이해하는 능력이 중요해졌습니다.\n\nAI도 모바일 경험의 핵심 요소로 부상하며, 내부 또는 클라우드 기반의 머신러닝, LLM 활용이 새로운 표준이 되고 있습니다. 개발자는 UI 디자인뿐 아니라, AI 데이터 처리, 개인정보 보호 등 문제 해결자로서의 역할도 수행해야 합니다.\n\n2025년에는 \"그냥 Android 또는 iOS 개발자\"라는 정체성은 한계에 부딪히게 되며, 생태계 전체를 아우르는 문제 해결 능력, 시스템 사고, 백엔드 이해도가 높은 개발자가 더욱 각광받고 있습니다. 지속적으로 백엔드 연계, 시스템 설계, AI 활용 등을 학습하며, 특화된 전문지식과 함께 폭넓은 이해를 갖춘 \"T-shaped 인재\"가 시장의 핵심입니다.\n\n---\n\n**핵심 키워드:**  \n- 모바일 생태계 통합  \n- 크로스플랫폼 기술  \n- 시스템 설계 능력  \n- AI와 머신러닝 적용  \n- 백엔드 협업 및 이해","location":"https:\/\/medium.com\/@avula.koti.realpage\/why-big-tech-doesnt-want-just-android-or-ios-developers-anymore-b10575ee0171"},{"keywords":["DeveloperTools"],"title":"Why Swift Migration Tooling Matters","comments":"스위프트 6로 마이그레이션을 도와주는 도구와 설정을 사용해보셨나요. 저도 아직 써보지 않았는데 마이그레이션 전략을 고려해서 도구로 변환을 시켜보는 과정을 설명합니다","summary":"","location":"https:\/\/www.avanderlee.com\/concurrency\/swift-migration-tooling-upcoming-swift-features\/?"},{"keywords":["Design","영어"],"title":"I was wrong about Liquid Glass | by Michal Malewicz ","comments":"베타 버전에서 실말했던 때도 있었지만 '작은 디테일들이 모여 섬세한 즐거움을 만든다'고 강조하며 유리 같은 투명 효과, 부드러운 애니메이션, 디테일한 하이라이트 등 작은 요소들이 전체적인 UI의 만족도를 높였다고 말합니다","summary":"이 글은 디자이너 미하우 말레비츠(Michal Malewicz)가 애플의 Liquid Glass 디자인을 중심으로 UI(사용자 인터페이스)의 발전과 그 의미를 탐구하는 이야기입니다. 처음 그는 Liquid Glass를 기대하며 베타 버전을 사용했지만, 초기에는 가독성과 개인화 문제로 실망하기도 했습니다. 그러나 계속해서 개선되는 애플의 디자인을 경험하며, Liquid Glass의 깊이감과 디테일이 사용자에게 주는 즐거움(delight)이 얼마나 중요한지 깨닫게 됩니다.  \n\n말레비츠는 디자인에 대해 '작은 디테일들이 모여 섬세한 즐거움을 만든다'고 강조하며, 유리 같은 투명 효과, 부드러운 애니메이션, 디테일한 하이라이트 등 작은 요소들이 전체적인 UI의 만족도를 높인다고 말합니다. 또한 그가 개발한 예제 앱은 Liquid Glass와 텍스처, 리플 이펙트 등을 활용해 'Liquid Ice'라는 새로운 개념을 만들어내며, 기술의 발전이 창의적 인터페이스를 가능하게 한다는 점을 보여줍니다.  \n\n또한, 그는 애플의 디자인 철학이 대중에게 미치는 영향과, 사용자들의 개인화 선택이 기존보다 더 세련되고 이해도 높아졌음을 지적하며, 디자인은 본질적으로 기능적이어야 하며 동시에 즐거움을 주는 것이 중요하다고 강조합니다. 마지막으로, Liquid Glass는 새로운 UI 깊이 아이디어의 출발점으로, 강력한 하드웨어와 창의적 기술이 만나는 접점임을 시사합니다.  \n\n이 글은 기술과 디자인, 그리고 개인적 영감이 어우러진 깊이 있는 통찰을 제공하며, 앞으로의 인터페이스 발전에 대한 기대를 품게 합니다.\n\n키워드: Liquid Glass, 사용자 경험(UX), 디테일, 인터페이스, 애플 디자인","location":"https:\/\/michalmalewicz.medium.com\/i-was-wrong-about-liquid-glass-751ce510f5ec"},{"keywords":["Framework"],"title":"iOS GraphQL & Async\/Await: Modern Networking Guide 2025 | Medium","comments":"REST 대신 GraphQL + Apollo 클라이언트와 async\/await 패턴을 활용하여 네트워킹 성능을 올리는 방법입니다. 물론 GraphQL도 여러 곳에 요청을 많이하지 않아야 합니다","summary":"이 글은 최신 iOS 앱 개발에서 REST API 대신 GraphQL과 Swift의 async\/await 패턴을 활용하여 네트워킹 성능을 극대화하는 방법을 소개한다. 빠른 데이터 로딩과 오프라인 활용 경험 제공이 사용자 만족도 향상에 핵심인 시대에, 개발자는 네트워크 호출을 최소화하고 효율성을 높이는 방법을 모색해야 한다.\n\n먼저, 기존 REST API는 여러 개의 엔드포인트 호출로 인해 지연, 배터리 소모, 유지보수 난제 등을 야기했지만, GraphQL은 단일 요청으로 필요한 데이터를 정확하게 요청할 수 있어 네트워크 오버헤드를 평균 58% 감소시킨다. GraphQL의 강점은 요청마다 필요한 데이터만 요청 가능하며, 버전 관리를 걱정할 필요도 없다. 특히 실시간 업데이트를 위한 구독 기능도 손쉽게 활용 가능하다.\n\nSwift의 async\/await는 콜백 지옥을 없애고 코드 가독성과 유지보수성을 크게 높였다. 예전의 중첩 콜백 방식은 복잡성 증가와 오류 발생 위험이 크지만, async\/await는 병렬 요청을 간단하고 명확하게 처리할 수 있게 도와준다. 예를 들어, 여러 요청을 동시에 수행하고 데이터가 모두 도착할 때까지 기다릴 수 있어 성능이 향상된다.\n\n네트워킹 환경을 효과적으로 관리하기 위해 Apollo 클라이언트는 다양한 캐싱 전략을 제공하며, 인메모리 캐시, 디스크 캐시, 그리고 적절한 캐시 무효화 정책을 활용하면 오프라인 상태도 지원할 수 있다. 이를 통해 빠른 화면 로딩과 오프라인 경험을 동시에 제공하는 ‘오프라인 우선’ 패턴이 가능하며, 사용자 경험 개선에 크게 기여한다.\n\n에러 처리 역시 중요하며, 재시도 로직(지수 백오프 적용)과 태스크 취소 기능을 활용하는 등 네트워크 불안정성에 강인한 코드를 작성하는 것이 필수다. 또한, 병렬 요청, 배치 요청, 연결 풀링, 압축 등을 활용하여 성능을 추가로 향상시킬 수 있다.\n\n부적절한 작업 차단이나 메인 스레드 블로킹, 낮은 메모리 환경에서의 캐시 관리 등을 방지하는 최적화 방법도 소개한다. 이와 같은 최적화 전략은 사용자에게 빠르고 신뢰성 높은 앱을 제공하는 핵심 요소이며, 지금 바로 REST를 GraphQL로 교체하고 콜백을 async\/await로 리팩토링하는 것이 권장된다.\n\n요약 키워드: GraphQL, async\/await, 네트워크 최적화, 오프라인-first, 타입 안정성","location":"https:\/\/medium.com\/@bhumibhuva18\/ios-networking-graphql-async-await-for-lightning-fast-data-fetching-17da5783e0cd"},{"keywords":["APPLE"],"title":"강력한 M5 칩으로 업그레이드된 Apple Vision Pro - Apple (KR)","comments":"소문이 무성하던 새로운 비전 프로가 드디어 나왔습니다. M5 칩으로 바뀌면서 성능도 좋아지고 배터리도 오래간다고 합니다. 듀얼 밴드 스트랩 뒷쪽에 무게추가 들어가서 균형이 잘 맞는다고 하네요","summary":"","location":"https:\/\/www.apple.com\/kr\/newsroom\/2025\/10\/apple-vision-pro-upgraded-with-the-powerful-m5-chip\/"}]}